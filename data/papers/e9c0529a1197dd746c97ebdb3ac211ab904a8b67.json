{
    "paperId": "e9c0529a1197dd746c97ebdb3ac211ab904a8b67",
    "title": "Testable algorithms for approximately counting edges and triangles in sublinear time and space",
    "year": 2025,
    "venue": "arXiv.org",
    "authors": [
        "T. Eden",
        "R. Rubinfeld",
        "A. Vasilyan"
    ],
    "doi": "10.48550/arXiv.2509.20351",
    "arxivId": "2509.20351",
    "url": "https://www.semanticscholar.org/paper/e9c0529a1197dd746c97ebdb3ac211ab904a8b67",
    "isOpenAccess": false,
    "openAccessPdf": "",
    "publicationTypes": [
        "JournalArticle"
    ],
    "s2FieldsOfStudy": [
        {
            "category": "Computer Science",
            "source": "external"
        },
        {
            "category": "Mathematics",
            "source": "s2-fos-model"
        },
        {
            "category": "Computer Science",
            "source": "s2-fos-model"
        }
    ],
    "abstract": "We consider the fundamental problems of approximately counting the numbers of edges and triangles in a graph in sublinear time. Previous algorithms for these tasks are significantly more efficient under a promise that the arboricity of the graph is bounded by some parameter $\\overline{\\alpha}$. However, when this promise is violated, the estimates given by these algorithms are no longer guaranteed to be correct. For the triangle counting task, we give an algorithm that requires no promise on the input graph $G$, and computes a $(1\\pm \\epsilon)$-approximation for the number of triangles $t$ in $G$ in time $O^*\\left( \\frac{m\\cdot \\alpha(G)}{t} + \\frac{m}{t^{2/3}} \\right)$, where $\\alpha(G)$ is the arboricity of the graph. The algorithm can be used on any graph $G$ (no prior knowledge the arboricity $\\alpha(G)$ is required), and the algorithm adapts its run-time on the fly based on the graph $G$. We accomplish this by trying a sequence of candidate values $\\tilde{\\alpha}$ for $\\alpha(G)$ and using a novel algorithm in the framework of testable algorithms. This ensures that wrong candidates $\\tilde{\\alpha}$ cannot lead to incorrect estimates: as long as the advice is incorrect, the algorithm detects it and continues with a new candidate. Once the algorithm accepts the candidate, its output is guaranteed to be correct with high probability. We prove that this approach preserves - up to an additive overhead - the dramatic efficiency gains obtainable when good arboricity bounds are known in advance, while ensuring robustness against misleading advice. We further complement this result with a lower bound, showing that such an overhead is unavoidable whenever the advice may be faulty. We further demonstrate implications of our results for triangle counting in the streaming model.",
    "citationCount": 0,
    "referenceCount": 59
}