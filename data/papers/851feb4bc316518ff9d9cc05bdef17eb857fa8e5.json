{
    "paperId": "851feb4bc316518ff9d9cc05bdef17eb857fa8e5",
    "title": "Transfer-Tuning: Reusing Auto-Schedules for Efficient Tensor Program Code Generation",
    "year": 2022,
    "venue": "International Conference on Parallel Architectures and Compilation Techniques",
    "authors": [
        "Perry Gibson",
        "José Cano"
    ],
    "doi": "10.1145/3559009.3569682",
    "arxivId": "2201.05587",
    "url": "https://www.semanticscholar.org/paper/851feb4bc316518ff9d9cc05bdef17eb857fa8e5",
    "isOpenAccess": true,
    "openAccessPdf": "https://dl.acm.org/doi/pdf/10.1145/3559009.3569682",
    "publicationTypes": [
        "JournalArticle",
        "Book",
        "Conference"
    ],
    "s2FieldsOfStudy": [
        {
            "category": "Computer Science",
            "source": "external"
        },
        {
            "category": "Computer Science",
            "source": "s2-fos-model"
        }
    ],
    "abstract": "Auto-scheduling for tensor programs is a process where a search algorithm automatically explores candidate schedules (program transformations) for a given program on a target hardware platform to improve its performance. However this can be a very time consuming process depending on the complexity of the tensor program and the capacity of the target device, with often many thousands of program variants being explored. To address this, in this paper we introduce the idea of transfer-tuning, a novel approach to identify and reuse auto-schedules between tensor programs. We demonstrate this concept using Deep Neural Networks (DNNs), taking sets of auto-schedules from pre-tuned DNNs and using them to reduce the inference time of a new DNN. We compare transfer-tuning against the state-of-the-art Ansor auto-scheduler, defining the maximum possible speedup for a given DNN model as what Ansor achieves using its recommended full tuning time. On a server-class CPU and across 11 widely used DNN models, we observe that transfertuning achieves up to 88.41% (49.13% on average) of this maximum speedup, while Ansor requires 6.5× more search time on average to match it. We also evaluate transfer-tuning on a constrained edge CPU and observe that the differences in search time are exacerbated, with Ansor requiring 10.8× more time on average to match transfer-tuning's speedup, which further demonstrates its value. Our code is available at https://github.com/gicLAB/transfer-tuning.",
    "citationCount": 14,
    "referenceCount": 43
}