{
    "paperId": "c33d62439b8acb73a1f2f132f6739cee1b4a83d6",
    "title": "Code Generation for Collectible Card Games with Complex APIs",
    "year": 2023,
    "venue": "The Florida AI Research Society",
    "authors": [
        "John Licato",
        "Logan Fields",
        "Brayden Hollis"
    ],
    "doi": "10.32473/flairs.36.133044",
    "arxivId": null,
    "url": "https://www.semanticscholar.org/paper/c33d62439b8acb73a1f2f132f6739cee1b4a83d6",
    "isOpenAccess": true,
    "openAccessPdf": "https://doi.org/10.32473/flairs.36.133044",
    "publicationTypes": [
        "JournalArticle"
    ],
    "s2FieldsOfStudy": [
        {
            "category": "Computer Science",
            "source": "external"
        },
        {
            "category": "Computer Science",
            "source": "s2-fos-model"
        }
    ],
    "abstract": "Large pre-trained language models (LMs) such as GPT-3 Codex are able to generate code remarkably well given prompts of natural language text. But if we want to use such LMs to generate code compatible with a specific API or library (e.g., an API which provides the environments in which certain rules, laws, or orders are to be carried out), the amount of computational and data resources required to fine-tune such models can be cost prohibitive to most organizations. Given these practical limitations, is it possible to utilize these massive code-generation LMs to write code compatible with a given API? We develop an algorithm that selects code examples using a smaller LM trained to predict which features of an API are likely to be used in the resulting code, which is a simpler problem than actually generating the code. The selected examples are then used to build a prompt for the larger LM, which in turn generates the final code. We demonstrate our results on a benchmark dataset derived from the collectible card game \"Magic: the Gathering,\" and obtain state-of-the-art results.",
    "citationCount": 1,
    "referenceCount": 39
}