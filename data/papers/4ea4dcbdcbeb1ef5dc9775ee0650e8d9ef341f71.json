{
    "paperId": "4ea4dcbdcbeb1ef5dc9775ee0650e8d9ef341f71",
    "title": "Modeling the Interplay between Loop Tiling and Fusion in Optimizing Compilers Using Affine Relations",
    "year": 2023,
    "venue": "ACM Transactions on Computer Systems",
    "authors": [
        "Jie Zhao",
        "Jinchen Xu",
        "Peng Di",
        "Wang Nie",
        "Jiahui Hu",
        "Yanzhi Yi",
        "Sijia Yang",
        "Zhen Geng",
        "Renwei Zhang",
        "Bojie Li",
        "Zhiliang Gan",
        "Xuefeng Jin"
    ],
    "doi": "10.1145/3635305",
    "arxivId": null,
    "url": "https://www.semanticscholar.org/paper/4ea4dcbdcbeb1ef5dc9775ee0650e8d9ef341f71",
    "isOpenAccess": false,
    "openAccessPdf": "",
    "publicationTypes": [
        "JournalArticle"
    ],
    "s2FieldsOfStudy": [
        {
            "category": "Computer Science",
            "source": "external"
        },
        {
            "category": "Computer Science",
            "source": "s2-fos-model"
        },
        {
            "category": "Mathematics",
            "source": "s2-fos-model"
        }
    ],
    "abstract": "Loop tiling and fusion are two essential transformations in optimizing compilers to enhance the data locality of programs. Existing heuristics either perform loop tiling and fusion in a particular order, missing some of their profitable compositions, or execute ad-hoc implementations for domain-specific applications, calling for a generalized and systematic solution in optimizing compilers. In this article, we present a so-called basteln (an abbreviation for backward slicing of tiled loop nests) strategy in polyhedral compilation to better model the interplay between loop tiling and fusion. The basteln strategy first groups loop nests by preserving their parallelism/tilability and next performs rectangular/parallelogram tiling to the output groups that produce data consumed outside the considered program fragment. The memory footprints required by each tile are then computed, from which the upward exposed data are extracted to determine the tile shapes of the remaining fusion groups. Such a tiling mechanism can construct complex tile shapes imposed by the dependences between these groups, which are further merged by a post-tiling fusion algorithm for enhancing data locality without losing the parallelism/tilability of the output groups. The basteln strategy also takes into account the amount of redundant computations and the fusion of independent groups, exhibiting a general applicability. We integrate the basteln strategy into two optimizing compilers, with one a general-purpose optimizer and the other a domain-specific compiler for deploying deep learning models. The experiments are conducted on CPU, GPU, and a deep learning accelerator to demonstrate the effectiveness of the approach for a wide class of application domains, including deep learning, image processing, sparse matrix computation, and linear algebra. In particular, the basteln strategy achieves a mean speedup of 1.8× over cuBLAS/cuDNN and 1.1× over TVM on GPU when used to optimize deep learning models; it also outperforms PPCG and TVM by 11% and 20%, respectively, when generating code for the deep learning accelerator.",
    "citationCount": 2,
    "referenceCount": 71
}