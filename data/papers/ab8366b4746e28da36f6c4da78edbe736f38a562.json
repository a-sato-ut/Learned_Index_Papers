{
    "paperId": "ab8366b4746e28da36f6c4da78edbe736f38a562",
    "title": "Dynamic Pruning for Recursive Joins",
    "year": 2025,
    "venue": "SIGMOD Conference Companion",
    "authors": [
        "Norifumi Nishikawa",
        "Akira Shimizu",
        "Akira Ito",
        "Shinji Fujiwara",
        "Yuto Hayamizu",
        "Masaru Kitsuregawa",
        "Kazuo Goda"
    ],
    "doi": "10.1145/3722212.3724434",
    "arxivId": null,
    "url": "https://www.semanticscholar.org/paper/ab8366b4746e28da36f6c4da78edbe736f38a562",
    "isOpenAccess": false,
    "openAccessPdf": "",
    "publicationTypes": [
        "Book",
        "JournalArticle",
        "Conference"
    ],
    "s2FieldsOfStudy": [
        {
            "category": "Computer Science",
            "source": "external"
        },
        {
            "category": "Computer Science",
            "source": "s2-fos-model"
        }
    ],
    "abstract": "This paper studies recursive join queries, which are witnessed in recent industrial applications such as event sequence analysis and traceability analysis. The recursive join query has the possibility to invoke deeply nested joins. Known pruning techniques generating pruning filters at compile time may not be able to exploit pruning opportunities, in particular for deep joins, at full. This paper explores dynamic pruning for recursive joins. Dynamic pruning generates pruning filters during query execution; a pruning filter is made based on the result of each recursive step, and it helps to more significantly reduce the amount of relation records to be accessed at the next recursive step, hence improving the query performance. This paper presents the intensive and extensive experiments that we have conducted with a commercial prototype database engine to clarify the performance benefit of dynamic pruning with four business benchmark scenarios. Our observation demonstrates that dynamic pruning significantly speeds up recursive join queries and non-recursive join queries having deeply nested joins; it works up to 135.6 times faster than the baseline case and 3.99 times faster even than the state-of-the-art pruning approach. In addition, our concise filter design only yielded negligibly small processing overheads for ineffective queries, even though the filter was intensively manipulated at runtime.",
    "citationCount": 0,
    "referenceCount": 113
}