{
    "paperId": "f34e6e031dc40c6f023a5186823dbe3d9b97e668",
    "title": "B-Trees Are Back: Engineering Fast and Pageable Node Layouts",
    "year": 2025,
    "venue": "Proc. ACM Manag. Data",
    "authors": [
        "Marcus MÃ¼ller",
        "Lawrence Benson",
        "Viktor Leis"
    ],
    "doi": "10.1145/3709664",
    "arxivId": null,
    "url": "https://www.semanticscholar.org/paper/f34e6e031dc40c6f023a5186823dbe3d9b97e668",
    "isOpenAccess": false,
    "openAccessPdf": "",
    "publicationTypes": [
        "JournalArticle"
    ],
    "s2FieldsOfStudy": [
        {
            "category": "Computer Science",
            "source": "external"
        },
        {
            "category": "Computer Science",
            "source": "s2-fos-model"
        },
        {
            "category": "Engineering",
            "source": "s2-fos-model"
        }
    ],
    "abstract": "Large main memory capacity and even larger data sets have motivated hybrid storage systems, which serve most transactions from memory, but can seamlessly transition to flash storage. In such systems, the data structure of choice is usually a B-Tree with pageable nodes. Most academic B-Tree work considers only fixed size records, making them unsuitable for most practical applications. Given the prevalence of B-Trees, surprisingly few available implementations and benchmarks of optimized B-Trees cover variable-sized records. In this paper, we describe an efficient B-Tree implementation supporting variable-sized records containing six known node layout optimizations. We evaluate each optimization to guide future implementations, and propose an optimized adaptive layout that can even compete with pure in-memory structures for many workloads. Our results show that well-engineered B-Trees can efficiently handle both in-memory and out-of-memory workloads.",
    "citationCount": 1,
    "referenceCount": 62
}