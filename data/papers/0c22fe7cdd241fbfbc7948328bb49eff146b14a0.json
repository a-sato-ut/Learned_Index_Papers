{
    "paperId": "0c22fe7cdd241fbfbc7948328bb49eff146b14a0",
    "title": "Kishu: Time-Traveling for Computational Notebooks",
    "year": 2024,
    "venue": "Proceedings of the VLDB Endowment",
    "authors": [
        "Zhaoheng Li",
        "Supawit Chockchowwat",
        "Ribhav Sahu",
        "Areet Sheth",
        "Yongjoo Park"
    ],
    "doi": "10.14778/3717755.3717759",
    "arxivId": "2406.13856",
    "url": "https://www.semanticscholar.org/paper/0c22fe7cdd241fbfbc7948328bb49eff146b14a0",
    "isOpenAccess": false,
    "openAccessPdf": "",
    "publicationTypes": [
        "JournalArticle"
    ],
    "s2FieldsOfStudy": [
        {
            "category": "Computer Science",
            "source": "external"
        },
        {
            "category": "Computer Science",
            "source": "s2-fos-model"
        }
    ],
    "abstract": "\n Computational notebooks (e.g., Jupyter, Google Colab) are widely used by data scientists. A key feature of notebooks is the interactive computing model of iteratively executing\n cells\n (i.e., a set of statements) and observing the result (e.g., model or plot). Unfortunately, existing notebook systems do not offer\n time-traveling to past states\n : when the user executes a cell, the notebook\n session state\n consisting of user-defined variables can be\n irreversibly modified\n —e.g., the user cannot 'un-drop' a dataframe column. This is because, unlike DBMS, existing notebook systems do not keep track of the session state. Existing techniques for checkpointing and restoring session states, such as OS-level memory snapshot or application-level session dump, are insufficient: checkpointing can incur prohibitive storage costs and may fail, while restoration can only be inefficiently performed from scratch by fully loading checkpoint files.\n \n \n In this paper, we introduce a new notebook system, Kishu, that offers time-traveling to and from arbitrary notebook states using an efficient and fault-tolerant incremental checkpoint and checkout mechanism. Kishu creates incremental checkpoints that are small and correctly preserve complex inter-variable dependencies at a novel\n Co-variable\n granularity. Then, to return to a previous state, Kishu accurately identifies the\n state difference\n between the current and target states to perform incremental checkout at sub-second latency with minimal data loading. Kishu is compatible with 146 object classes from popular data science libraries (e.g., Ray, Spark, PyTorch), and reduces checkpoint size and checkout time by up to 4.55× and 9.02×, respectively, on a variety of notebooks.\n",
    "citationCount": 5,
    "referenceCount": 135
}