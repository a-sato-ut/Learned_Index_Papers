{
    "paperId": "e41f808daf46e384e5b942d81c8e255edc54ba7d",
    "title": "Using SBPF to Accelerate Kernel Memory Access From Userspace",
    "year": 2025,
    "venue": "arXiv.org",
    "authors": [
        "Boming Kong",
        "Zhizhou Zhang",
        "Jonathan Balkind"
    ],
    "doi": "10.48550/arXiv.2506.22632",
    "arxivId": "2506.22632",
    "url": "https://www.semanticscholar.org/paper/e41f808daf46e384e5b942d81c8e255edc54ba7d",
    "isOpenAccess": false,
    "openAccessPdf": "",
    "publicationTypes": [
        "JournalArticle"
    ],
    "s2FieldsOfStudy": [
        {
            "category": "Computer Science",
            "source": "external"
        },
        {
            "category": "Computer Science",
            "source": "s2-fos-model"
        },
        {
            "category": "Engineering",
            "source": "s2-fos-model"
        }
    ],
    "abstract": "The cost of communication between the operating system kernel and user applications has long blocked improvements in software performance. Traditionally, operating systems encourage software developers to use the system call interface to transfer (or initiate transfer of) data between user applications and the kernel. This approach not only hurts performance at the software level due to memory copies between user space address spaces and kernel space address spaces, it also hurts system performance at the microarchitectural level by flushing processor pipelines and other microarchitectural state. In this paper, we propose a new communication interface between user applications and the kernel by setting up a shared memory region between user space applications and the kernel's address space. We acknowledge the danger in breaking the golden law of user-kernel address space isolation, so we coupled a uBPF VM (user-space BPF Virtual Machine) with shared memory to control access to the kernel's memory from the user's application. In this case, user-space programs can access the shared memory under the supervision of the uBPF VM (and the kernel's blessing of its shared library) to gain non-blocking data transfer to and from the kernel's memory space. We test our implementation in several use cases and find this mechanism can bring speedups over traditional user-kernel information passing mechanisms.",
    "citationCount": 0,
    "referenceCount": 43
}