{
    "paperId": "4210ae310f240221c9038ded5eaf18c090a32a98",
    "title": "Engineering Compact Data Structures for Rank and Select Queries on Bit Vectors",
    "year": 2022,
    "venue": "SPIRE",
    "authors": [
        "Florian Kurpicz"
    ],
    "doi": "10.48550/arXiv.2206.01149",
    "arxivId": "2206.01149",
    "url": "https://www.semanticscholar.org/paper/4210ae310f240221c9038ded5eaf18c090a32a98",
    "isOpenAccess": true,
    "openAccessPdf": "https://arxiv.org/pdf/2206.01149",
    "publicationTypes": [
        "JournalArticle"
    ],
    "s2FieldsOfStudy": [
        {
            "category": "Computer Science",
            "source": "external"
        },
        {
            "category": "Engineering",
            "source": "s2-fos-model"
        },
        {
            "category": "Computer Science",
            "source": "s2-fos-model"
        }
    ],
    "abstract": "Bit vectors are fundamental building blocks of many succinct data structures. They can be used to represent graphs, are an important part of many text indices in the form of the wavelet tree, and can be used to encode ordered sequences of integers as Elias-Fano codes. To do so, two queries have to be answered: namely rank and select queries. Given a position in the bit vector, a rank query returns the number of 1-bits before that position. A select query, given a parameter $j$, returns the position of the $j$-th 1-bit. On a length-n bit vector, both queries can be answered in $O(1)$ time and require $o(n)$ bits of additional space. In practice, the smallest (uncompressed) rank and select data structure cs-poppy has a space overhead of $\\approx$ 3.51% [Zhou et al., SEA 13]. In this paper, we present an improved rank and select data structure that has the same space overhead but can answer queries up to 8% (rank) and 16.5% (select) faster compared with cs-poppy.",
    "citationCount": 21,
    "referenceCount": 29
}