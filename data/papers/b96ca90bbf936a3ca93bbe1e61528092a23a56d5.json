{
    "paperId": "b96ca90bbf936a3ca93bbe1e61528092a23a56d5",
    "title": "A Deep Learning Based Cost Model for Automatic Code Optimization",
    "year": 2021,
    "venue": "Conference on Machine Learning and Systems",
    "authors": [
        "Riyadh Baghdadi",
        "Massinissa Merouani",
        "Mohamed-Hicham Leghettas",
        "Kamel Abdous",
        "T. Arbaoui",
        "K. Benatchba",
        "S. Amarasinghe"
    ],
    "doi": null,
    "arxivId": "2104.04955",
    "url": "https://www.semanticscholar.org/paper/b96ca90bbf936a3ca93bbe1e61528092a23a56d5",
    "isOpenAccess": false,
    "openAccessPdf": "",
    "publicationTypes": [
        "JournalArticle"
    ],
    "s2FieldsOfStudy": [
        {
            "category": "Computer Science",
            "source": "external"
        },
        {
            "category": "Computer Science",
            "source": "s2-fos-model"
        }
    ],
    "abstract": "Enabling compilers to automatically optimize code has been a longstanding goal for the compiler community. Efficiently solving this problem requires using precise cost models. These models predict whether applying a sequence of code transformations reduces the execution time of the program. Building an analytical cost model to do so is hard in modern x86 architectures due to the complexity of the microarchitecture. In this paper, we present a novel deep learning based cost model for automatic code optimization. This model was integrated in a search method and implemented in the Tiramisu compiler to select the best code transformations. The input of the proposed model is a set of simple features representing the unoptimized code and a sequence of code transformations. The model predicts the speedup expected when the code transformations are applied. Unlike previous models, the proposed one works on full programs and does not rely on any heavy feature engineering. The proposed model has only 16% of mean absolute percentage error in predicting speedups on full programs. The proposed model enables Tiramisu to automatically find code transformations that match or are better than state-of-the-art compilers without requiring the same level of heavy feature engineering required by those compilers.",
    "citationCount": 79,
    "referenceCount": 36
}