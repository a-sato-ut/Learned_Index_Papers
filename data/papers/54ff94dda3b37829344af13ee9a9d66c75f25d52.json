{
    "paperId": "54ff94dda3b37829344af13ee9a9d66c75f25d52",
    "title": "Scheduling Languages: A Past, Present, and Future Taxonomy",
    "year": 2024,
    "venue": "arXiv.org",
    "authors": [
        "Mary W. Hall",
        "C. Oancea",
        "A. Elster",
        "Ari Rasch",
        "Sameeran Joshi",
        "Amir Mohammad Tavakkoli",
        "Richard Schulze"
    ],
    "doi": "10.48550/arXiv.2410.19927",
    "arxivId": "2410.19927",
    "url": "https://www.semanticscholar.org/paper/54ff94dda3b37829344af13ee9a9d66c75f25d52",
    "isOpenAccess": false,
    "openAccessPdf": "",
    "publicationTypes": [
        "JournalArticle"
    ],
    "s2FieldsOfStudy": [
        {
            "category": "Computer Science",
            "source": "external"
        },
        {
            "category": "Computer Science",
            "source": "s2-fos-model"
        }
    ],
    "abstract": "Scheduling languages express to a compiler a sequence of optimizations to apply. Compilers that support a scheduling language interface allow exploration of compiler optimizations, i.e., exploratory compilers. While scheduling languages have become a common feature of tools for expert users, the proliferation of these languages without unifying common features may be confusing to users. Moreover, we recognize a need to organize the compiler developer community around common exploratory compiler infrastructure, and future advances to address, for example, data layout and data movement. To support a broader set of users may require raising the level of abstraction. This paper provides a taxonomy of scheduling languages, first discussing their origins in iterative compilation and autotuning, noting the common features and how they are used in existing frameworks, and then calling for changes to increase their utility and portability.",
    "citationCount": 1,
    "referenceCount": 159
}