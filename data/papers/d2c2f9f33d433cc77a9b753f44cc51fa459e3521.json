{
    "paperId": "d2c2f9f33d433cc77a9b753f44cc51fa459e3521",
    "title": "S/C: Speeding up Data Materialization with Bounded Memory",
    "year": 2023,
    "venue": "IEEE International Conference on Data Engineering",
    "authors": [
        "Zhaoheng Li",
        "Xinyu Pi",
        "Yongjoo Park"
    ],
    "doi": "10.1109/ICDE55515.2023.00393",
    "arxivId": "2303.09774",
    "url": "https://www.semanticscholar.org/paper/d2c2f9f33d433cc77a9b753f44cc51fa459e3521",
    "isOpenAccess": true,
    "openAccessPdf": "http://arxiv.org/pdf/2303.09774",
    "publicationTypes": [
        "JournalArticle",
        "Conference"
    ],
    "s2FieldsOfStudy": [
        {
            "category": "Computer Science",
            "source": "external"
        },
        {
            "category": "Computer Science",
            "source": "s2-fos-model"
        }
    ],
    "abstract": "With data pipeline tools and the expressiveness of SQL, managing interdependent materialized views (MVs) are becoming increasingly easy. These MVs are updated repeatedly upon new data ingestion (e.g., daily), from which database admins can observe performance metrics (e.g., refresh time of each MV, size on disk) in a consistent way for different types of updates (full vs. incremental) and for different systems (single node, distributed, cloud-hosted). One missed opportunity is that existing data systems treat those MV updates as independent SQL statements without fully exploiting their dependency information and performance metrics. However, if we know that the result of a SQL statement will be consumed immediately after for subsequent operations, those subsequent operations do not have to wait until the early results are fully materialized on storage because the results are already readily available in memory. Of course, this may come at a cost because keeping those results in memory (even temporarily) will reduce the amount of available memory; thus, our decision should be careful.In this paper, we introduce a new system, called S/C, which tackles this problem through efficient creation and update of a set of MVs with acyclic dependencies among them. S/C judiciously uses bounded memory to reduce the end-to-end MV refresh time by short-circuiting expensive reads and writes; S/C’s objective function accurately estimates the time savings from keeping intermediate data in memory for particular periods. Our solution jointly optimizes an MV refresh order, what data to keep in memory, and when to release the data from memory. At a high level, S/C still materializes all data exactly as defined in MV definitions; thus, it does not impact any service-level agreements. In our experiments with TPC-DS datasets (up to 1TB), we show that S/C's optimization can speedup end-to-end runtime by 1.04×–5.08× with (only) 1.6GB memory.",
    "citationCount": 5,
    "referenceCount": 88
}