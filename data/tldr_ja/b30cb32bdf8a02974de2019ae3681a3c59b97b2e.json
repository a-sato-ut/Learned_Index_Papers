{
  "paperId": "b30cb32bdf8a02974de2019ae3681a3c59b97b2e",
  "title": "ComboTree: A Persistent Indexing Structure with Universal Operational Efficiency and Scalability",
  "abstract": "To leverage the larger-than-DRAM capacity and close-to-DRAM performance of persistent memory (PM) to build future memory systems, more scalable and efficient indexing structures are of paramount importance. However, as we evaluate existing PM indexing structures, we find that (1) both ordered and unordered indexing structures cannot support efficiently all KV operation types, i.e., Put, Get, Delete and Scan, and (2) the majority of indexes scale poorly as the PM capacity and dataset increases, i.e., the decreasing throughput of ordered indexes with the growth of dataset and the blocking of foreground requests by costly hash resizing of unordered indexes. To provide better operational efficiency on both point accesses and range queries for persistent memory in the ever-increasing volume of data, this paper proposes ComboTree, a three-tiered indexing structure with a sorted key space. In ComboTree, we break the global B+Tree into multiple low height B+Trees (Tier C) and arrange them with a sorted array (Tier B). Further, we accelerate the lookup of the sorted array by cumulative distribution function (Tier A). Last but not least, a background resizing policy is proposed to avoid performance degradation when the capacity of the ComboTree grows. We implement and evaluate ComboTree on Intels Optane DCPMM. Test results show that ComboTree delivers 2.1 - 3.6 put throughput and 1.5 - 2.1 get throughput of the state-of-art sorted indexes. Furthermore, ComboTree is 1.27 faster than the efficient B+Tree variant in various scan granularities, and it is open-sourced.",
  "tldr_ja": "ComboTreeは、永続メモリ用に設計された三層インデックス構造で、データ量の増加に伴う効率的なKV操作（Put、Get、Delete、Scan）を実現します。従来のインデックスのスケーラビリティの問題を解決し、従来のB+ツリーよりも最大3.6倍のスループットを提供します。"
}