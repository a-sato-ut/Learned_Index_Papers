{
  "paperId": "7913430d7659f62eda2539ce78353209a2d32a24",
  "title": "Implementation Of Dynamic De Bruijn Graphs Via Learned Index",
  "pdfPath": "7913430d7659f62eda2539ce78353209a2d32a24.pdf",
  "text": "Implementation Of Dynamic De Bruijn Graphs\nVia Learned Index\nRiccardo Nigrelli\nJune 19, 2024\nAbstract\nDe Bruijn graphs are essential for sequencing data analysis and must be efficiently constructed and stored\nfor large-scale population studies. They also need to be dynamic to allow updates such as adding or removing\nedges and nodes. Existing dynamic implementations include DynamicBOSS and dynamicDBG. In 2018, a\nnew family of data structures called learned indexes was introduced by Tim Kraska and Alex Beutel, with a\nparticularly efficient implementation proposed by Paolo Ferragina and Giorgio Vinciguerra in 2020. This paper\npresents a new method for implementing De Bruijn graphs using learned indexes and compares its performance\nwith current implementations. The new method shows improved time and memory efficiency for edge and node\ninsertions, particularly with large datasets (over 110 million k-mers).\nIntroduction\nIn the past two decades, genome assembly from vast\namounts of DNA sequencing data has been a ma-\njor computational challenge in molecular biology, rec-\nognized as an NP-hard problem [9]. Traditionally,\nlong-read assembly algorithms use an overlap graph,\nwhere nodes represent reads and edges exist if there is\nsufficient overlap between reads. This method, how-\never, struggles with the massive datasets produced by\nnext-generation sequencing (NGS) technologies due\nto computational constraints and the short length of\nreads.\nTo address these limitations, many recent algo-\nrithms have shifted to using de Bruijn graphs [8, 10,\n11, 12]. In a de Bruijn graph [2], each node repre-\nsents a k-mer (a substring of length kfrom the reads),\nand edges denote exact overlaps of length k−1. Al-\nthough de Bruijn graphs can be constructed more ef-\nficiently than overlap graphs, they still require signifi-\ncant memory, making the overlap phase a bottleneck.\nRecent advances in combining data structures with\nMachine Learning (ML) have introduced learned data\nstructures [7], which replace traditional components\nlike arrays and trees with ML models. This approach\nleverages data patterns to improve space efficiency\nand time performance across various applications.\nTheaimofthisarticleistopresentanewimplemen-\ntation of de Bruijn graphs using learned data struc-\ntures, specificallystartingwiththePGM-Index[5], an\nefficient learned index [4]. The performance, in terms\nof time and memory, is then compared with existing\ndynamic implementations such as DynamicBOSS [1]\nand dynamicDBG [3].Methodology\nFerragina and Vinciguerra in [5] not only present\nthe PGM-Index from a theoretical and computational\nperspective but also provide an implementation in\nC++. Therefore, it was decided to experimentally ver-\nify if this type of learned index, specifically the dy-\nnamic version, would be a valid starting point for the\nimplementation of de Bruijn graphs.\nThis particular implementation of a dynamic\nlearned index is used when indexing elements con-\nsisting of a key-value pair (k, v)contained within a\nvector. Indeed, the Dynamic PGM-Index is imple-\nmented as a parametric class in KandV, where K\nandVrepresent the types of the key and the value,\nrespectively. The behavior of the main operations are\nthe following:\n•creation: This involves creating nempty levels\nup to the first level capable of containing all the\nelements of the input vector. A PGM-Index is\nthen constructed and associated with this level.\n•insertion: The correct insertion point within the\nfirst free level must be found so that the elements\nremain always sorted and the maximum capacity\nof the level is not violated.\n•deletion: The key-value pair is inserted into the\nlowestlevelcapableofcontainingit, assigningthe\ntombstone to the value of the pair.\n•search: Usingthekeyofthepair (k, v),alevel-by-\nlevel scan is performed starting from the lowest\none. Foreachlevel, itischeckedwhetheraPGM-\nIndex is associated with it. If so, the search is\nperformed within the PGM-Index; otherwise, it\nis conducted on the level itself.\nThis type of learned index can be a good start-\ning point for creating an abstraction of de Bruijn\n1arXiv:2406.12339v1  [cs.DS]  18 Jun 2024\n\ngraphs. However, the current implementation is very\nlimiting. Interacting only with sets whose elements\nare key-value pairs is redundant for graphs since the\nvalue field would never be used. Therefore, it was de-\ncided to improve the following aspects of the current\nimplementation: the ability to index vectors of sin-\ngle elements and not just key-value pairs, finding a\nmemory-efficient method for handling deletions, and\nimplementing a procedure to remove any duplicate\nand/or deleted elements.\nAdditionally, it was decided to profile the heap\nmemory during the creation process to observe the\ntrends and identify any possible points for further op-\ntimization. It was found that at the end of the cre-\nation process, the memory contains both the index\nand the vector on which it was built. To resolve this\nissue, by utilizing the library offered by KMC [6], it\nwas possible to develop an onlineindex construction\nprocedure.\nEvaluation\nOnce the implementation phase was completed, this\nnew approach to implementing de Bruijn graphs was\nverified and validated. Performance analysis in terms\nof time and memory was conducted using the Dy-\nnamic PGM-Index Set on a real dataset, E. Coli K-\n12 substr. MG1655 . Additionally, comparisons were\nmade with existing literature implementations: Dy-\nnamicBOSS [1] and standard Dynamic PGM-Index.\nThe E. Coli dataset was chosen as it is commonly\nused by authors experimenting with DynamicBOSS.\nUnfortunately, comparison with dynamicDBG [3] was\nnot possible as its runtime implementation encoun-\nterederrorswithanyinputdataset. Foursubsetswere\ngenerated from the initial dataset, comprising 20000,\n200000,2000000 and 14000000 reads.\nFor the creation operation, the complete dataset\nwas used. For modification operations (inser-\ntions/deletions) and searches, datasets were divided\ninto two parts: 80% for creating data structures and\n20% for executing the operation. Performance anal-\nysis for search operations was also conducted follow-\ning modifications to data structures. This involved\ninserting and/or deleting elements from a graph fol-\nlowed by search operations to verify that modification\noperations did not affect search operations.\n•creation: The implementation based on sets\nshown better memory efficiency compared to\nthe key-value pair-based approach, while hav-\ning comparable time performance. Dynamic-\nBOSS, however, exhibited worse time perfor-\nmance across all datasets but proved the best\nsolution in terms of memory (based solely on a\nBWT and bit vector). In Figure 1 are shown the\nresults.\n•insertion: DynamicBOSS could not be tested on\n(a)\n(b)\nFigure 1: Creation of a de Bruijn graph as a function\nof the number of reads. Note that the y-axis scale\nis logarithmic. (a) Execution time (b) Peak memory\nusage.\nlarger datasets due to excessive execution time.\nImplementations based on PGM-Index, however,\nshown reasonable performance times across all\ndatasets (just over half a minute on the largest\ndataset). In Figure 2 are shown the results.\n•deletion: Performance for deletion operations in\nPGM-Index-basedimplementationsfollowedsim-\nilar trends as insertion. Again, testing with Dy-\nnamicBOSS could not be completed for the two\nlargest datasets. In Figure 3 are shown the re-\nsults.\n•search: DynamicBOSSdidnotdemonstratecom-\npetitive performance in either time or memory.\nPGM-Index-basedimplementationsshownequiv-\nalent time performance, with single-element-\nbased approaches prevailing in terms of mem-\nory. Performance analysis of search operations\nfollowing insertions and/or deletions yielded sim-\nilar times and memory usage as those observed\n2\n\n(a)\n(b)\nFigure 2: Insertions within a de Bruijn graph as a\nfunction of the number of reads. Note that the y-\naxis scale is logarithmic. (a) Execution time (b) Peak\nmemory usage.\nimmediatelyaftercreation. InFigure4areshown\nthe results.\nConclusions and Future Works\nFirst and foremost, it should be highlighted that all\nthe objectives set at the beginning of the project have\nbeen achieved. The implementation of the Dynamic\nPGM-Index Set data structure is derived from the im-\nplementation of the Dynamic PGM-Index, thus rep-\nresented through a template to enable the indexing of\nvectors of any numeric type. Moreover, all possible\noperations have been tested through unit tests.\nThe implementation presented here proves to be a\nvalid alternative to those currently available in the\nliterature for the representation of dynamic de Bruijn\ngraphs. In fact, it has been shown to be superior both\nin terms of time and memory efficiency for both mod-\nification operations and searches. The PGM-Index\nproved to be less efficient in terms of memory during\n(a)\n(b)\nFigure 3: Deletions within a de Bruijn graph as a\nfunction of the number of reads. Note that the y-\naxis scale is logarithmic. (a) Execution time (b) Peak\nmemory usage.\nthe creation process; however, despite this, it was still\nbetter in terms of time compared to DynamicBOSS.\nThe current implementation of the Dynamic PGM-\nIndex Set leaves points still open. Some future devel-\nopments could be:\n1. extension of the representation of k-mers using\ntheWide-integer library to allow for kvalues up\nto 255, the maximum value in KMC. Currently,\nthe implementation is limited to k-mers of length\n31. For the extension, a method needs to be\nfound to convert the KMC representation (a vec-\ntor of up to four elements) into the corresponding\ntype offered by Wide-integer for subsequent use\nin index construction;\n2. implementation of a function to insert and/or\ndelete a sorted set of k-mers without the need\nto iterate through it. One possible solution is\nto perform a pairwise_merge of the set with the\nfirsti−1levels and use the result to build level i,\n3\n\n(a)\n(b)\nFigure 4: Memberships within a de Bruijn graph as\na function of the number of reads. Note that the y-\naxis scale is logarithmic. (a) Execution time (b) Peak\nmemory usage.\nwhere iis the first level that has sufficient space\nto contain the result of the merge;\n3. perform modifications and deletions of elements\nphysically rather than logically. This could be\nimplemented by locating the level containing the\nelement to be modified or deleted, making the\nmodification within the levels, and then recon-\nstructing the associated PGM-Indexes. Another\npossibility is to clean the entire index to have a\nsingle level on which to perform the search, make\nthe modification, and associate a new PGM-\nIndex.\nAnother potential future development could be the\nfeasibility analysis of using Dynamic PGM-Indexes\nfor the representation of colored de Bruijn graphs. In\nthis case, indexing key-value pairs is useful because\na specific color is associated with each k-mer. If a\nk-mer can be associated with more than one color, a\nbitmask could be used as the value, where each bit\nrepresents a color.References\n[1] Bahar Alipanahi et al. “Succinct dynamic\nde Bruijn graphs”. In: Bioinformatics 37.14\n(2021), pp. 1946–1952. doi:10 . 1093 /\nbioinformatics/btaa546 .\n[2] Nicolaas Govert de Bruijn. “A combinatorial\nproblem”. In: Proc. Koninklijke Nederlandse\nAcademie van Wetenschappen . Vol. 49. 1946,\npp. 758–764.\n[3] Victoria G. Crawford et al. “Practical dynamic\nde Bruijn graphs”. In: Bioinformatics 34.24\n(2018), pp. 4189–4195.\n[4] Paolo Ferragina, Fabrizio Lillo, and Giorgio\nVinciguerra. “Why Are Learned Indexes So Ef-\nfective?” In: Proceedings of the 37th Interna-\ntional Conference on Machine Learning, ICML\n2020, 13-18 July 2020, Virtual Event . Vol. 119.\nProceedings of Machine Learning Research.\nPMLR, 2020, pp. 3123–3132.\n[5] Paolo Ferragina and Giorgio Vinciguerra.\n“The PGM-index: a fully-dynamic compressed\nlearned indexwith provableworst-casebounds”.\nIn:Proc. VLDB Endow. 13.8 (2020), pp. 1162–\n1175.\n[6] Marek Kokot, Maciej Dlugosz, and Sebastian\nDeorowicz.“KMC3:countingandmanipulating\nk-mer statistics”. In: Bioinform. 33.17 (2017),\npp. 2759–2761.\n[7] Tim Kraska et al. “The Case for Learned Index\nStructures”. In: Proceedings of the 2018 Inter-\nnational Conference on Management of Data,\nSIGMOD Conference 2018, Houston, TX, USA,\nJune 10-15, 2018 . ACM, 2018, pp. 489–504.\n[8] Ruiqiang Li et al. “De novo assembly of hu-\nman genomes with massively parallel short read\nsequencing”. In: Genome research 20.2 (2010),\npp. 265–272.\n[9] Eugene W.Myers. “Toward Simplifying andAc-\ncurately Formulating Fragment Assembly”. In:\nJ. Comput. Biol. 2.2 (1995), pp. 275–290.\n[10] Pavel A. Pevzner, Haixu Tang, and Michael\nS. Waterman. “An Eulerian path approach to\nDNA fragment assembly”. In: Proceedings of\nthe National Academy of Sciences 98.17 (2001),\npp. 9748–9753.\n[11] Jared T Simpson et al. “ABySS: a parallel\nassembler for short read sequence data”. In:\nGenome research 19.6 (2009), pp. 1117–1123.\n[12] Daniel R Zerbino and Ewan Birney. “Velvet: al-\ngorithms for de novo short read assembly us-\ning de Bruijn graphs”. In: Genome research 18.5\n(2008), pp. 821–829.\n4",
  "textLength": 13042
}