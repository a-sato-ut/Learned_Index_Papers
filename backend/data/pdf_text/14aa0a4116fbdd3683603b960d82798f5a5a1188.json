{
  "paperId": "14aa0a4116fbdd3683603b960d82798f5a5a1188",
  "title": "Dynamic Necklace Splitting",
  "pdfPath": "14aa0a4116fbdd3683603b960d82798f5a5a1188.pdf",
  "text": "Dynamic Necklace Splitting\nRishi Advani/envel⌢pe\nUniversity of Illinois Chicago, IL, USA\nAbolfazl Asudeh/envel⌢pe\nUniversity of Illinois Chicago, IL, USA\nMohsen Dehghankar/envel⌢pe\nUniversity of Illinois Chicago, IL, USA\nStavros Sintos/envel⌢pe\nUniversity of Illinois Chicago, IL, USA\nAbstract\nThe necklace splitting problem is a classic problem in fair division with many applications, including\ndata-informed fair hash maps. We extend necklace splitting to a dynamic setting, allowing for\nrelocation, insertion, and deletion of beads. We present linear-time, optimal algorithms for the\ntwo-color case that support all dynamic updates. For more than two colors, we give linear-time,\noptimal algorithms for relocation subject to a restriction on the number of agents. Finally, we\npropose a randomized algorithm for the two-color case that handles all dynamic updates, guarantees\napproximate fairness with high probability, and runs in polylogarithmic time when the number of\nagents is small.\n2012 ACM Subject ClassificationMathematics of computing →Discrete mathematics; Theory of\ncomputation→Algorithmic game theory; Theory of computation→Online algorithms\nKeywords and phrasesNecklace splitting, dynamic algorithms, fair division\n1 Introduction\nThe necklace splitting problem, first introduced by Bhatt and Leiserson [ 6], is a classic\ncombinatorial fair division problem. In this work, we extend it to a dynamic setting, enabling\napplications such as data-informed fair hash maps and improved load-balancing among\nmultiple servers.\n1.1 Problem Setup\nWe are given a string Sofmbeads. We denote the jth element in SbyS[j]and the substring\nfrom thej1th element to the j2th element by[ j1,j2].1Each bead is a certaincolor i∈[n].\nLetmi=|{b∈S|bis colori}| . Letkbe the number of agents. For simplicity, assume that\nkdividesmifor alli. The goal is to find a set Pconsisting of cuts of Swith the property\nthat the resulting set of intervals can be allocated to the agents in such a way that each\nagent receives exactly mi/kbeads of color i. An overview of the notation is given in Table 1.\nWe are interested in the dynamic case. We are given an instance of the necklace splitting\nproblem solved using an offline algorithm (see Section 2). We allow the following dynamic\nupdates:\nRelocationBeadS[j 1]is moved to indexj 2.\nInsertionαkbeads of the same color are inserted intoS.\nDeletionαkbeads of the same color are deleted fromS.\nWe can also allow for recoloring of beads by performing successive deletion and insertion.\n1For ease of notation, whenj 1> j2, we write[j 1, j2]instead of[j 1, m]∪[1, j 2].\n\n2 Dynamic Necklace Splitting\nTable 1Key notation used in the paper.\nNotation Description\nSThe string representing the necklace\nPThe set of cuts inS\nmThe number of beads inS\nmiThe number of beads of coloriinS\nnThe number of distinct colors of beads inS\nkThe number of agents\nGThe neighborhood graph associated withP\nTThe neighborhood tree associated withSandP\nAAn arbitrary agent\n1.2 Contributions\nHere we give a brief overview of our contributions:\nWe introduce and formalize the problem of dynamic necklace splitting.\nWe design a linear-time algorithm for swapping adjacent beads when n= 2that achieves\nthe optimal bound of2( k−1)cuts. We design two linear-time algorithms for relocation\nof arbitrary distance when n= 2that achieve the optimal bound of2( k−1)cuts. We\nalso design a linear-time algorithm for relocation with looser bounds for general n≥2\n(Section 3).\nWe introduce theMinNodeMaxFlowproblem and prove it to be NP-complete. We design\nan approximation algorithm for special cases that we then use as part of an algorithm\nto efficiently perform batch relocation when n= 2with the optimal number of cuts\n(Section 4).\nWe design two linear-time algorithms for relocation with general n≥2whenm=nk\nthat achieve the optimal bound ofn(k−1)cuts (Section 5).\nWe adapt our algorithm for batch relocation to be used for efficient insertion and deletion\n(Section 6).\nWe design a randomized, polylogarithmic-time algorithm for relocation, insertion, and\ndeletion that produces an approximately fair set of cuts with high probability when n= 2\n(Section 7).\nSee Table 2 for a comparison of our algorithms.\n1.3 Data Structures\nThe choice of which data structures to use to store information about the necklace has a\nsignificant impact on the running time of our algorithms. We implement the necklace itself\nas a doubly linked list, allowing for efficient dynamic updates. Each node/bead also stores\nits index, the agent to whom it belongs, and a pointer to the next node/bead belonging to\nthe same agent. Given any bead, this allows us to find the subsequence of beads belonging\nto the same agent inO(m/k)time.\nNote that the cuts are stored implicitly and can be explicitly generated in O(m)time by\niterating through the necklace and identifying pairs of consecutive beads where the associated\nagents switch. Alternatively, with minimal added cost, we can maintain a hash table mapping\neach possible pair of agents to the set of cuts adjacent to both agents.\n\nR. Advani, A. Asudeh, M. Dehghankar, and S. Sintos 3\nTable 2Key details of dynamic algorithms presented in the paper.\nAlgorithmnUpdate Exact? Optimal # of cuts? Running time (per bead)\nSwap2Swap✓ ✓O/parenleftig\nm\nk/parenrightig\nPath2Any✓ ✓O/parenleftig\nk+k′m\nk/parenrightig\nColorPath2Any✓ ✓O/parenleftig\nk+k′m\nk/parenrightig\nFenceAny Relocation✓ ✗O/parenleftig\nm\nkn/parenrightig\nBatchPath2Any✓ ✓O/parenleftig\nlogk+k′m\nkm′/parenrightig\nDenseSwapm/kSwap✓ ✓O(n)\nDenseJumpm/kRelocation✓ ✓O(k+n)\nApprox2Any✗N/AO/parenleftbig\nk222kε−2(logm)2+ logm/parenrightbig\nFor certain algorithms, we need to make use of aneighborhood graph Gwhere each vertex\nrepresents an agent and two vertices are joined by an edge if the corresponding agents possess\nadjacent beads. We implement Gas an adjacency list. If the beads corresponding to k′\nagents are reassigned among the same agents, Gcan be updated in O(k′m/k)time. We\nremove all edges incident to the k′agents and then determine which edges to add by iterating\nthrough thek′m/kbeads assigned to those agents.\n1.4 Related Work\nSoon after the necklace splitting problem was originally introduced [ 6], Goldberg and West [ 9]\nproved that a solution always exists if k= 2. Alon and West [ 3] gave a simpler proof using\nthe Borsuk–Ulam theorem [ 7], and Alon [ 1] generalized the results to k>2. Finally, Alon\nand Graur [ 2] discovered an efficient approximation algorithm for finding a solution with few\ncuts. Alon and Graur [ 2] also consider an online variation of the problem. They derive lower\nand upper bounds on the number of cuts needed when k= 2based on the value of n. They\nalso generalize some of these results to thek>2case.\nIn addition to necklace splitting, other fair division problems can be extended to dynamic\nsettings. Kash et al. [ 13] study a fair division problem with divisible goods where agents with\nLeontiefpreferencesarriveovertimeandgoodsmustbeirrevocablyallocated. Benadeetal.[ 5]\nstudy the problem of allocating indivisible goods that arrive in an online manner, again with\nirrevocable decisions. He et al. [ 11] generalize this to a setting where reallocation is allowed\nbut expensive.\n1.5 Applications\nIn this section, we discuss several key applications of the dynamic necklace splitting problem.\n1.5.1 Fair Hash Maps\nA core application of dynamic necklace splitting is designing practical fair hash maps.\nIn addition to ensuring fairness, such data-informed hash maps can even be faster than\ntraditional hash maps [ 14,17]. Shahbazi et al. [ 19] use the static necklace splitting problem\n\n4 Dynamic Necklace Splitting\nto design hash maps that satisfy group fairness. However, making dynamic updates to these\nhash maps is infeasible without a dynamic solution to the necklace splitting problem.\nFor a concrete application, consider the use of fair hash maps to maintain user information\non a social network. Whenever new users join the network, their data needs to be efficiently\nadded to the hash map, and when users leave, their data needs to be efficiently removed.\nAs users’ attributes change, their data needs to be efficiently updated (corresponding to\nrelocation of beads in a necklace).\nAnother concrete application involves table joins in data lakes. Consider an organization\nseeking to share its data with third parties. The data is stored in a data lake and includes\nsensitive information as primary keys for certain tables. To protect patient privacy, the\ndata needs to be hashed, which introduces the risk of hash collision. A fair hashing scheme\nmust be used to ensure any resulting errors when joining on the hashed columns do not\ndisproportionately impact a specific demographic group [ 19]. For this system to be efficient,\nit needs to be easy to update the hashes as the data changes.\n1.5.2 Load-Balancing\nConsider the problem of load-balancing among multiple servers, where tasks need to be\ncompleted in a specific order. Each agent corresponds to a server, and each bead color\ncorresponds to a different type of task. We want to spread the load across the servers evenly,\nbut we also want to minimize communication costs [ 12]. This necessitates having as few cuts\nas possible.\nIf the order of tasks needs to be modified, new tasks need to be added, or existing tasks\nneed to be canceled, we would want to be able to update the computation plan without\nrecreating it from scratch. As a special case, if computation has already begun, we can\nstill perform dynamic updates that don’t affect the already-completed tasks using dynamic\nnecklace splitting.\n1.5.3 Bucketization\nAnother key application is ensuring minority representation in bucketization. For example,\nwhen partitioning data for machine learning tasks, it is crucial that the training data is\naccurately represented by the test data for reliable results [ 18]. Intentionally designing the\nbucketization process to maintain fairness helps prevent downstream fairness issues [ 15,16].\nHere, each agent represents a bucket, and the color of each bead represents the grouping\nattribute. If the “red” data is more sparse than the “blue” data, it is important that the\nrelative proportions are preserved to have accurate results.\n2 Offline Algorithm\nWe present a simplified version of the algorithm of Shahbazi et al. [ 19] here, as it is used as\na subroutine in our algorithms for the n= 2case. Without loss of generality, we refer to\nthe colors as red and blue. Initialize a doubly linked list Lsuch that, for each j∈[0,m− 1],\nL[j]is the number of red beads in the substring[ j,j+m/k− 1]. Initialize a hash set H\nthat contains all indices jwhereL[j] =m1/k. This takes O(m)time. By the discrete\nintermediate value theorem, there is a substring with m1/kred beads and m2/kblue beads,\nsoHis nonempty. We remove the smallest index jfromHand allocate the sublist of length\nm/kbeginning at jinLto the first agent. We remove all indices within m/k− 1beads ofj\ninLfromH, update the values of Lform/k− 1beads preceding j, add new indices to H\n\nR. Advani, A. Asudeh, M. Dehghankar, and S. Sintos 5\nas necessary, and update the element preceding jinLto point to the next unallocated bead.\nWe repeat this process k−1more times to allocate the remaining beads. Each step takes\nO(m/k)time, so in total, the algorithm takes O(m)time. When we use this algorithm as a\nsubroutine, we will often run it on a subsequence of length k′m/kwith onlyk′agents. For\nthis special case, the algorithm takes onlyO(k′m/k)time.\nAs shown by Alon and Graur [ 2], this algorithm produces at most2( k−1)cuts. It is\nalso known that no algorithm can guarantee fewer than2(k−1)cuts.2\nWe now walk through a sample execution of the offline algorithm.\n▶Example 1.Suppose we are splitting the following necklace between three agents.\nRRBRRBBBRBRB\nEach agent needs to receive two red beads and two blue beads. The first interval with the\ncorrect number of beads of each color is assigned to the first agent.\nRRBRRBBBRBRB\nThe second agent receives the first, second, seventh, and eighth beads, and the third agent\nreceives the remaining beads.\nRRBRRBBBRBRB\nEach agent receives two red beads and two blue beads in total.⌟\n3 Relocation with Two Colors\nWe now study the dynamic update of relocation with two colors.\n3.1 Adjacent Indices\nFirst, we consider the case where we restrict ourselves to relocating a bead to an adjacent\nindex. Notice that this is equivalent to swapping two adjacent beads. For brevity, we will\nrefer to relocation fromjtoj+ 1as swapping beadsS[j]andS[j+ 1].\nWe now show how we can maintain a valid set of cuts after swapping two adjacent beads\nS[j]andS[j+ 1]. If they are the same color or belong to the same agent, we can maintain\nthe same set of cuts P. The only interesting case is when S[j]andS[j+ 1]are different colors\nand belong to different agents. Let A1be the owner of S[j]andA2the owner of S[j+ 1].\nConsider the subsequence of beads S′⊆Sbelonging to either A1orA2. We remove from P\nthe cuts adjacent to both A1andA2. We run the offline algorithm on S′(inO(m/k)time)\nand add the (at most two) new cuts to P. We will henceforth refer to this procedure asSwap.\nNext, we prove upper bounds on the number of cuts in Pafter the update. We start with\na relatively trivial bound.\n▶Proposition 2.Afterrswaps,Swapproduces a set of cuts of size at most2(k−1) +r.\nProof.During each update, there is at least one cut adjacent to both A1andA2. We remove\nthis cut and add at most two cuts. Thus, with each update, we add at most one new cut.\nAfterrswaps, we will have at most2(k−1) +rcuts.◀\n2See Appendix A for proof.\n\n6 Dynamic Necklace Splitting\nIn fact, we can show that no extra cuts are needed.\n▶Theorem 3.Swapproduces a set of cuts of size at most2( k−1)and has time complexity\nO(m/k).\nProof.For the first update, we can assume that the original allocation has the structure\nof one given by an execution of the offline algorithm (up to order of interval selection). In\naddition, we will show that each update preserves that invariant, allowing us to use those\nproperties in the proof of the bound.\nAssume without loss of generality that A1is allocated beads before A2. Notice that the\norder in which agents are assigned beads can, in some cases, be altered without affecting\nthe resulting allocations. In particular, since A1shares a common boundary with A2, there\ncan be no agent whose allotted set of beads “encloses” that of A1but notA2. Thus, we\ncan conceptually alter the order of execution of the original offline algorithm without loss of\ngenerality such that A1was allocated beads immediately before A2. The only changes we\nhave to make are in the cases where a cut is added during A1’s turn that is adjacent to an\nagentA3whose beads are allocated after A1but beforeA2. In those cases, we add the cut\nduringA 3’s turn instead.\nNext, notice that each agent has two cuts allotted in the offline bound of2( k−1)cuts\n(with the exception of the final agent, who has none). Thus, during each update, we can\nsimply remove the cuts corresponding to A1(resulting in at most2( k−2)total cuts) and\nadd new cuts by rerunning the offline algorithm for the beads originally allocated to A1and\nA2(returning to the bound of2( k−1)). The only special case is when A1is not enclosed\nwithinA2and has no other adjacent agent at the time of allocation. In that case, we only\nremove one of two cuts corresponding to A1, but we may add two cuts back. However, if we\nadd two cuts, we can note that A2only has one corresponding cut, so A1can “donate” one\ncut toA2, maintaining the property that each non-final agent has at most two corresponding\ncuts.\nFinally, we note that none of the steps in the update process violate the stated invariant\nthat the allocation is one that could have been generated by an execution of the offline\nalgorithm (up to order of interval selection), concluding our proof.◀\n3.2 Nonadjacent Indices\nNext, we consider the case where beads need to be relocated an arbitrary distance away. Let\nA1be the owner ofS[j 1]andA 2the owner ofS[j 2].\n3.2.1 The Path Algorithm\nIf the distance between A1andA2in the neighborhood graph Gis sufficiently small, we can\nefficiently perform relocations without adding any extra cuts. First, we find a shortest path\nbetweenA1andA2inG. Letk′be the number of agents along that path. Then, we move\nS[j1]to indexj2. Finally, we rerun the offline algorithm on the substring belonging to the k′\nagents. We will henceforth refer to this procedure asPath.\nNote that the number of edges in Gis at most the number of cuts. Thus, finding a shortest\npath takes O(k)time using breadth-first search, giving a running time of O(k+k′m/k)\nforPath. In many practical applications, the distance that beads need to be relocated is\nrelatively small, makingPathvery efficient.3\n3See Appendix B for a theoretical analysis of the lengths of paths inG.\n\nR. Advani, A. Asudeh, M. Dehghankar, and S. Sintos 7\n▶Theorem 4.Pathproduces a set of cuts of size at most2( k−1)and has time complexity\nO(k+k′m/k).\nProof.For the first update, we can assume that the original allocation has the structure\nof one given by an execution of the offline algorithm (up to order of interval selection). In\naddition, we will show that each update preserves that invariant, allowing us to use those\nproperties in the proof of the bound.\nEach agent A′in the path shares a common boundary with the next agent in the path,\nA′′, so there can be no agent whose allotted set of beads “encloses” that of A′but notA′′.\nWithout loss of generality, this enables us to conceptually alter the order of execution of\nthe original offline algorithm such that A′andA′′were assigned beads in consecutive turns.\nFollowing the same logic, we can consider all of the k′agents to have had consecutive turns.\nNext, notice that each agent has two cuts allotted in the offline bound of2( k−1)cuts\n(with the exception of the final agent, who has none). Thus, during each update, we can\nsimply remove the cuts corresponding to the k′agents (resulting in at most2( k−k′)total\ncuts) and add new cuts by rerunning the offline algorithm for the beads originally allocated\nto those agents (returning to the bound of2(k−1)).\nFinally, we note that none of the steps in the update process violate the stated invariant\nthat the allocation is one that could have been generated by an execution of the offline\nalgorithm (up to order of interval selection), concluding our proof.◀\n3.2.2 The ColorPath Algorithm\nWithout loss of generality, assume S[j1]is red. We now construct a more intricate neighbor-\nhood graph, G′. UnlikeG, this graph is directed and weighted. For each pair of agents A′\nandA′′, there is an edge from A′toA′′if the two agents possess adjacent beads. If any such\npair of beads has a red bead on the side of A′, we call the edgegood, and its weight is0;\notherwise, we call itbad, and its weight is1.\nFirst, we find a shortest path from A2toA1inG′. Letk′be the number of agents\nalong that path. Then, we move S[j1]to indexj2. Next, for each good edge, we move the\ncorresponding red bead across the adjacent cut. For each subpath of bad edges, we rerun the\noffline algorithm on the substring corresponding to the subpath. We will henceforth refer to\nthis procedure asColorPath.\nNote that the number of edges in G′is at most twice the number of cuts. Finding a\nshortest path takes O(k)time using Dial’s algorithm [ 8], giving a running time of O(k+k′m/k)\nforColorPath. Asymptotically, this is the same asPath, but in practice,ColorPathwill likely\nbe faster.\n▶Proposition 5.ColorPathproduces a set of cuts of size at most2( k−1)and has time\ncomplexityO(k+k′m/k).\n3.2.3 The Fence Algorithm\nIf the number of agents k′in the path is large, we may instead wish to add extra cuts in\nreturn for a reduced running time. After moving S[j1]to indexj2, instead of rerunning\nthe offline algorithm, we simply add (at most two) cuts around it as necessary. We will\nhenceforth refer to this procedure asFence.\nThe main disadvantage ofFenceis that the resulting allocation is not guaranteed to be\none that could have been generated by an execution of the offline algorithm. This means that,\nafter a single execution ofFence, the guarantees of Theorems 3 and 4 (and Proposition 5) no\n\n8 Dynamic Necklace Splitting\nlonger hold.4As such, onceFencehas been used, any further relocations must be performed\nusingFenceas well. Furthermore, once the guaranteed number of cuts has passed some\nuser-determined tolerance level, the whole necklace should be reallocated from scratch using\nthe offline algorithm.\nSuppose2kextra cuts are permitted to be added via relocations before reallocation from\nscratch is required. Consider the sequence of relocations starting from the first execution of\nFenceto the first relocation that leads to over2 kextra cuts. The amortized running time of\nFence(including the time needed for the reallocation from scratch) is then\nO(1) +O(m)\nΩ(k)=O/parenleftbiggm\nk/parenrightbigg\n.\nAs such,Fencemay be preferred overPathandColorPathifk′is frequently large.\nWe can also adaptFenceto the case of n > 2in a straightforward way. Using the\noffline algorithm of Alon and Graur [ 2, Theorem 5] (which has a running time of O(m)), we\ncan guarantee at most n(k−1)⌈4 +log2(3kmaxi∈[n]mi)⌉+ 2rcuts afterrrelocations. If\n2knextra cuts are permitted to be added before reallocation from scratch is required, the\namortized running time is then\nO(1) +O(m)\nΩ(kn)=O/parenleftbiggm\nkn/parenrightbigg\n.\n▶Proposition 6.After rrelocations,Fenceproduces a set of cuts of size at most2( k+r−1)\nifn= 2andn(k−1)⌈4+log2(3kmaxi∈[n]mi)⌉+2rifn>2and has time complexity O/parenleftig\nm\nkn/parenrightig\n.\n4 Batch Relocation with Two Colors\nTo make relocation more efficient, we can perform batch updates. Instead of moving a\nsingle bead, we will move m′beads (of the same color)5from indices j1\n1,...,jm′\n1to indices\nj1\n2,...,jm′\n2. LetA1andA2be the corresponding sets of agents. If there are any agents in\nboth sets, we can remove them from both. Let k′′be the number of agents remaining. Let\nm′′be the number of beads that need to change owners.\nWe construct a flow network G′′= (V′′,E′′)fromGas follows. For each node in V, there\nis a corresponding node in V′′. In addition, there is a source sand sinkt. For each node\nu∈V′′\\{s,t}, let∆(u)denote the net change in the number of beads that the corresponding\nagent owns. For each node ucorresponding to an agent in A1, there is an edge( s,u)with\ncapacitycsu:=−∆(u). For each node ucorresponding to an agent in A2, there is an edge\n(u,t)with capacity cut:= ∆(u). For each edge in E, there is a corresponding edge( u,v)in\nE′′with infinite capacity.\nDefine anactivenode to be one with positive incoming and outgoing flow. We want to\nfind a max flow (of value m′′) such that the number of active nodes is minimized. We will\nhenceforth refer to this problem asMinNodeMaxFlow.\n▶Proposition 7.MinNodeMaxFlowis NP-complete.6\n4Proposition 2 can technically still be made to work with some adjustments. After usage ofFence, a\nmodified Proposition 2 would guarantee that the number of cuts increases by one with each execution\nofSwap.\n5Our techniques can be adapted in a straightforward manner to work with beads of both colors being\nrelocated simultaneously, but for ease of exposition, we restrict ourselves to a single color here.\n6See Appendix C for proof.\n\nR. Advani, A. Asudeh, M. Dehghankar, and S. Sintos 9\nWe now describe the construction of a spanning tree of Gthat will allow us to approxi-\nmately solveMinNodeMaxFlow. Consider the process of generating the neighborhood graph\nGwhile the offline necklace splitting algorithm is being run. When a new node is added, we\ninitially assign it alevelof 1. If the corresponding agent’s interval encloses any other agents’\nintervals, then we increment the levels of all the nodes corresponding to agents with enclosed\nintervals.\nFor example, the node corresponding to the first agent allocated beads is initially on level\n1. If the second agent’s interval encloses that of the first, the first agent’s node is moved to\nlevel 2. If the third agent’s interval encloses that of the second, then we have the first agent’s\nnode on level 3 and the second agent’s node on level 2.\nWe continue the process of updating the levels until all agents have been assigned their\nintervals and the graph Gis finalized. Then, we construct a new graph by removing all\nedges between nodes on the same level, other than those on level 1. We will denote this\nneighborhood treebyT.\nA1 A2 A3\nA4 A6 A7\nA5 A8\nFigure 1An example of a neighborhood tree. The dashed lines indicate additional edges present\nin the corresponding neighborhood graph.\n▶Proposition 8.Tis a spanning tree ofG.\nProof.First, we prove that Tis connected. Gis trivially connected since the necklace it\nrepresents is a contiguous collection of beads. We need to show that the edges removed\nfromGto construct Tare unnecessary for connectivity. Consider any edge removed. By\nconstruction, neither endpoint is on level 1. Thus, both endpoints are joined to a node on the\nprevious level corresponding to an enclosing agent, and consequently, they remain connected.\nNext, we prove that Tis acyclic. Assume for contradiction that there exists a cycle in T.\nLetℓbe the lowest level represented in the cycle. Consider a nodeuin the cycle on levelℓ.\nBoth of its neighbors in the cycle must be on level ℓ−1. However, by construction, each\nnode is joined to at most one node on the level below it. We have a contradiction, so Tmust\nbe acyclic. Therefore,Tis a spanning tree ofG.◀\nWe now describe how we can efficiently produce an approximate solution toMinNode-\nMaxFlowusing the properties of T. We construct a flow network T′fromTanalogous to\nG′′. The only difference from G′′is the lack of edges between nodes on the same level (other\nthan level 1).\n▶Lemma 9.The number of active nodes in a solution toMinNodeMaxFlowon T′is at most\ntwice the number of active nodes in a solution onG′′.\nProof.Consider an optimal solution toMinNodeMaxFlowon G′′. Assume, without loss\nof generality, that there is no pair of nodes uandvsuch that both( u,v)and(v,u)have\npositive flow. Let k′be the number of active nodes. For each edge( u,v)with positive flow\nwhereuandvare on the same level (other than level 1), we can remove the flow and instead\nadd equal flow to( u,w)and(w,v), wherewis the unique node on the previous level joined\n\n10 Dynamic Necklace Splitting\nto bothuandv. If we replicate the resulting flow on T′, we have a feasible solution to\nMinNodeMaxFlowonT′.\nSince each node is joined to at most two nodes on the same level, there are at most k′\npairs of adjacent active nodes on the same level. In the worst case, we add k′active nodes to\nthe solution, resulting in2 k′active nodes. The optimal solution toMinNodeMaxFlowon T′\nmust have at most as many active nodes as this feasible solution, so it also has at most2 k′\nactive nodes. Therefore, the number of nodes is at most twice the number of active nodes in\nan optimal solution onG′′.◀\n▶Lemma 10.MinNodeMaxFlowcan be solved inO(k′′logk′′+k′)time onT′.\nProof.The edges from the source sand to the sink tmust all be saturated to produce a\nmax flow, so we can ignore both nodes. The remaining subgraph has structure identical\ntoT, and is thus a tree. We sort the sources/sinks by their level in descending order and\ninitialize a linked list of pointers to them in that order. Consider the set of nodes with excess\n(potentially negative) flow on the highest level (other than level 1). At first, these are all\nsources/sinks. Each of these nodes has a unique edge leading to the level below. Any valid\nflow must have flow on these edges. We place the appropriate amount of flow on each of these\nedges to satisfy the demands of the sources/sinks. Then we consider the new set of nodes\nwith excess flow on the highest level (other than level 1) and repeat the process, updating\nthe linked list accordingly. We terminate once all nodes not on level 1 have no excess flow.\nIn each step, the highest level with excess flow decreases, so this process must terminate.\nIf any nodes with excess flow remain, they are on level 1. Consider the leftmost such\nnode. We put flow on each edge to the right until the current node has no excess flow. Then\nwe find the new leftmost node with excess flow and repeat the process. In each step, the\nnumber of nodes with excess flow decreases, so eventually no nodes will have excess flow, at\nwhich point we terminate.\nSorting the initial list takes O(k′′logk′′)time. In the first phase, we process only the\nnodes in the solution, and each in constant time, giving a running time of O(k′)for the\nfirst phase. In the second phase, assuming the relative position of each node on level 1 is\nstored when Tis constructed, we can find the leftmost node in O(k′)time, and after that,\nwe only process nodes in the solution, each in constant time. This gives us a running time of\nO(k′)for the second phase. Overall, we have a running time of O(k′′logk′′+k′)for solving\nMinNodeMaxFlowonT′.◀\n▶Example 11.Consider the following neighborhood tree.\nA1 A2 A3\nA4 A6 A7\nA5 A8\nSupposeA1andA5are sources and A3andA6are sinks, all with demands of 1. At first,\nA1andA3are the highest nodes with excess flow. We put flow on the edges( A1,A4)and\n(A4,A3).\n\nR. Advani, A. Asudeh, M. Dehghankar, and S. Sintos 11\nA1 A2 A3\nA4 A6 A7\nA5 A8\nNow the highest node with excess flow isA 6, so we put flow on(A 8,A6).\nA1 A2 A3\nA4 A6 A7\nA5 A8\nContinuing, we put flow on(A 5,A8).\nA1 A2 A3\nA4 A6 A7\nA5 A8\nAll nodes are now satisfied, so the algorithm terminates.⌟\nAfterMinNodeMaxFlowhas been solved on T′, we can return to Gto perform a heuristic\noptimization. For each active node uthat is neither a source/sink nor sending flow to the\nlevel below, consider the subgraph consisting of its active neighbors on the level above. If that\nsubgraph is connected, then we can remove ufrom the solution. Finding all such subgraphs\ntakesO(k)time since we consider each edge a constant number of times. Checking if the\nsubgraphs are connected takes O(k)time in total. Overall, this heuristic pruning process\naddsO(k)additional time.\nFinally, we rerun the offline necklace splitting algorithm on the substring belonging to\nthe agents corresponding to the active nodes. We will henceforth refer to this procedure as\nBatchPath. We have an overall running time of O/parenleftig\n1\nm′/parenleftig\nk′′logk′′+k′+k′m\nk/parenrightig/parenrightig\n=O/parenleftig\nk′′logk′′\nm′+\nk′m\nkm′/parenrightig\nper bead forBatchPath.7Sincek′′≤m′, we also have the looser but more intuitive\nrunning time of O/parenleftig\nlogk +k′m\nkm′/parenrightig\n. Thus, there is only an O(logk)overhead when using\nBatchPathcompared toPath, without accounting for the m′×speedup from batching\nupdates.\n▶Theorem 12.BatchPathproduces a set of cuts of size at most2( k−1)and has time\ncomplexityO/parenleftig\nlogk+k′m\nkm′/parenrightig\n.\n5 Relocation with Multiple Colors and High Cut Density\nNext, we consider the case of relocation for general n≥2with the additional restriction\nthatm=nk. Note that using the corresponding offline algorithm of Alon and Graur [ 2,\n7Alternatively,O/parenleftig\nk′′logk′′\nm′+k′m\nkm′+k\nm′/parenrightig\nper bead if pruning is used.\n\n12 Dynamic Necklace Splitting\nProposition 1], the initial solution is guaranteed to have exactly n(k−1)cuts (some may be\nredundant). This initial solution is produced in O(m)time. To enable efficient implementa-\ntions for our dynamic algorithms, we maintain a two-dimensional array indexed by agent\nand color that points to the corresponding bead inS.\n5.1 Adjacent Indices\nSuppose we need to swap a red bead (on the left) and blue bead (on the right) between A1\nandA 2, respectively. There are three possible (nontrivial) cases (Table 3).\nTable 3The possible cases for theDenseSwapalgorithm.\nCase Necklace\n1RB→BR\n2RBG→ BRG\n3aBRB→BBR→BBR\n3bGRB→GBR→GBR\nIn the first case, there is a cut to the left of the red bead and to the right of the blue\nbead (or it is at the end of the necklace). This is the simplest case – we swap the beads and\nlet the agents retain ownership of their original beads. No cuts need to be adjusted.\nIn the second case, there is a cut on the left, but not the right. We swap the beads and do\nnot adjust any cuts. A2takes possession of the left interval, and A1takes possession of the\nright interval. As part of the right interval, A1gains at least one unneeded extra bead (the\ngreen one). Each extra bead lacks a cut to its left, so they must be the first of their colors.\nThus, the original beads of A1are somewhere to the right in the necklace. Furthermore,\nsince each of the original beads is not the first of its color, they each start their own intervals.\nA2takes ownership of each of these intervals and repeats the process with each of them if\nthey have multiple beads, continuing to attempt to re-satisfy the fairness constraint. Since\nthe necklace has exactly n−1pairs of adjacent beads without a cut, this results in at most\nnownership exchanges throughout the procedure.\nIn the third case, there is no cut on the left. We swap the beads and move the cut left\nby one bead (to ensure that the set of cuts maintains the structure of one generated by the\noffline algorithm). A1andA2retain the left and right intervals, respectively. Similarly to\nthe second case, to maintain the fairness constraint, at mostn−1intervals will have to be\nexchanged between the two agents.\nWe will henceforth refer to this procedure asDenseSwap. The two-dimensional array\nallows us to perform each ownership exchange in constant time, giving a running time of\nO(n)forDenseSwap.\n▶Theorem 13.DenseSwapproduces a set of cuts of size exactly n(k−1)and has time\ncomplexityO(n).\n5.2 Nonadjacent Indices\nWe can generalize the ideas from the previous section to design an algorithm for arbitrary\nrelocation. In addition to the two-dimensional array, we maintain for each color a red–black\n\nR. Advani, A. Asudeh, M. Dehghankar, and S. Sintos 13\ntree tracking the indices of the beads of that color in S. Suppose we need to relocate a red\nbead. There are four possible cases (Table 4).\nTable 4The possible cases for theDenseJumpalgorithm.\nCase First of its color?\n1✓→✓\n2✗→✗\n3✓→✗\n4✗→✓\nIn the first case, the bead to be relocated begins as the first of its color and remains\nso. We move the bead to the desired position, and if the interval is owned by a different\nagent, we re-satisfy the fairness constraint by exchanging at most nintervals between the\ntwo agents, as in the previous section.\nIn the second case, the bead to be relocated begins not as the first of its color and remains\nso. We move the bead and its corresponding cut to an arbitrary boundary to make it a\nsingleton interval, and if the two affected intervals are not owned by the same agent, we\nre-satisfy the fairness constraint by exchanging at most n−1intervals between the two\nagents. Then, we move the bead and its corresponding cut to the desired position, and if\nthe destination interval does not belong to the owner of the bead, we re-satisfy the fairness\nconstraint by exchanging at mostnintervals between the two agents.\nIn the third case, the bead begins as the first of its color but does not remain so. We\nrelocate the bead directly to the left of the second red bead via Case 1, and then we relocate\nthe second red bead to the desired position via Case 2. At most3 n−1intervals are exchanged\nthroughout this case.\nIn the fourth case, the bead begins not as the first of its color but becomes the first. We\nrelocate the bead and its corresponding cut directly to the right of the first red bead via\nCase 2, and then we relocate the first red bead to the desired position via Case 1. At most\n3n−1intervals are exchanged throughout this case.\nWe will henceforth refer to this procedure asDenseJump. Updating the red–black tree in\nCase 2 takes O(k)time if the rank of the bead changes. Otherwise, all updates to the tree\ntake constant time. This gives us a total running time ofO(k+n)forDenseJump.\n▶Theorem 14.DenseJumpproduces a set of cuts of size exactly n(k−1)and has time\ncomplexityO(k+n).\n6 Insertion and Deletion\nIn this section, we study the complementary dynamic updates of insertion and deletion with\ntwo colors. For insertion, we simply give αbeads to each agent and then relocate the αk\nbeads to the desired indices usingBatchPath. For deletion, we delete the desired beads and\nthen relocate beads from agents with surpluses to those with deficits, again usingBatchPath.\nBoth insertion and deletion take O/parenleftig\nk′′logk′′\nαk+k′m\nαk2/parenrightig\n=O/parenleftig\nlogk\nα+k′m\nαk2/parenrightig\ntime per bead using\nthis approach.\n▶Theorem 15.There is an algorithm for insertion and deletion that produces a set of cuts\nof size at most2(k−1)and has time complexityO/parenleftig\nlogk\nα+k′m\nαk2/parenrightig\n.\n\n14 Dynamic Necklace Splitting\nWe now show how the running time can be more precisely understood in the special case\nofα= 1by bounding the value of k′′askgrows. Suppose each of the beads is associated\nwith a scalar value, such that the position of a bead in the necklace is determined by the\nrank of its value. This is the case, for example, when designing fair hash maps [ 19]. If the\nbead values are drawn independently from the same distribution D, then the distribution of\nthe rank of a new sample among the existing beads in the necklace is simply the uniform\ndistribution. As such, it is well motivated to consider beads as being inserted into the\nnecklace uniformly at random. Equivalently, agents to receive beads are chosen uniformly at\nrandom. In the absence of any further information, it is justified to assume that beads to be\ndeleted are chosen uniformly at random as well.\nIdeally (to reduce running time), we want to have as many agents receive exactly one\nbead as possible, since k′′is the number of agents that do not receive exactly one bead.\nWe will show that this is likely to be the case. Assume k >101. For each i∈[k], letXi\nbe a Bernoulli random variable indicating if the number iis not chosen exactly once when\nsamplingkvalues from the discrete uniform distribution on[ k]. LetX=/summationtext\niXi. We have\nk(1−1.005/e)<E[X]<k(1−1/e). For the variance, we have the following.\nVar(X) = Var(k−X)\n=/summationdisplay\niVar(1−X i) +k/summationdisplay\ni,j=1,i̸=jCov(1−X i,1−Xj)\n=kVar(1−X 1) +k(k−1) Cov(1−X 1,1−X 2)\n<1.005k\ne−k\ne2+k(k−1)/parenleftbigg(k−1)(k−2)k−2\nkk−1−(k−1)2k−2\nk2k−2/parenrightbigg\n=1.005e−1\ne2k+kk−1(k−1)2(k−2)k−2−(k−1)2k−1\nk2k−1\n<1.005e−1\ne2k+k2k−1−(k−1)2k−1\nk2k−1\n=1.005e−1\ne2k+ 1−/parenleftbigg\n1−1\nk/parenrightbigg2k−1\n<1.005e−1\ne2k+ 1−0.995\ne2\nThen, by the Chebyshev–Cantelli inequality, we have\nPr(X≥λk)<1.005e−1\ne2k+ 1−0.995\ne2\n1.005e−1\ne2k+ 1−0.995\ne2+/parenleftig\nλk+1\ne−1/parenrightig2.\nIf we setλ= 1−1/e, then we havek′′<(1−1/e)kwith probability greater than 99.3%.\n7 Approximate Necklace Splitting\nIn this section, we design an algorithm for approximate necklace splitting with two colors\nthat works in both the static and dynamic settings. The algorithm is efficient when the\nnumber of agentskis small, for example,k=o(m).\n7.1 Static Setting\nWe construct a red–black tree Tover the necklace Swith respect to the order of the beads\n(i.e., we assume that S[j1]<S[j2]ifj1<j2). LetS1be the subsequence consisting of red\n\nR. Advani, A. Asudeh, M. Dehghankar, and S. Sintos 15\nbeads andS2the subsequence consisting of blue beads with |S1|=m1and|S2|=m2. Let\nε∈(0,1)be a parameter specified by the user. Let I0=∅. We run the following subroutine\nforkiterations.\nIn thejth iteration, for each color i∈{ 1,2}, we useTto obtain a uniform random\nsampleSj\ni⊆Si\\Ij−1of cardinality O/parenleftbig\n(k−j + 1)222kε−2log(2km)/parenrightbig\n. LetSj=Sj\n1∪Sj\n2. We\nexecute one iteration of the exact offline algorithm with k−j + 1agents on S\\Ij−1. LetIj\nbe the interval returned by the algorithm. We add the (at most) two corresponding cuts.\nLetIj=Ij−1∪{Ij}.\nAfter thekth iteration, the resulting set of cuts is returned. We will henceforth refer to\nthis procedure asApproxStatic.\n▶Theorem 16.ApproxStaticproduces an approximate solution with at most2( k−1)cuts,\nsuch that each agent gets at least(1 −ε)mi\nkand at most(1 + ε)mi\nkbeads of color iwith\nprobability at least1−1\nm. It has time complexityO/parenleftbig\nm+k322kε−2(logm)2/parenrightbig\n.8\n7.2 Dynamic Setting\nWe now show how to adaptApproxStaticto the dynamic setting. Our algorithm can handle\nany type of dynamization, including relocation, insertion, and deletion.\nNotice that the crux ofApproxStaticrelies on a small set of samples (given sufficiently\nsmallk). Hence, if we ensure that sampling is performed efficiently under updates, we\ncan have a dynamic algorithm for approximate necklace splitting with an update time that\nonly depends logarithmically on m. Indeed, assume that the tree Tis constructed in the\npreprocessing phase. It is known that a red–black tree can be updated in O(logm )time under\ninsertion/deletion of an element. Thus, our algorithm for the dynamic necklace splitting\nproblem consists of maintaining Tunder relocations/insertions/deletions (a relocation can\nbe handled as a deletion followed by an insertion). When the user requests the set of cuts,\nwe executeApproxStaticas a subroutine using the updated T. We will henceforth refer to\nthis procedure asApprox.\nWhen a batch of kupdates is encountered, Tis updated in O(klogm )time, and the\nnew set of cuts can be constructed in O/parenleftbig\nk322kε−2(logm )2/parenrightbig\ntime. The overall running time\nofApproxis thus O/parenleftbig\nk222kε−2(logm )2+logm/parenrightbig\nper bead. If we do not often need to produce\nthe actual set of cuts, we only needO(logm)time per bead to maintainT.\n▶Theorem 17.Approxproduces an approximate solution with at most2( k−1)cuts, such\nthat each agent gets at least(1 −ε)mi\nkand at most(1 + ε)mi\nkbeads of color iwith probability\nat least1−1\nm. It has time complexityO/parenleftbig\nk222kε−2(logm)2+ logm/parenrightbig\n.\nReferences\n1Noga Alon. Splitting necklaces.Advances in Mathematics, 63(3):247–253, March 1987.\ndoi:10.1016/0001-8708(87)90055-7.\n2Noga Alon and Andrei Graur. Efficient splitting of necklaces. In48th International Colloquium\non Automata, Languages, and Programming (ICALP 2021), volume 198 ofICALP ’21, pages\n14:1–14:17, Virtual (Glasgow, Scotland), July 2021. Schloss Dagstuhl-Leibniz-Zentrum für\nInformatik.doi:10.4230/LIPIcs.ICALP.2021.14.\n8See Appendix D for proof.\n\n16 Dynamic Necklace Splitting\n3Noga Alon and Douglas B. West. The Borsuk-Ulam theorem and bisection of neck-\nlaces.Proceedings of the American Mathematical Society, 98(4):623–628, 1986. doi:\n10.1090/s0002-9939-1986-0861764-9.\n4Martin Anthony and Peter L. Bartlett.Neural Network Learning: Theoretical Foundations.\nCambridge University Press, November 1999.doi:10.1017/cbo9780511624216.\n5Gerdus Benade, Aleksandr M. Kazachkov, Ariel D. Procaccia, and Christos-Alexandros\nPsomas. How to make envy vanish over time. InProceedings of the 2018 ACM Conference\non Economics and Computation, EC ’18, pages 593–610, Ithaca, New York, USA, June 2018.\nACM.doi:10.1145/3219166.3219179.\n6SandeepN. BhattandCharlesE. Leiserson. How toassembletreemachines(extended abstract).\nInProceedings of the Fourteenth Annual ACM Symposium on Theory of Computing, STOC ’82,\npages 77–84, San Francisco, California, USA, May 1982. ACM. doi:10.1145/800070.802179 .\n7Karol Borsuk. Drei Sätze über die n-dimensionale euklidische Sphäre.Fundamenta Mathemat-\nicae, 20(1):177–190, 1933.doi:10.4064/fm-20-1-177-190.\n8Robert B. Dial. Algorithm 360: shortest-path forest with topological ordering [h].Communi-\ncations of the ACM, 12(11):632–633, November 1969.doi:10.1145/363269.363610.\n9Charles H. Goldberg and Douglas B. West. Bisection of circle colorings.SIAM Journal on\nAlgebraic Discrete Methods, 6(1):93–106, January 1985.doi:10.1137/0606010.\n10Sariel Har-Peled.Geometric Approximation Algorithms, volume 173 ofMathematical Surveys\nand Monographs. AMS, June 2011.\n11Jiafan He, Ariel D. Procaccia, Alexandros Psomas, and David Zeng. Achieving a fairer future\nby changing the past. InProceedings of the Twenty-Eighth International Joint Conference on\nArtificial Intelligence, IJCAI-2019, pages 343–349, Macao, China, August 2019. International\nJoint Conferences on Artificial Intelligence Organization.doi:10.24963/ijcai.2019/49.\n12Einollah Jafarnejad Ghomi, Amir Masoud Rahmani, and Nooruldeen Nasih Qader. Load-\nbalancing algorithms in cloud computing: A survey.Journal of Network and Computer\nApplications, 88:50–71, June 2017.doi:10.1016/j.jnca.2017.04.007.\n13Ian Kash, Ariel D. Procaccia, and Nisarg Shah. No agent left behind: Dynamic fair division\nof multiple resources.Journal of Artificial Intelligence Research, 51:579–603, November 2014.\ndoi:10.1613/jair.4405.\n14Tim Kraska, Alex Beutel, Ed H. Chi, Jeffrey Dean, and Neoklis Polyzotis. The case for learned\nindex structures. InProceedings of the 2018 International Conference on Management of Data,\nSIGMOD ’18, pages 489–504. ACM, May 2018.doi:10.1145/3183713.3196909.\n15Ninareh Mehrabi, Fred Morstatter, Nripsuta Saxena, Kristina Lerman, and Aram Galstyan.\nA survey on bias and fairness in machine learning.ACM Computing Surveys, 54(6):1–35, July\n2021.doi:10.1145/3457607.\n16Dana Pessach and Erez Shmueli. A review on fairness in machine learning.ACM Computing\nSurveys, 55(3):1–44, February 2022.doi:10.1145/3494672.\n17Ibrahim Sabek, Kapil Vaidya, Dominik Horn, Andreas Kipf, Michael Mitzenmacher, and Tim\nKraska. Can learned models replace hash functions?Proceedings of the VLDB Endowment,\n16(3):532–545, November 2022.doi:10.14778/3570690.3570702.\n18Nima Shahbazi, Yin Lin, Abolfazl Asudeh, and V. Jagadish, H.˙Representation bias in data:\nA survey on identification and resolution techniques.ACM Computing Surveys, 55(13s):1–39,\nJuly 2023.doi:10.1145/3588433.\n19Nima Shahbazi, Stavros Sintos, and Abolfazl Asudeh. FairHash: A fair and memory/time-\nefficient hashmap.Proceedings of the ACM on Management of Data, 2(3):1–29, May 2024.\ndoi:10.1145/3654939.\nA Offline Algorithm is Optimal\n▶Proposition 18.For everyk, there exists a necklace that requires exactly2(k−1)cuts.\n\nR. Advani, A. Asudeh, M. Dehghankar, and S. Sintos 17\nProof.Thek= 1case is trivial, so we assume k >1. Consider the necklace withm\n2red\nbeads followed bym\n2blue beads. Suppose we have an optimal set of cuts of the necklace.\nThe first interval in the resulting allocation consists of at mostm\n2kred beads. Without loss\nof generality, assume this interval belongs to A1. If it has exactlym\n2kbeads, we move to\nthe next interval (without loss of generality, owned by A2). Else, we check if the first two\nintervals combined have more thanm\n2kbeads. If so, we can move the first cut to the right\nuntil the first interval has exactlym\n2kbeads. To maintain the fairness constraint, we reassign\nall the red beads of A1in the rest of the necklace to A2(without adding any cuts). We then\nmove to the next interval. Instead, if the first two intervals combined have at mostm\n2kbeads,\nwe remove the cut between them and add one cut within another interval with red beads\nbelonging toA 1, maintaining the overall number of cuts.\nWe repeat this process from both the left (red) and right (blue) ends of the necklace\nuntil we reach the center interval, which consists ofm\n2kred beads andm\n2kblue beads. We\nhave exactly2( k−1)cuts, and since the number of cuts remained constant throughout this\nprocedure, the original optimal set of cuts was of size2(k−1).◀\nB Lengths of Paths in the Neighborhood Graph\nIn this section, we analyze the lengths of paths in Gunder loose conditions on the dynamic\nupdates. We show that if relocation positions are drawn uniformly at random, we can bound\nthe length of the path with high likelihood.\n▶Proposition 19.The distance between two distinct nodes selected uniformly at random is\nat most⌈k/2⌉with probability at least 75%.\nWe first state and prove a lemma that will be useful in the proof.\n▶Lemma 20.The average distance between a node uand each other node in a connected\ngraph withknodes is at mostk/2.\nProof.Letdbe the greatest distance between uand any other node. The existence of such\na node implies the existence of nodes at distances d−1,d−2, etc. from uas well. The\nremainingk−1−dnodes are at distance at most dfromuby assumption. The average\ndistance betweenuand each other node can be bounded as follows.\n/summationtextd\nκ=1κ+ (k−1−d)d\nk−1≤/summationtextd\nκ=1κ+/summationtextk−1\nκ=d+1κ\nk−1=/summationtextk−1\nκ=1κ\nk−1=k(k−1)\n2(k−1)=k\n2\n◀\nProof of Proposition 19. First, we show that the connected graph with maximum average\npath length is the linear graph. Note that the average path length of any graph is at most\nthat of one of its spanning trees, so we can restrict ourselves to trees. We prove the claim by\ninduction.\nFor the base case, our claim trivially holds for k<3. Assume the claim holds for some\nk=µ. We show that it holds for k=µ+ 1. Consider the linear graph with µ+ 1nodes. The\nsubgraph induced by the first µnodes has maximum average path length by assumption.\nThe average distance between the last node and each other node is k/2, so by Lemma 20, it\ncannot be increased. Therefore, the claim holds for k=µ+ 1, and by induction, it holds for\nallk.\nNext, we verify that it is possible for the neighborhood graph to be linear. One possible\nnecklace that gives rise to a linear neighborhood graph is the following.\n\n18 Dynamic Necklace Splitting\nRBRBRBRBRBRB\nFinally, we analyze the lengths of shortest paths in a linear graph. Suppose Gis a linear\ngraph and two (distinct) nodes are selected uniformly at random. The distance between\nthem follows a triangular distribution. The length is at most ⌈k/2⌉with probability at least\n1−/summationtextk/2−1\nκ=1κ\n/summationtextk−1\nκ=1κ= 1−k(k−2)\n4k(k−1)=3k−2\n4k−4>3k−3\n4k−4= 75%.\n◀\nC NP-completeness of MinNodeMaxFlow\nProof of Proposition 7. First, we show thatMinNodeMaxFlowis in NP. We are given a flow\nnetwork and a limit κon the number of active nodes as input and a proposed flow as a\ncertificate. We can compute the value of a max flow on the graph (in polynomial time).\nThen we can easily verify whether the proposed flow has that value and satisfies the flow\nconstraints and whether the number of active nodes is at most κ.MinNodeMaxFlowis in NP.\nNext, we show thatMinNodeMaxFlowis NP-hard, via reduction fromVertex Cover. Given\nan undirected graphΓ = ( VΓ,EΓ)and parameter κ, we want to determine whetherΓhas\na vertex cover of size at most κ. We construct an auxiliary, directed graphΓ′= (VΓ′,EΓ′)\ncontaining the same vertices in addition to a source node σ, a sink node τ, and an extra node\nuvfor every edge( u,v)∈EΓ. We replace each edge( u,v)∈EΓwith two infinite-capacity\nedges:(uv,u )and(uv,v). We add a unit-capacity edge from σto each extra node uvand\nan infinite-capacity edge from each original nodeutoτ.\nIf there is a vertex cover of size κinΓ, then there is a max flow onΓ′with|EΓ|+κ\nactive nodes. Conversely, suppose there is a max flow onΓ′withκactive nodes. If any\nnodeuvis sending fractional flow to each of its neighbors, we can reroute its flow to go to\njust one neighbor without changing the number of active nodes. We would need to do this\nat most|EΓ|times, so we can always efficiently find an integral solution, given the initial\nsolution. Once we obtain an integral solution, we have a corresponding vertex cover of size κ.\nTherefore,MinNodeMaxFlowis NP-hard.◀\nD Correctness and Time Complexity of ApproxStatic\n▶Definition 21( ε-sample [ 10, Chapter 5]).Let( X,R )be a set system. For any ε∈[0,1], a\nsubsetC⊆Xis anε-samplefor(X,R)if for everyρ∈R, we have\n/vextendsingle/vextendsingle/vextendsingle/vextendsingle|ρ|\n|X|−|C∩ρ|\n|C|/vextendsingle/vextendsingle/vextendsingle/vextendsingle≤ε.\nProof of Theorem 16. Wecanconstruct TinO(m)time. Wecanretrieveanelementfrom T\ninO(logm )time, sowecanconstructtheset SjinO(|Sj|logm ) =O/parenleftbig\nk222kε−2(logm )2/parenrightbig\ntime.\nExecuting the exact offline algorithm for one iteration takes O(|Sj|) =O/parenleftbig\nk222kε−2logm/parenrightbig\ntime. We run the subroutine for kiterations, so the total running time ofApproxStatic\nisO/parenleftbig\nm+k322kε−2(logm )2/parenrightbig\n. It is clear that, by construction, the algorithm produces at\nmost2(k−1)cuts. What remains is to show that the resulting assignment of beads is\napproximately fair.\nFor any subset of beads Xin the necklace, consider the set system( X,RS)of VC\ndimension2, where RSis the family of all possible intervals (sets of contiguous beads) in\n\nR. Advani, A. Asudeh, M. Dehghankar, and S. Sintos 19\nS. Then, with probability at least1 −φ, a uniform random subset C⊆Xof cardinality\nO/parenleftbig\nε−2log/parenleftbig\nφ−1/parenrightbig/parenrightbig\nis anε-sample for(X,R S)[4].\nLet¯ε=ε\n2k. By definition, the probability that Sj\niis a¯ε\nk−j+1-sample is at least1 −1\n2km.\nWe have that in the jth iteration, both Sj\n1andSj\n2are¯ε\nk−j+1-samples for( S1\\Ij−1,RS)\nand(S2\\Ij−1,RS), respectively, with probability at least1 −1\nkm. Via a union bound\nover the iterations, with probability at least1 −1\nm, we have thatSj\niis a¯ε\nk−j+1-sample for\n(Si\\Ij−1,RS)for allj∈[k]andi∈{1,2}.\nWe now prove by induction that for each iterationj∈[k]and colori∈{1,2}, we have\n1−(2j−1)¯ε\nk≤|Si∩Ij|\n|Si|≤1 + (2j−1)¯ε\nk\nifSj\niis an¯ε\nk−j+1-sample for Si\\Ij−1. First we consider the base case: j= 1. By definition,\nin the first iteration, S1\niis a¯ε\nk−j+1-sample for Si. By the correctness of the exact offline\nalgorithm onS1, for eachi∈{1,2}, we have that|S1\ni∩I1|/|S1\ni|= 1/k. Thus, we have\n1−¯ε\nk≤|Si∩I1|\n|Si|≤1 + ¯ε\nk.\nFor the inductive step, assume that the claim holds for all j < ζ. We will show that\nit holds for j=ζ. By the correctness of the exact offline algorithm on S1we have that\n|Sζ\ni∩Iζ|/|Sζ\ni|= 1/(k−ζ+ 1). SinceSζ\niis a¯ε\nk−ζ+1-sample forS i\\Iζ−1, we have\n1−¯ε\nk−ζ+ 1≤|(Si\\Iζ−1)∩Iζ|\n|Si\\Iζ−1|≤1 + ¯ε\nk−ζ+ 1.\nNotice that(S i\\Iζ−1)∩Iζ=Si∩Iζ, so we can rewrite this as\n1−¯ε\nk−ζ+ 1|Si\\Iζ−1|≤|Si∩Iζ|≤1 + ¯ε\nk−ζ+ 1|Si\\Iζ−1|.\nWe first prove the left inequality of the claim.\n|Si∩Iζ|≥1−¯ε\nk−ζ+ 1/vextendsingle/vextendsingleSi\\Iζ−1/vextendsingle/vextendsingle\n=1−¯ε\nk−ζ+ 1/parenleftbigg\nmi−ζ−1/summationdisplay\nj=1|Si∩Ij|/parenrightbigg\n≥1−¯ε\nk−ζ+ 1/parenleftigg\n1−ζ−1/summationdisplay\nj=11 +/parenleftbig\n2j−1/parenrightbig\n¯ε\nk/parenrightigg\nmi\n= (1−¯ε)/parenleftbigg\n1−¯ε\nk−ζ+ 1ζ−1/summationdisplay\nj=1/parenleftbig\n2j−1/parenrightbig/parenrightbiggmi\nk\n= (1−¯ε)/parenleftigg\n1−/parenleftbig\n−ζ+ 2ζ−1/parenrightbig\n¯ε\nk−ζ+ 1/parenrightigg\nmi\nk\n≥(1−¯ε)/parenleftbig\n1−/parenleftbig\n−ζ+ 2ζ−1/parenrightbig\n¯ε/parenrightbigmi\nk\n≥/parenleftbig\n1−¯ε+ζ¯ε−2ζ¯ε+ ¯ε/parenrightbigmi\nk\n≥/parenleftbig\n1−/parenleftbig\n2ζ−1/parenrightbig\n¯ε/parenrightbig|Si|\nk\n\n20 Dynamic Necklace Splitting\nSimilarly, we prove the right inequality.\n|Si∩Iζ|≤1 + ¯ε\nk−ζ+ 1/vextendsingle/vextendsingleSi\\Iζ−1/vextendsingle/vextendsingle\n=1 + ¯ε\nk−ζ+ 1/parenleftbigg\nmi−ζ−1/summationdisplay\nj=1|Si∩Ij|/parenrightbigg\n≤1 + ¯ε\nk−ζ+ 1/parenleftigg\n1−ζ−1/summationdisplay\nj=11−/parenleftbig\n2j−1/parenrightbig\n¯ε\nk/parenrightigg\nmi\n= (1 + ¯ε)/parenleftigg\n1 +/parenleftbig\n−ζ+ 2ζ−1/parenrightbig\n¯ε\nk−ζ+ 1/parenrightigg\nmi\nk\n≤(1 + ¯ε)/parenleftbig\n1 +/parenleftbig\n−ζ+ 2ζ−1/parenrightbig\n¯ε/parenrightbigmi\nk\n=/parenleftbig\n1 + 2ζ¯ε−ζ¯ε+/parenleftbig\n2ζ−ζ−1/parenrightbig\n¯ε2/parenrightbigmi\nk\n</parenleftbig\n1 + 2ζ¯ε−ζ¯ε+ ¯ε/parenrightbigmi\nk\n≤/parenleftbig\n1 +/parenleftbig\n2ζ−1/parenrightbig\n¯ε/parenrightbig|Si|\nk\nBy induction, the claim holds. Finally, substituting¯ε=ε\n2k, we have\n(1−ε)|Si|\nk<|Si∩Ij|<(1 +ε)|Si|\nk.\n◀",
  "textLength": 55518
}