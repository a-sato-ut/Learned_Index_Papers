{
  "paperId": "f0f8843a343d66a03602f31b560fa432775c9549",
  "title": "Learning-Augmented Online TSP on Rings, Trees, Flowers and (almost) Everywhere Else",
  "pdfPath": "f0f8843a343d66a03602f31b560fa432775c9549.pdf",
  "text": "Learning-Augmented Online TSP on Rings, Trees,\nFlowers and (almost) Everywhere Else\nEvripidis Bampis /envelope/orcid\nSorbonne Université, CNRS, LIP6, F-75005 Paris, France\nBruno Escoﬃer /envelope/orcid\nSorbonne Université, CNRS, LIP6, F-75005 Paris, France\nInstitut Universitaire de France, Paris, France\nThemis Gouleakis /envelope/orcid\nNational University of Singapore, Singapore, Singapore\nNiklas Hahn /envelope/orcid\nSorbonne Université, CNRS, LIP6, F-75005 Paris, France\nKostas Lakis /envelope/orcid\nETH Zürich, Zürich, Switzerland\nGolnoosh Shahkarami /envelope/orcid\nMax-Planck-Institut für Informatik, Universität des Saarlandes, Saarbrücken, Germany\nMichalis Xefteris /envelope/orcid\nSorbonne Université, CNRS, LIP6, F-75005 Paris, France\nAbstract\nWe study the Online Traveling Salesperson Problem (OLTSP) with predictions. In OLTSP, a\nsequence of initially unknown requests arrive over time at points (locations) of a metric space. The\ngoal is, starting from a particular point of the metric space (the origin), to serve all these requests\nwhile minimizing the total time spent. The server moves with unit speed or is “waiting” (zero speed)\nat some location. We consider two variants: in the open variant, the goal is achieved when the last\nrequest is served. In the closed one, the server additionally has to return to the origin. We adopt a\nprediction model, introduced for OLTSP on the line [ 23], in which the predictions correspond to the\nlocations of the requests and extend it to more general metric spaces.\nWe ﬁrst propose an oracle-based algorithmic framework, inspired by previous work [ 13]. This\nframework allows us to design online algorithms for general metric spaces that provide competitive\nratio guarantees which, given perfect predictions, beat the best possible classical guarantee ( consist-\nency). Moreover, they degrade gracefully along with the increase in error ( smoothness ), but always\nwithin a constant factor of the best known competitive ratio in the classical case ( robustness ).\nHaving reduced the problem to designing suitable eﬃcient oracles, we describe how to achieve\nthis for general metric spaces as well as speciﬁc metric spaces (rings, trees and ﬂowers), the resulting\nalgorithms being tractable in the latter case. The consistency guarantees of our algorithms are tight\nin almost all cases, and their smoothness guarantees only suﬀer a linear dependency on the error,\nwhich we show is necessary. Finally, we provide robustness guarantees improving previous results.\n2012 ACM Subject Classiﬁcation Theory of computation →Design and analysis of algorithms\nKeywords and phrases TSP, online algorithms, predictions, competitive analysis\nFunding This work was partially funded by the grant ANR-19-CE48-0016 from the French National\nResearch Agency (ANR).arXiv:2305.02169v1  [cs.DS]  3 May 2023\n\nBampis et al. 1\n1 Introduction\nIn the classical Traveling Salesperson Problem (TSP), we are given a set of locations as well\nas the pairwise distances between them and the objective is to ﬁnd a shortest tour visiting all\nthe locations. TSP is one of the most fundamental and well studied problems in Computer\nScience [ 30]. We focus on the online version of the problem in a metric space, the Online\nTraveling Salesperson Problem (OLTSP), introduced in the seminal paper of Ausiello et\nal. [10]. In OLTSP, the input arrives over time, i.e., new requests (locations) that have to be\nvisited by the traveler (or server) will appear during the travel. The time in which a request\nis communicated to the traveler is called its release time (or release date). The objective is\nthe minimization of the total traveled time assuming that at any time the traveler either\nmoves at unit speed or is “waiting” (zero speed) at some location1. We study both the closed\nvariant, where the server is required to return to the origin after serving all requests, and\ntheopenvariant, where the server does not have to return to the origin after serving all the\nrequests. A series of papers considered many variations of OLTSP in diﬀerent metric spaces\n(general metric space [ 10,13], the line [ 10,17,23], the semi-line [ 9,13,18], the ring [ 13,27]\nand the star [13]).\nThe motivation of studying OLTSP and its variations comes from applications in many\ndiﬀerent domains, such as e.g. logistics and robotics [ 8,37]. In the framework of competitive\nanalysis, the performance of an online algorithm is usually evaluated using the competitive\nratio which is deﬁned as the maximum ratio between the cost of the online algorithm and the\ncost of an optimal oﬄine algorithm, which by deﬁnition has knowledge of the entire input\nin advance, over all input instances. However, it is admitted that the competitive analysis\napproach can be overly pessimistic as it is calculated considering worst-case instances, giving a\nlot of power to the adversary. Hence, many papers try to limit the power of the adversary [ 18],\nor give extra knowledge and hence more power to the online algorithm [1, 13, 26].\nMore recently, the framework of Learning-Augmented (LA) algorithms has emerged due\nto the vibrant successes of Machine Learning methods and Artiﬁcial Intelligence in predicting\nand learning the unknown (i.e., future inputs in the case of online algorithms) based on\ndata [32]. In this line of research, the goal is to utilize predictions of the future input that\nhave potentially been acquired using a learning algorithm, in order to have provably improved\ncompetitive ratio in the case that the predictions are accurate enough, while maintaining\nworst-case guarantees even if the prediction error is arbitrarily large. In particular, a (possibly\nerroneous) prediction of the input is given to the algorithm and the goal is to design algorithms\nwith a good performance guarantee when the prediction is accurate (consistency), a not too\nbad (and bounded) performance when the prediction is wrong (robustness) and a gradual\ndeterioration of the competitive ratio with respect to the prediction error (smoothness). We\ngive more precise deﬁnitions in Section 2.\nRecent works have proposed a variety of approaches to tackle OLTSP with predictions\n(LA-OLTSP). In [ 23], Gouleakis et al. studied a learning-augmented framework for OLTSP\non the line. They introduced a prediction model in which the predictions correspond to\nthe locations of the requests. They proposed LA algorithms for both the closed and the\n1Note that this choice of possible speeds is w.l.o.g., as any setting where the maximum speed is bounded\ncan be reduced to this setting. Speciﬁcally, if the maximum speed is some S > 0, we can normalize\nthe maximum speed to be 1and multiply all distances by S. Also, our setting can simulate any other\nsetting where the algorithm is free to chose either the unit speed of some other speed 0<s< 1. Moving\nat speedsis equivalent to dividing the time into intervals of length dt→0and moving at unit speed\nonly for time s·dtwithin each interval.\n\n2 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\nopen variants that are consistent, smooth and robust. Bampis et al., in [ 13], considered\nthe case of perfect predictions of the locations and studied diﬀerent metric spaces (general\nmetric space, semi-line, ring, and star) and proposed competitive online algorithms and lower\nbounds. In [ 25], Hu et al. proposed three diﬀerent prediction models for OLTSP. In two\nof their models, each request is associated to a prediction for both its release time and its\nlocation while in the third one the prediction is just the release time of the last request.\nIn [16], Bernardini et al. studied OLTSP with predictions of both the release time and the\nlocation of each request. They introduced a new error measure, the cover error, and they also\nconsidered other online graph problems. More recently, Chawla and Christou [ 19] studied\nthe Online Time-Windows TSP with predictions of release time and location of the requests.\nIn this work, we adopt the prediction model of [ 23]. We propose a general oracle-based\nframework that allows us to design consistent, smooth and robust LA algorithms for both\nthe closed and open variants of the problem for diﬀerent metric spaces. We also provide\nsome interesting lower bounds.\n1.1 Our contributions and techniques\nIn this paper, we propose a novel approach to improve the competitive ratio of OLTSP using\npredictions concerning the locations of requests in general metric spaces. Our algorithms\nprovide tight competitive ratio guarantees in most cases. Moreover, we show how to get\npolynomial-time/FPT algorithms in speciﬁc metrics, namely rings, trees and ﬂowers.\nBampis et al. [ 13] gave an algorithm for general metrics with a competitive ratio of 3/2\nfor the case of perfect predictions (known locations), which is tight. First, in Section 3,\nwe modify this algorithm (still under the assumption of perfect predictions) and introduce\nour main oracle-based 3/2-competitive framework, which we call Strategically Wait And Go\n(SWAG, for pseudocode see Algorithm 1). The main idea is to consider a suitable subset of\npermutations of the requests, referred to as Dominating permutations , given by a so-called\nDomination oracle instead of all the permutations. This allows for a reduction of the running\ntime, since the bottleneck is located in the cardinality of the set of considered permutations.\nThis restriction of the permutation set preserves the consistency of 3/2.\nThen, we introduce our main algorithm, Learning-Augmented Strategically Wait And\nGo(LA-SWAG, for pseudocode see Algorithm 2), which does not assume perfect predictions.\nLA-SWAG is consistent, smooth, and robust. More formally, in Section 4 we show the following.\nITheorem 1 (Consistency and Smoothness) .LA-SWAG has a competitive ratio of at most\n3/2 + 5ηfor both closed and open LA-OLTSP.\nHere,ηis the error of the prediction (deﬁned formally later) that captures the normalized\nsum of distances between predicted and actual locations of the requests. Note that for η= 0,\nwe get a consistency of 3/2, which is tight for all cases except the open variant on trees.\nAdditionally, we show a smoothness lower bound of 3/2 +η/2for the open variant with\nη∈[0,1/3](Proposition 14), implying that a linear dependency on ηis required.\nRegarding robustness, the algorithm in [ 23] achieves 3-robustness on the line. LA-SWAG\nimproves this bound for general metrics and further so in speciﬁc metrics.\nITheorem 2 (Robustness-Closed) .LA-SWAG is2.75-robust for closed LA-OLTSP in general\nmetric spaces, and 2.5-robust in Euclidean spaces and in trees.\nITheorem3 (Robustness-Open) .LA-SWAG is(3−1/6)-robust for open LA-OLTSP in general\nmetric spaces, and (3−1/3)-robust in trees.\n\nBampis et al. 3\nOur analysis for 2.5-robustness and (3−1/3)-robustness is tight even on the line (Remarks\n18 and 21). Moreover, we show a negative result concerning the consistency/robustness\ntrade-oﬀ of any algorithm for the open variant (Lemma 22).\nThe main technical contribution of our work, found in Sections 5 and 6, is the imple-\nmentation of the domination oracles we have referred to. On a high level, we say that a\npermutation πdomdominates another permutation πat timet, if the following conditions\nhold. Assuming qis the ﬁrst unreleased request in πat timet, the distance traveled up to q\nis not longer in πdom, and also a superset of the requests preceding qinπis visited before q.\nMoreover,πdominduces a not longer path than π. These two key facts allow us to preserve\n3/2-consistency.\nFor general metrics, we achieve this domination using a very similar idea as the one\nemployed in the deﬁnition of the O(n22n)dynamic programming solution of the classical\nTSP [15,24]. That is, for any possible subset of released requests that might have been\nserved byπbeforeq, we simply build two optimal paths for the parts before and after q\n(without release times) and then we concatenate them to get a dominating permutation. We\ncall the resulting sets general dominating sets . Any permutation is dominated by the one\ncorresponding to the correct guess of requests served up to q. This yields a single-exponential\ntime algorithm overall.\nITheorem 4 (General Metrics) .LA-SWAG with an oracleDwhich uses the general dominating\nsets runs in single-exponential time and is min{3/2 + 5η,2.75}-competitive for the closed\nvariant and min{3/2 + 5η,3−1/6}-competitive for the open variant of LA-OLTSP.\nThe overarching insight behind how we reduce the runtime in speciﬁc metrics is the\nfact that we do not really need to try all possible subsets of requests served before q. For\nexample, in trees, we ﬁrst show a structural result about the optimal solutions (with release\ntimes). Speciﬁcally, we prove that the requests placed along a path from a leaf to the origin\n(considered the root) can be assumed to be served in a very speciﬁc order. This is the order in\nwhich the requests are encountered as one traverses the path from the leaf to the origin. This\nfact allows us to design a domination oracle which, roughly, provides a single permutation\nfor any subset of leavesvisited before q. Hence, we get an FPT algorithm parameterized by\nthe number lof leaves of the tree.\nITheorem 5 (Trees).There exists a Domination oracle for LA-SWAG in trees which yields a\ntime complexity of O(2l·n3)for the closed variant and O(2l·n4)for the open variant, where\nlis the number of leaves of the input tree.\nAs a ﬁrst step towards more general graphs, we deal with the concept of cycles by\nconsidering the ring. While we cannot retrieve the exact same structural result about online\noptimal solutions, we show something quite similar. Namely, we prove that the cyclic nature\nof the ring may be utilized only once by an optimal solution. After such a cyclic traversal,\nwe can assume that the ring is split in half, yielding a tree which we know how to deal with.\nITheorem 6 (Ring).There exists a Domination oracle for LA-SWAG in the ring which yields\na time complexity of O(n3)for the closed variant and O(n5)for the open variant.\nFinally, we combine the two previous sets of ideas to tackle ﬂowers. Flowers are essentially\ncomprised of a bunch of rings (petals) and a semi-line (stem), all of which are attached to\nthe origin. It is still true that each single ring may be assumed to be traversed with a loop\nonly once in this case. It turns out that we can consider at most 6options for every petal.\n\n4 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\nITheorem 7 (Flowers).There exists a Domination oracle for LA-SWAG in ﬂowers which\nyields a time complexity of O(6p·n3)for the closed variant and O(6p·n5)for the open\nvariant, where pis the number of petals of the input ﬂower.\nWe summarize our results in Tables 1 and 2. In the closed variant, there is a lower bound\nof3/2even in the case of a line [ 23]. In the open one, we show a lower bound of ≈1.468\neven in the case of a line in the Appendix (Proposition 44) and there is a lower bound of 3/2\neven in the case of a ring [13].\nTable 1Consistency, smoothness, robustness and runtime guarantees of LA-SWAG.\nSmoothness\n(Consistency for η= 0)Robustness Runtime\nClosed/Open Closed Open Closed Open\nTree\n3/2 + 5η2.5 3−1/3O(2l·n3)O(2l·n4)\nRing 2.75 3−1/6O(n3)O(n5)\nFlower 2.75 3−1/6O(6p·n3)O(6p·n5)\nEuclidean 2.5 3−1/6O(n2·2n)O(n2·2n)\nGeneral 2.75 3−1/6O(n2·2n)O(n2·2n)\nTable 2Consistency of LA-SWAG and other tractable algorithms. The upper bounds with * are\ngiven by an FPT algorithm and a polytime algorithm otherwise. Tight bounds are denoted in bold.\nConsistency\nClosed Open\nPrevious work This paper Previous work This paper\nLine 3/2[23] 3/2 5/3 [23] 3/2\nStar 7/4+/epsilon1[13] 3/2∗2 [13] 3/2∗\nTree 2 [10] 3/2∗2 [13] 3/2∗\nRing 5/3 [13] 3/2 2 [13] 3/2\nFlower 2 [10] 3/2∗2 [13] 3/2∗\n1.2 Further related works\nThe oﬄine version of the problem, in which the locations and release times are known in\nadvance, has been studied in [ 17,37] for both closed and open variants. For OLTSP, a\n2-competitive algorithm for the closed variant and a 2.5-competitive algorithm for the open\nvariant have been proposed in general metric spaces by [ 10]. Speciﬁcally on the line, there\nexist lower bounds of 1.64[10] and 2.04[17] for the closed and open variants, respectively.\nIn addition to online TSP, there are several works that have explored learning augmented\nsettings. The online caching problem with predictions was investigated by [ 32], and the initial\nresults were improved by [ 3,39,41]. Adopting the LA approach, algorithms were developed\nfor the ski-rental problem [ 2,22,38,40] as well as for scheduling problems [ 4,11,34,36].\nThere is also literature on learning augmented algorithms for classical data structures [ 29],\nbloom ﬁlters [ 33], routing problems [ 14,21,28], online selection and matching problems [ 5,20]\nand a more general framework of online primal-dual algorithms [ 12]. There is a survey [ 35]\nand an updated list of papers [31] in this area.\n\nBampis et al. 5\n2 Preliminaries\nOnline TSP (OLTSP).\nThe input of OLTSP consists of a metric space Mwith a distinguished point O(the origin),\nand a setQ={q1,...,qn}ofnrequests. Every request qiis a pair (xi,ti), wherexiis a point\nofMandti≥0is a real number. We use tto quantify time. The number tirepresents the\nmoment after which the request qican be served (release time). A server located at the\norigin at time t= 0, which can move with unit speed, must serve all the requests after their\nrelease times with the goal of minimizing the total completion time (makespan).\nWe consider a wide class of continuous metric spaces Mwhose corresponding distance\nmetricd(x,y)is deﬁned as the shortest path from x∈Mtoy∈Mand is continuous in M,\nas in [10]. We call this class general metric spaces (or general metrics). The release times for\ncontinuous metric spaces can be any non-negative real number.\nFor the rest of the paper, we denote the total completion time of an online algorithm\nALGby|ALG|and that of an optimal (oﬄine) solution OPTby|OPT|. We recall that an\nalgorithm ALGisρ-competitive if on all instances we have |ALG|≤ρ·|OPT|.\nLearning-augmented algorithms.\nIn order to measure the quality of the predictions, we will deﬁne a prediction error η. LA\nalgorithms have three main properties. We use the formal deﬁnitions in [ 23] here. We say\nthat an algorithm is\nα-consistent , if it isα-competitive whenη= 0,\nβ-robust, if it is always β-competitive regardless of η, and\nγ-smoothfor a continuous function γ(η), if it isγ(η)-competitive .\nIn general, if cis the best competitive ratio achievable without predictions, it is desirable to\nhaveα<c,β≤k·cfor some constant kand also the function γshould increase from αto\nβalong with the error η.\nOur prediction setting.\nLetQ={q1,...,qn}be the set of requests. As we mentioned, each request qihas a\ncorresponding release time tiand a location xi. We have a set of predictions P={p1,...,pn}\nin whichpipredictsxi, the location of request qi. The algorithm gets these predictions as\nwell as the number of requests nas an oﬄine input. The actual values of xiandtionly\nbecome known at time-point ti.\nThe predictions’ quality can vary and is unknown to the algorithm. We can evaluate\nthe quality by deﬁning a measure η. Essentially, ηmeasures the sum of all the distance\nbetween the predicted location and the actual ones normalized by the length of a shortest\npath serving all the requests.\nIDeﬁnition 8 (Prediction Error) .The prediction error of an instance is deﬁned by η=/summationtextn\ni=1d(xi,pi)\nF, whereFis the length of a shortest path serving all the requests (and returning\nto the origin in the closed case).\nNote that the prediction error is scale invariant (i.e., it will not change if all the distances\nare multiplied by a constant factor), and Facts as the normalization factor.\n\n6 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\n3 Oracle-based framework: the SWAG algorithm\nIn this section, we deﬁne an oracle-based algorithm, SWAG, designed for the case of perfect\npredictions. The oracle provides the algorithm with a set of permutations of the requests.\nWe show that if the oracle satisﬁes some conditions, then SWAGhas a competitive ratio of\n3/2.\nSWAGis actually a (slightly) modiﬁed version of the general algorithm in [ 13]. The principle\nof this latter algorithm is the following:\nFirst, to wait at Ountil a chosen time T. This time Tdepends both on the requests’\nlocations and on their release times.\nThen, to choose a route of serving requests that minimizes some criterion involving the\nlength of the corresponding route and the fraction of it which is released at time T, and\nto follow this route, waiting at unreleased requests.\nThe calculation of the chosen time Ton the ﬁrst step is done by computing some values on\nallthen!permutations of the requests. The improvement we show here is that we can get\nthe same competitive ratio (i.e., 3/2) while considering not the whole set of permutations,\nbut some well chosen (and ideally small) subset that satisﬁes a certain property. This subset\nof permutations is given to the algorithm by the oracle.\nThen, based on this framework, to derive an eﬃcient 3/2-competitive algorithm, one only\nhas to build an eﬃcient oracle. We will show for example in Section 6 that for lines or rings,\nwe can devise a polytime oracle building a polysize subset of permutations, leading to a\npolytime 3/2-competitive algorithm for these metrics.\nMore formally, we consider SWAG, which uses the following notation. For a given order σ\non the requests (where σ[i]denotes the i-th request in the order), we denote:\nby/lscriptσthe length of the route associated to σ(starting atO), i.e.,/lscriptσ=d(O,σ[1]) +/summationtextn−1\nj=1d(σ[j],σ[j+1])in the open case, /lscriptσ=d(O,σ[1])+/summationtextn−1\nj=1d(σ[j],σ[j+1])+d(σ[n],O)\nin the closed case;\nbyασ(t)the fraction of the length of the largest fully released preﬁx of the route associated\ntoσat timetover/lscriptσ. More formally, if all nrequests are released, then ασ(t) = 1for all\nσ, otherwise, if requests σ[1],...,σ [k−1]are released at tbutσ[k]is not, then the route\nis fully released up to σ[k], and\nασ(t) =/parenleftbig\nd(O,σ[1]) +k−1/summationdisplay\nj=1d(σ[j],σ[j+ 1])/parenrightbig\n//lscriptσ.\nNote that this deﬁnition requires /lscriptσ>0. If/lscriptσ= 0, i.e., all requests are at O, we set\nασ= 1.\nThe algorithm for general metrics in [ 13] considers all possible permutations of requests to\nﬁnd the waiting time Tand a good permutation to follow. With SWAG, we build on this idea.\nCrucially, at any point in time t, it focuses only on a subset Sof permutations to determine\nTand the permutation to follow. The key idea behind these subsets is the following. To\nachieve the same competitive ratio, it is suﬃcient that for any possible permutation σ, the\nsetScontains a permutation σ/primethat induces a tour/path that is not longer than that of σ,\nand its unreleased portion of the tour at time tis not larger than that of σ. We will say that\nσ/primedominatesσand deﬁne this notion formally below. Furthermore, since the released parts\nonly change when a new request is released, it is suﬃcient to only update the subset in that\ncase.\n\nBampis et al. 7\nAlgorithm 1 Strategically Wait And Go (SWAG)\nInput:Oﬄine: request locations x1,...,xn\nOnline: release times t1,...,tn\nParameter: an oracle Dwhich outputs a set of permutations on requests\n1Call the oracleDto get an initial set S(0)of permutations at t= 0. SetS=S(0).\n2whiletruedo\n3At each release time ti, request a new set S(ti)of permutations and update\nS=S(ti). For every σ∈S, compute/lscriptσandασ(ti).\n4If∃σ0∈Ss.t. (1)t≥/lscriptσ0/2and (2)ασ0(t)≥1/2, setT=tandbreak.\n5end\n6At timeT:\nCompute an order σ1which minimizes, over all orders σ/prime∈S,(1−βσ/prime)/lscriptσ/prime,\nwhereβσ/prime= min{ασ/prime(T),1/2}.\nFollow the tour/path associated to σ1. Serve the requests in this order,\nwaiting at a request location if this request is not released.\nIDeﬁnition 9 (Dominating permutation) .Letσbe a permutation of the nrequests and ta\ngiven time. We deﬁne Dom( σ,t) to be the set of permutations that dominate permutation σ\nat timet. A permutation σ/prime∈Dom (σ,t)if and only if:\n/lscriptσ/prime≤/lscriptσ, (1)\nand\n(1−ασ/prime(t))/lscriptσ/prime≤(1−ασ(t))/lscriptσ. (2)\nWe also say that σ/primeis a corresponding dominating permutation of σ(at timet).\nFor ease of exposition, we assume that the subsets of permutations are given to the\nalgorithm by an oracle D. We will discuss in Sections 5 and 6 how to implement such oracles\nfor speciﬁc cases.\nWe show that SWAGwith an oracleDis3/2-consistent ifDis adomination oracle .\nFormally, we have the following.\nIDeﬁnition 10 (Domination oracle) .An oracleDwhich outputs at time ta setS(t)of\npermutations is a domination oracle if\n1.S(t)⊆S(t/prime)for everyt≤t/prime, and\n2.for alltthere exists a permutation σ/prime∈S(t)such thatσ/prime∈Dom(σOPT,t). Here,σOPT\nis the permutation corresponding to the serving order of requests in an optimal solution.\nILemma 11. SWAGis3/2-consistent for both closed and open variants of OLTSP with\nperfect predictions if it uses a domination oracle.\nProof.We denote by S(t)the set of permutations that the algorithm considers at time t\n(setSin the description of SWAG) and bytqthe release time of a request q. Note that the\nfew times we drop the dependence on twe implyt=T.\nFirst, we show that the algorithm always terminates since the while loop in SWAGalways\nterminates when a domination oracle is used. When all requests have been released we have\nthatασ(t) = 1for every permutation σof requests. From Equation (2)and the domination\noracle’s condition 2 we get that there is σ/prime∈S(t)such that (1−ασ/prime(t))/lscriptσ/prime≤0. Then\n\n8 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\nασ/prime(t) = 1(when/lscriptσ/prime= 0we also have that ασ/prime(t) = 1from the deﬁnition of α). So, there is\na timet/primesuch thatt/prime=/lscriptσ/prime/2and the loop terminates no later than t=t/prime.\nAt timeT, there exists a permutation σ0∈S(T)withT≥/lscriptσ0/2andασ0(T)≥1/2.\nThenβσ0= 1/2, and (1−βσ0)/lscriptσ0=/lscriptσ0/2≤T. By deﬁnition of σ1, we have (1−βσ1)/lscriptσ1≤\n(1−βσ0)/lscriptσ0. So we get\n(1−βσ1)/lscriptσ1≤T . (3)\nNow let us consider the optimal solution OPTand its corresponding permutation σOPT.\nConsider at time ta corresponding dominating permutation of OPT,σ/prime(t)∈S(t)(domination\noracle’s condition 2). Since σ/primewill always refer to a permutation that dominates OPT, we\ndrop the OPTin the notation. From Equation (2), it follows that\n|OPT|≥T+ (1−ασOPT(T))/lscriptσOPT≥T+ (1−ασ/prime(T)(T))/lscriptσ/prime(T).\nWe distinguish two cases for the value of ασ/prime(T)(T).\nIfασ/prime(T)(T)≤1/2, thenβσ/prime(T)(T) =ασ/prime(T)(T), and\n|OPT|≥T+ (1−ασ/prime(T)(T))/lscriptσ/prime(T)=T+ (1−βσ/prime(T)(T))/lscriptσ/prime(T).\nSinceσ1is a minimizer for (1−β)/lscriptatTwe get\n|OPT|≥T+ (1−βσ1)/lscriptσ1.\nOtherwise, if ασ/prime(T)(T)>1/2, thenβσ/prime(T)(T) = 1/2. We study two sub-cases.\nCase 1:T/negationslash=tqfor every request q. Since the algorithm updates set S(t)only when\nthere is a release of a new request, the corresponding dominating permutation of OPT,\nσ/prime(T), is the same at T−/epsilon1/prime,∀/epsilon1/prime∈(0,/epsilon11]for a suﬃciently small /epsilon11>0(we can choose /epsilon11\nsuch that there is no release of a new request in [T−/epsilon1/prime,T],∀/epsilon1/prime∈(0,/epsilon11]). So, we have\nthatσ/prime(T) =σ/prime(T−/epsilon1/prime),∀/epsilon1/prime∈(0,/epsilon11].\nWe now look at the position of OPTat timeTin its route. Suppose that it is (strictly)\non the second half of this route. Then, at T−/epsilon1(for a suﬃciently small /epsilon11≥/epsilon1>0), it\nwas already on the second part. But then T−/epsilon1≥/lscriptσOPT/2(asOPThas already visited\nhalf of the route). So, from Equation (1) we get T−/epsilon1≥/lscriptσOPT/2≥/lscriptσ/prime(T−/epsilon1)/2. Moreover,\nsince in [T−/epsilon1,T]there is no release of a new request, we have that ασ/prime(T−/epsilon1)(T−/epsilon1) =\nασ/prime(T−/epsilon1)(T)>1/2. ThenT−/epsilon1would satisfy the two conditions for the starting time of\nthe algorithm, a contradiction with the deﬁnition of T. Consequently, at T,OPTis in the\nﬁrst half of its route. So |OPT|≥T+/lscriptσOPT/2≥T+/lscriptσ/prime(T)/2 =T+(1−βσ/prime(T)(T))/lscriptσ/prime(T).\nSinceσ1is a minimizer for (1−β)/lscriptatT, we get|OPT|≥T+ (1−βσ1)/lscriptσ1.\nCase 2:T=tqfor some request q. We can now ﬁnd a (suﬃciently small) /epsilon11>0\nsuch that there is no release of a new request in [T−/epsilon11,T). We can then ﬁnd another\n(suﬃciently small) /epsilon12with 0</epsilon12≤/epsilon11such that OPTis only in the ﬁrst half of its route\nin[T−/epsilon12,T)or only on the second half of its route in [T−/epsilon12,T). Let/epsilon1∈(0,/epsilon12]. We\nnow look at the position of OPTat timeT−/epsilon1in its route.\nIfOPTis in the ﬁrst half at T−/epsilon1, then|OPT|≥T−/epsilon1+/lscriptσOPT/2≥T−/epsilon1+/lscriptσ/prime(T)/2 =\nT−/epsilon1+ (1−βσ/prime(T)(T))/lscriptσ/prime(T). The inequality holds for every choice of /epsilon1∈(0,/epsilon12],\nso taking the limit /epsilon1→0we get|OPT|≥T+ (1−βσ/prime(T)(T))/lscriptσ/prime(T). Sinceσ1is a\nminimizer for (1−β)/lscriptatT, we get|OPT|≥T+ (1−βσ1)/lscriptσ1.\n\nBampis et al. 9\nIfOPTis (strictly) on the second half of its route at T−/epsilon1, then consider a corresponding\ndominating permutation of OPTatT−/epsilon1that is contained in S(T−/epsilon1),σ/prime(T−/epsilon1).\nSuppose that ασ/prime(T−/epsilon1)(T−/epsilon1)>1/2. Then, since OPTis (strictly) on the second half\natT−/epsilon1, we have that T−/epsilon1≥/lscriptσOPT/2(asOPThas already visited half of the route).\nSo, from Equation (1)we getT−/epsilon1≥/lscriptσOPT/2≥/lscriptσ/prime(T−/epsilon1)/2. ThenT−/epsilon1would satisfy\nthe two conditions for the starting time of the algorithm, a contradiction with the\ndeﬁnition of T. So, if OPTis (strictly) on the second half of its route at T−/epsilon1, it holds\nthatασ/prime(T−/epsilon1)(T−/epsilon1)≤1/2.\nSo,ασ/prime(T−/epsilon1)(T−/epsilon1)≤1/2andβσ/prime(T−/epsilon1)(T−/epsilon1) =ασ/prime(T−/epsilon1)(T−/epsilon1). From Equation (1)\nwe have that\n|OPT|≥T−/epsilon1+ (1−ασOPT(T−/epsilon1))/lscriptσOPT\n≥T−/epsilon1+ (1−ασ/prime(T−/epsilon1)(T−/epsilon1))/lscriptσ/prime(T−/epsilon1)\n=T−/epsilon1+ (1−βσ/prime(T−/epsilon1)(T−/epsilon1))/lscriptσ/prime(T−/epsilon1).\nNote that at time Tthe setS(T)also contains the permutation σ/prime(T−/epsilon1)that dominates\nσOPTatT−/epsilon1(domination oracle’s condition 1). So, ασ/prime(T−/epsilon1)(T−/epsilon1)≤ασ/prime(T−/epsilon1)(T)and\nβσ/prime(T−/epsilon1)(T−/epsilon1)≤βσ/prime(T−/epsilon1)(T), forevery/epsilon1∈(0,/epsilon12](αandβarenondecreasingfunctions\noftimeforaﬁxedpermutation). Thus, weget |OPT|≥T−/epsilon1+(1−βσ/prime(T−/epsilon1)(T))/lscriptσ/prime(T−/epsilon1).\nThis implies|OPT|≥T−/epsilon1+ (1−βσ1)/lscriptσ1sinceσ1is a minimizer for (1−β)/lscriptat\nT. As the above inequality holds for every /epsilon1∈(0,/epsilon12], for/epsilon1→0it follows that\n|OPT|≥T+ (1−βσ1)/lscriptσ1.\nConsequently, in all cases we have that\n|OPT|≥T+ (1−βσ1(T))/lscriptσ1. (4)\nNow we look at the value |ALG|of the solution ALGoutput by the algorithm. We\ndistinguish two cases:\nIfALGdoes not wait after T, it holds that|ALG|=T+/lscriptσ1. By deﬁnition βσ1(T)≤1/2,\nso|ALG|≤T+ 2(1−βσ1(T))/lscriptσ1. Adding Equations (3) and (4) with coeﬃcients 1/2\nand3/2, we getT+ 2(1−βσ1(T))/lscriptσ1≤3|OPT|/2. Hence,|ALG|≤3|OPT|/2.\nOtherwise, ALGwaits after Tfor some request to be released. Let t∗be the last time\nALGwaits. As a fraction ασ1(T)ofσ1is completely released at T(i.e., when ALG\nstarts), ALGhas distance at most (1−ασ1(T))/lscriptσ1to perform after t∗. So\n|ALG|≤t∗+ (1−ασ1(T))/lscriptσ1≤t∗+ (1−βσ1(T))/lscriptσ1, (5)\nwhere we use the fact that, by deﬁnition, βσ1(T)≤ασ1(T). We havet∗≤|OPT|, as a\nrequest is released at t∗. Adding Equations (3) and (4) gives 2(1−βσ1(T))/lscriptσ1≤|OPT|.\nPutting these two inequalities in Equation (5) gives |ALG|≤3|OPT|/2.\nJ\nLet us consider now the running time of SWAGand prove the following lemma.\nILemma 12. IfNis the maximum number of permutations which the oracle Doutputs at\neach timetandTDis the total time required (by the oracle) to compute all permutations,\nthen the running time of SWAGisO(max{n2·N,TD}).\nProof.For every release time tiand every permutation σ∈S(ti), the algorithm has to\ncompute the length /lscriptσand the fraction of the associated tour that is released, ασ. It can\n\n10 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\ndo that with O(n)operations and has to repeat this procedure n+ 1times, once for every\nrelease of a new request (and once at t= 0). IfNis the maximum number of permutations\nwhich the oracle Doutputs, then the total running time of the algorithm without taking\nthe oracle’s workload into account is O(n2·N). Moreover, if we assume that for all calls of\nthe oracleDthe total computational time required by Dto compute all permutations is TD,\nthen the total running time of SWAGisO(max{n2·N,TD}). J\n4 Performance guarantees for LA-OLTSP: the LA-SWAG algorithm\nIn this section, we deal with imperfect predictions; more speciﬁcally, we show how to adapt\nSWAGto also get smoothness and robustness upper bounds. We ﬁrst present the algorithm,\nthen the consistency-smoothness analysis, and ﬁnally the robustness analysis.\nAlgorithm 2 Learning-Augmented Strategically Wait And Go (LA-SWAG)\nInput:Oﬄine: predicted request locations p1,...,pn\nOnline: release times t1,...,tn, true request locations x1,...,xn\nParameter: an oracle Dwhich outputs a set of permutations on requests\n1(Breaking rule) At any time t: if all requests are released, follow an optimal path\nserving all unserved requests (returning to Oif in the closed variant) and break.\n2Run SWAGuntil the starting time Tof the server, and the computation of σ1.\n3At timeT, follow the tour/path σ1, serving the requests in the following order:\n4fori= 1,...,n do\nﬁrst go topσ1[i]; ifqσ1[i]is not released, wait there until it is released;\nthen, go to xσ1[i]and serve the request.\n5end\n6In the closed version, go back to O.\nWe note that if the predictions are perfect, then LA-SWAG is at least as good as SWAG(it\nworks the same, the only diﬀerence being that it optimally serves the remaining unserved\nrequests when everything is released). So in particular it is 3/2-consistent as well, provided\nthat the oracle satisﬁes the conditions of Lemma 11.\nWe also note that the algorithm could serve the request in a more clever way: instead of\ngoing ﬁrst to the predicted location of a request and then to its true location, the algorithm\ncould go to the true location directly if it is released (or as soon as it is). However, the lower\nbounds we will provide still hold under this modiﬁcation.\nRegarding the running time of LA-SWAG, it is trivial to see that if TTSPis the time\nrequired for the computation of an optimal path serving a subset of the requests, then from\nLemma 12 we get the following.\nICorollary 13. IfNis the maximum number of permutations which the oracle Doutputs\nat each time t,TDis the total time required (by the oracle) to compute all permutations and\nTTSPis the time for the computation of an optimal path that serves a subset of the requests,\nthen the running time of LA-SWAG isO(max{n2·N,TD,TTSP}).\nNote that, for the cases we consider, we achieve suitable bounds on TTSP. We describe\nhow this is this done for each metric space in Section 6.\n\nBampis et al. 11\n4.1 Smoothness\nWe now show that LA-SWAG is smooth with respect to the measure of error ηin the predictions,\nwhere we recall that η=/summationtextn\ni=1d(xi,pi)/FwithFthe length of a shortest TSP-tour serving\nall the requests (and returning to the origin in the closed case), ignoring release times. For\nconvenience, let ∆ =ηF=/summationtextn\ni=1d(xi,pi).\nITheorem 1 (Consistency and Smoothness) .LA-SWAG has a competitive ratio of at most\n3/2 + 5ηfor both closed and open LA-OLTSP.\nProof.LetIbe an instance of the problem with requests q1,...,qn, predictions p1,...,pn\nand actual locations x1,...,xn. Let us denote by IHa corresponding (hypothetical) instance\nof the problem where the predicted locations p1,...,pnwould be the actual ones (so IH\nis an instance with perfect predictions). Let us denote by ALGIH(resp. OPTIH) the\nsolution output by SWAGonIH(resp. an optimal solution on IH). By Lemma 11, we have\n|ALGIH|IH≤3/2|OPTIH|IHsince inIHthe predictions are perfect.\nNow, we ﬁrst claim that |ALG|I≤|ALGIH|IH+2∆. As previously noticed, the breaking\nrule in LA-SWAG cannot increase the value of the solution, so |ALG|I≤|ALG/prime|Iwhere\nALG/primeis the solution on Ithat would perform the entire for loop in Step 4 of LA-SWAG. Note\nthat now ALGIHandALG/primestart at the same time T, and serve the requests in the same\norderσ1. Lett∗be the last time ALG/primewaits on a prediction pσ1[s]for the actual instance I,\nort∗=TifALG/primenever waits on a prediction. In the ﬁrst case, ALGIHcannot serve the\ncorresponding request σ1[s]beforet∗(as it is not released). In the second case, ALGIHdoes\nnot leave the origin before t∗. Thus, denoting for convenience s= 0,σ1[0]= 0andp0=Oif\nALG/primenever waits at a prediction, we have for the closed case (just remove the term d(pn,O)\nfor the open case):\n|ALGIH|IH≥t∗+n−1/summationdisplay\ni=sd(pσ1[i],pσ1[i+1]) +d(pσ1[n],O).\nSince the hypothetical algorithm ALG/primemoves between predictions and requests, we get the\nfollowing bound on |ALG/prime|I\n|ALG/prime|I≤t∗+/parenleftBiggn−1/summationdisplay\ni=sd(pσ1[i],xσ1[i]) +d(xσ1[i],pσ1[i+1])/parenrightBigg\n+d(pσ1[n],xσ1[n]) +d(xσ1[n],O).\nUsing the triangle inequality d(xσ1[i],pσ1[i+1])≤d(xσ1[i],pσ1[i]) +d(pσ1[i],pσ1[i+1]), we get\n|ALG/prime|I≤t∗+/parenleftBiggn−1/summationdisplay\ni=sd(pσ1[i],pσ1[i+1]) + 2d(xσ1[i],pσ1[i])/parenrightBigg\n+ 2d(pσ1[n],xσ1[n]) +d(pσ1[n],O)\n≤|ALGIH|IH+ 2∆.\nNow, we shift our attention to the values |OPTI|Iand|OPTIH|IH. Our goal will be\nto show that|OPTI|I≥|OPTIH|IH−2∆. Since|OPTIH|IH≤|OPTI|IH, it suﬃces to\nshow|OPTI|I≥|OPTI|IH−2∆. We can assume that OPTmoves to the requests eagerly,\nfollowing an order σ, and leaves as soon as they are released. Similarly to before, let t∗be\nthe last time that the tour of OPTIin the instance IHinduces some waiting, and let qσ[s]\nbe that request (or the origin for s= 0, which also implies t∗= 0). It follows then that\n|OPTI|IH=t∗+n−1/summationdisplay\ni=sd(pσ[i],pσ[i+1]) +d(pσ[n],O).\n\n12 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\nBut, because the request qσ[s]is unreleased before t∗(the cases= 0impliest∗= 0, so\nthe conclusion will still hold), we also have\n|OPTI|I≥t∗+n−1/summationdisplay\ni=sd(xσ[i],xσ[i+1]) +d(xσ[n],O)\n≥t∗+/parenleftBiggn−1/summationdisplay\ni=s−d(xσ[i],pσ[i]) +d(pσ[i],pσ[i+1])−d(pσ[i+1],xσ[i+1])/parenrightBigg\n−d(xσ[n],pσ[n]) +d(pσ[n],O)\n≥|OPTI|IH−2∆,\nwhere we use the triangle inequality for the second inequality. The smoothness of the general\nalgorithm follows. We have |ALGIH|IH≤3/2|OPTIH|IH, which implies|ALG|I−2∆≤\n3/2(|OPTI|I+ 2∆). This gives us|ALG|I\n|OPTI|I≤3/2 + 5η. J\nLA-SWAG achieves smoothness that is linear in the error (besides the optimal consistency\nbound of 3/2). We now show that this linear dependency is necessary for the open case.\nIProposition 14 (Smoothness Lower Bound) .No algorithm can have a better competitive\nratio than (3/2 +η/2)for the open variant on an instance with prediction error η∈[0,1/3].\nProof.Letη∈[0,1/3], and deﬁne /epsilon1such thatη=/epsilon1/(2−/epsilon1)(i.e.,/epsilon1= 2η/(1 +η)). Note that\n/epsilon1∈[0,1/2]. Consider the graph represented in Figure 1.\n1\n1/epsilon1\n1−2/epsilon1\n/epsilon1/epsilon1\n1−2/epsilon1\n/epsilon1OA\nBC\nDE\nF\nFigure 1 An example for the open variant showing a metric space in which the competitive ratio\nhas to scale linearly with ηfor values of the latter up to 1/3.\nThere are two requests, q1predicted to be in location p1=Aandq2predicted to be in\np2=B. We assume w.l.o.g. that at time t= 1the algorithm is on [O,B]. Thenq1is released\natt= 1on its predicted location ( x1=p1=A). Note that at time 2−/epsilon1, the algorithm\nmust be at distance at least /epsilon1fromA(in particular, it cannot be on (C,A]or on (E,A]). If\nit is on [B,E], then we release the second request q2onD. Otherwise, we release it on F.\nSuppose w.l.o.g. that the ﬁrst case occurs. Then the algorithm needs at least one unit of\ntime to serve both requests (at t= 2−/epsilon1it is not on (B,C)and at distance at least /epsilon1from\nA). So|ALG|≥3−/epsilon1.\nThe optimal solution is to serve q1att= 1andq2att= 2−/epsilon1.Note thatη=/epsilon1\n2−/epsilon1is\nindeed the error in the prediction. Then\n|ALG|≥3−/epsilon1\n2−/epsilon1|OPT|=/parenleftbigg3\n2+η\n2/parenrightbigg\n|OPT|.\n\nBampis et al. 13\nJ\n4.2 Robustness\nWe now deal with the robustness analysis. We ﬁrst upper bound the robustness of LA-SWAG,\nand then complement this analysis with some lower bounds.\nIRemark 15 (3-Robustness). It is easy to see that LA-SWAG is 3-robust (in both the closed\nand open variants). Indeed, let tfbe the time when the ﬁnal request is released. Of course\n|OPT|≥tf. Then, at tfthe server can be at most |OPT|away from the origin. Since,\nthanks to the breaking rule, the algorithm serves the remaining requests optimally after\nt=tf, to return back to the origin and then follow OPTis an upper bound of its cost.\nSo,|ALG|≤tf+|OPT|+|OPT|≤3|OPT|and the robustness of the algorithm with\npredictions is at most 3.\nWe now improve this bound, both for the closed and open cases, both in general metrics\nand for speciﬁc metric spaces.\nLet us ﬁrst deal with the closed variant.\nClosed variant.\nILemma 16. LA-SWAG is2.75-robust for closed OLTSP in general metric spaces.\nProof.LetT≥0be the time computed in Step 2 of LA-SWAG. It depends both on the\npredicted locations of the requests and the (real) release times. Let c∈(0,1]be a real\nconstant to be determined later. We denote by ρthe ratio|ALG|/|OPT|.\nIfT >|OPT|, then ALGstarts following an optimal tour from the origin at time\nt=tf≤|OPT|because of the breaking rule. So, |ALG|≤2|OPT|and\nρ≤2. (6)\nIf0≤T≤c·|OPT|, then there is an order of requests σ0that the general algorithm keeps\ntrack of such that T≥/lscript/prime\nσ0/2,α/prime\nσ0(T)≥1/2andβ/prime\nσ0(T) = 1/2, where the parameters\nwith the prime symbol /lscript/prime,α/prime,β/primeare computed on the predicted locations and the real\nrelease times.\nLetσ1be the tour that our algorithm will follow at T. Thus, we have that\n/parenleftbig\n1−β/prime\nσ1(T)/parenrightbig\n/lscript/prime\nσ1≤/parenleftbig\n1−β/prime\nσ1(T)/parenrightbig\n/lscript/prime\nσ1=/lscript/prime\nσ1/2≤T .\nSinceβ/prime≤1/2, it holds that 1−β/prime\nσ1(T)≥1/2and/lscript/prime\nσ1≤2T. Hence, with the assumption\nT≤c·|OPT|we get that\n/lscript/prime\nσ1≤2c·|OPT|. (7)\nAfterT, the algorithm follows the order of requests σ1. It ﬁrst goes to the predicted\nlocation of a request and waits for its release. Then, it goes to the real location of the\nrequest and serves it. When all requests are released, the algorithm computes and follows\nan optimal path that serves the remaining requests and returns to the origin.\nThe furthest distance from the origin that a predicted request can have is LP≤/lscript/prime\nσ1/2.\nFrom(7), we getLP≤c·|OPT|. On the other hand, the furthest distance from the\norigin that a real request can have is LR≤/lscriptOPT/2≤|OPT|/2, where/lscriptOPTis the length\nof the optimal tour.\nNow let us consider the furthest distance that ALGcan have from the origin at time\nt=tf.ALGduring its tour moves between predicted and real locations of requests until\n\n14 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\npjOxi\nz\nFigure 2 The case for general metrics when the server goes from the furthest predicted location\npjto the location xiof the furthest (real) request qior vice-versa. The algorithm ( z) is always on\nthe shortest path between xiandpj.\ntimetf. In the following, we denote the position of ALGattfbyz. The worst-case occurs\nifALGgoes from the furthest predicted request to the furthest real request or vice-versa\n(see Fig. 2). From the triangle inequality, we have that d(z,O)≤d(O,xi) +d(xi,z)\nandd(z,O)≤d(O,pj) +d(pj,z). Hence, we have 2d(z,O)≤d(O,xi) +d(O,pj) +\nd(xi,z) +d(pj,z). Since the algorithm is on the shortest path between xiandpj, we\ngetd(xi,pj) =d(xi,z) +d(pj,z). Using the triangle inequality again it follows that\nd(xi,pj) =d(xi,z) +d(pj,z)≤d(O,xi) +d(O,pj). Therefore,\n2d(z,O)≤d(O,xi) +d(O,pj) +d(xi,z) +d(pj,z)≤2(d(O,xi) +d(O,pj)),\nwhich implies\nd(z,O)≤d(O,xi) +d(O,pj)≤LR+LP≤(1/2 +c)·|OPT|. (8)\nThe strategy that returns to the origin at time t=tfand then follows OPTis clearly an\nupper bound of|ALG|, and thus from (8)and the fact that tf≤|OPT|it follows that\n|ALG|≤tf+d(z,O) +|OPT|≤(2.5 +c)·|OPT|and\nρ≤2.5 +c . (9)\nElse,c·|OPT|< T≤|OPT|.Then, ALGis at most (|OPT|−T)away from the\norigin att=|OPT|. So, the following strategy is clearly an upper bound of |ALG|: an\nalgorithm that is in the origin at t=|OPT|+|OPT|−Tand then follows OPTto serve\nall requests. Thus, we get\nρ≤|OPT|+|OPT|−T+|OPT|\n|OPT|<(3−c)|OPT|\n|OPT|= 3−c . (10)\nWe can see that the case leading to (6)will not be a factor in the determination of the\nrobustness, so we can ignore it. We optimize (9)and(10)simultaneously. It is easy to see\nthat the best value is attained for c= 0.25, giving a robustness of 2.75. J\nMoreover, we observe that we can get a better robustness guarantee with almost the\nsame proof for the special metric spaces of Euclidean spaces and trees. More speciﬁcally, we\nget the following lemma.\nILemma 17. LA-SWAG is2.5-robust for closed OLTSP in Euclidean spaces and in trees.\nProof.The proof is almost the same as the proof of Lemma 16. The only diﬀerence is that\nsince it holds that d(z,O)≤max{d(O,xi),d(O,pj)}≤max{c·|OPT|,1/2·|OPT|}in these\n\nBampis et al. 15\nmetric spaces (as the algorithm is on a shortest path between xiandpj), we can actually get\na better upper bound than that of inequality (9), namely\nρ≤tf+ max{d(O,xi),d(O,pj)}+|OPT|\n|OPT|≤2 + max{1/2,c}. (11)\nWe can again ignore (6). Considering (10)and(11), we get robustness 2.5withc= 0.5.J\nFrom Lemma 16 and 17 we directly get the following theorem for the robustness of\nLA-SWAG in the closed variant.\nITheorem 2 (Robustness-Closed) .LA-SWAG is2.75-robust for closed LA-OLTSP in general\nmetric spaces, and 2.5-robust in Euclidean spaces and in trees.\nIRemark 18 (Tightness of Analysis for Closed Variant 2.5-Robustness.). The 2.5-robustness\nbound of LA-SWAG given in Lemma 17 is tight even on the line, as shown in the following\nexample. There are two requests. The real request locations are x1= 1,x2= 0, released\nat times 1 and 2, respectively, and the predictions are p1= 0,p2=−1. Note that at\ntime 1 our algorithm will start moving towards the prediction p2, because half the tour\nO→p2→p1→Ois “released” and enough time (half of its length) has passed.2It will\nkeep moving and reach position −1at time 2, sincep2’s corresponding request is unreleased\nuntil that time. Then, after reaching this unfavorable position, ALGcan only go back to\nthe origin and copy OPT. We see that|ALG|= 2 +|−1|+ 2 = 5while OPT = 2, so the\nalgorithm has competitive ratio 2.5.\nOpen variant.\nIn fact, we can also show a better than 3 robustness bound even for the open variant, where\nonly the triangle inequality is assumed. The trick is to consider another option for ﬁnishing\nup, namely to go to the last request served by OPT, sayq/lscript, and then copy OPTbackwards .\nIt is clear that this copy also takes at most |OPT|time, since there might not be a request\nat the origin. Hence, it remains to show that we can reach q/lscriptorthe origin relatively fast.\nILemma 19. LA-SWAG is/parenleftbig\n3−1\n6/parenrightbig\n-robust for open OLTSP in general metric spaces.\nProof.Note that LA-SWAG, at the ﬁnal release time tf, is onsomeshortest path from a\nprediction to the location of a request or vice versa (or from the origin to a prediction, which\nis trivial or can be thought of as a request location). Now, let pbe that prediction and qthe\nrequest with actual location x. We do not distinguish whether the movement is made from p\ntoxor vice versa. Consider the path P1, which moves from z(the position of the server at\ntimetf) topand then toO, and the path P2which moves from ztoxand then to x/lscript, the\nlocation of the last request served by OPT. Now, letdp=d(z,p)anddx=d(z,x). Since\nALGis on the shortest path from ptoxor vice versa, it holds that dp+dx=d(p,x). Note\nthat we have\nmin{|P1|,|P2|}≤|P1|+|P2|\n2=dp+dx+d(p,O) +d(x,x/lscript)\n2\n≤d(p,O) +d(x,x/lscript) +d(x,O)\n2≤|OPT|\n2+d(p,O).\n2In fact, this is the only permutation that LA-SWAG will be provided with by the oracles we deﬁne later.\nTo ensure this, we can perturb p1to the left of the origin by some arbitrarily small /epsilon1and then let /epsilon1→0.\nHence, it will deﬁnitely choose to follow this permutation.\n\n16 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\nThis means that we can ﬁnish in at most (2.5 +γ)|OPT|overall, where γ=d(p,O)\n|OPT|. Now,\nwe can apply the same idea from the proofs for the closed case. That is, let T=c·|OPT|,\nwhereTis the start time of the algorithm. We see that d(p,O)≤2c·|OPT|, otherwise the\nconditions necessary for the algorithm to start would not be satisﬁed at T. Also, a trivial\nbound for the performance is (3−c)|OPT|. Hence, on the one hand we have|ALG|\n|OPT|≤2.5+2c\nand on the other|ALG|\n|OPT|≤3−c, and these bounds hold simultaneously. Thus, overall we\nhave that|ALG|\n|OPT|≤3−1\n6by settingc=1\n6. J\nAlso, we can improve the bound when dealing with trees.\nILemma 20. LA-SWAG is(3−1/3)-robust for open OLTSP in trees.\nProof.Consider a prediction pand the location xof a request q. For simplicity, let us\nassume that pandxare vertices in the tree, otherwise we could simply add vertices at these\nlocations. Note that in this case, when moving from ptoxor vice versa, ALGﬁrst moves to\nthe lowest common ancestor of pandxand then continues along the path to its destination.\nThis means that at any point through this movement, it is on one of xorp’s paths to the\norigin. In particular, this is also true at t=tf. If it is on the path to p, then the distance to\nthe origin is at most p’s distance to the origin. If it is on the path to x, then it means that\nit is also on some point along the path that OPTwould take. Thus, it can complete the\nobjective by ﬁrst moving to either endpoint of the path and then copying it, which takes at\nmost (1 + 2c)|OPT|or3/2|OPT|time in total, depending on the previous case distinction,\nwherecis the fraction of |OPT|waited. Hence, we have the bounds 2.5,2 + 2c,3−c, and\nso we get the desired competitive ratio by considering c= 1/3. J\nThe two previous lemmata give us our main robustness theorem for the open variant.\nITheorem3 (Robustness-Open) .LA-SWAG is(3−1/6)-robust for open LA-OLTSP in general\nmetric spaces, and (3−1/3)-robust in trees.\nIRemark 21 (Tightness of Analysis for Open Variant/parenleftbig\n3−1\n3/parenrightbig\n-Robustness.). The/parenleftbig\n3−1\n3/parenrightbig\n-\nrobustness bound of LA-SWAG given in Lemma 20 is tight, even on a line. To see this, we\nplace (on the real line) a prediction at −1and the real request at 1.5, released at t= 1.5.\nNote that at time t= 0.5, our algorithm embarks on its path to the prediction. It reaches\n−1att= 1.5. This means that it cannot ﬁnish before t= 4, since it has to travel from −1\nto1.5, starting at t= 1.5. However, the optimal time is 1.5, yielding a competitive ratio of\n8/3 = 3−1/3.\nConsistency-Robustness tradeoﬀ lower bound for the open variant.\nWe conclude this section by showing a consistency-robustness tradeoﬀ lower bound for the\nopen variant.\nIProposition 22. LetALGbe an algorithm for the open variant with consistency guarantee\n2−λ, whereλ∈[0,1]. Then, ALGcannot be (2 +λ−/epsilon1)-robust, for any /epsilon1>0.\nProof.We show this on the line. We place a prediction at −1and the real request at 1,\nwhich will be released at t= 1. Since ALGis(2−λ)-consistent, it must be located at a\nposition not strictly to the right of −λatt= 1, otherwise it could not reach the prediction\nby time 2−λ, which would be a contradiction to ALG’s consistency if the prediction was\ncorrect and released at t= 1. Therefore, ALGcan only reach the real request at or later\nthant= 2 +λ, which concludes the proof since |OPT|= 1. J\n\nBampis et al. 17\nNote that the above implies that the best possible robustness for any 1.5-consistent\nalgorithm is 2.5, placing our algorithm relatively close to the underlying Pareto front.\n5 A single-exponential time algorithm for general metrics\nIn the case of perfect predictions, using SWAGand Lemma 11 we can reduce the factorial\nrunning time of the algorithm in [ 13] for general metrics. We will show that an exponential\nnumber of permutations suﬃces to have a domination oracle. After that, using the scheme\nofLA-SWAG and the theorems proved in the previous section we will get an exponential-time\nalgorithm that is 3/2-consistent, smooth and robust.\nAt each time tthere is a set R(t)of released requests and a set U(t)of unreleased requests.\nFor ease of explanation we refer to the closed case here, but the open case is similar. Consider\nan arbitrary permutation σof thenrequests at time t. A corresponding dominating tour\nfor this permutation can be constructed as follows. First, ﬁnd the ﬁrst unreleased request\nu∈U(t)in the permutation σ. The released requests before uin the permutation form a\nsubsetR/prime(t)⊆R(t)of released requests. Then, a corresponding general dominating tour\nwould be the optimal TSP path that starts from the origin, serves all requests in R/prime(t)\nand ends at request uplus the optimal TSP path that starts from u, serves all requests in/parenleftbig\nR(t)\\R/prime(t)/parenrightbig\n∪/parenleftbig\nU(t)\\{u}/parenrightbig\nand returns to the origin. We will call these tours (corresponding)\ngeneral dominating tours .\nThroughout this section, we will assume for ease of exposition that t1≤t2≤···≤tnand\nuset0= 0andtn+1=∞. At timeti, withi≤n, we compute the set of general dominating\ntoursDigiven the sets R(ti)andU(ti). Together with the previously computed sets, it is\nthen provided to SWAGas setS(ti) =/uniontexti\nj=0Dj.\nIDeﬁnition 23 (General Dominating Permutations) .Letσbe a permutation of the nrequests.\nGiven a time t, there is a set R(t)of released requests and a set U(t)(assume for now\nthatU(t)/negationslash=∅) of unreleased requests. Let u∈U(t)be the ﬁrst unreleased request in\nthe permutation σandR/prime(t)⊆R(t)be the set of released requests that precedes uin the\npermutation. A corresponding general dominating tour of σat timetconsists of:\n1.an optimal TSP path TSPO−R/prime−uthat starts from the origin, serves all requests in R/prime(t)\nand ends at request u,\n2.and an optimal TSP path TSPu−B−Othat starts from request u, serves all requests in\nB=/parenleftbig\nR(t)\\R/prime(t)/parenrightbig\n∪/parenleftbig\nU(t)\\{u}/parenrightbig\nand returns to the origin.\nNote that an optimal TSP path here is computed ignoring the release times of the requests.\nThe length /lscriptof the corresponding general dominating tour is then\n/lscript=/lscriptTSPO−R/prime−u+/lscriptTSPu−B−O.\nIfU(t) =∅, then|R(t)|=n, every request is released and we deﬁne the corresponding\ngeneral dominating tour for every σto be an optimal TSP tour that starts from the origin,\nserves all requests and returns again to the origin (the same optimal TSP tour for every σ).\nThe deﬁnition of the corresponding general dominating path of a permutation σfor\nthe open case is similar, i.e., instead of ending at the origin, a path ends at an arbitrary\nrequest from/parenleftbig\nR\\R/prime/parenrightbig\n∪/parenleftbig\nU\\{u}/parenrightbig\n, and thus we omit it. From now on we will refer to general\ndominating permutations (paths or tours).\nIProposition 24. Letσbe a permutation of the nrequests. Then, at each time t, there\nexists a corresponding general dominating permutation σ/primeofσ. Equivalently, it holds that\n/lscriptσ/prime≤/lscriptσ (12)\n\n18 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\nand\n(1−ασ/prime(t))/lscriptσ/prime≤(1−ασ(t))/lscriptσ. (13)\nProof.Since timetis ﬁxed here, the time dependence will be suppressed for convenience. At\ntimet, there is a set of released requests Rand a set of unreleased requests U(suppose for\nnow thatU/negationslash=∅). Letu∈Ube the ﬁrst unreleased request in the permutation σat timet\nandR/prime⊆Rbe the set of released requests that precedes uin the permutation. So, we know\nthat permutation σserves ﬁrst the set R/primeof requests, then the request uand after that, the\nrest of the requests (set B=/parenleftbig\nR\\R/prime/parenrightbig\n∪/parenleftbig\nU\\{u}/parenrightbig\n). So, we can write its length /lscriptσas\n/lscriptσ=/lscriptO−R/prime−u+/lscriptu−B−O.\nIt is easy to see that the value (1−ασ)/lscriptσis exactly the length of the part of the tour\nstarting with the unreleased request u, i.e.,/lscriptu−B−O. Similarly for its corresponding general\ndominating permutation σ/prime, we have that (1−ασ/prime)/lscriptσ/prime=/lscriptTSPu−B−O. It is also clear that\n/lscriptTSPO−R/prime−u≤/lscriptTSPO−R/prime−uand/lscriptTSPu−B−O≤/lscriptTSPu−B−O. Thus, we get (12) and (13).\nIfU=∅, thenσ/primeis an optimal TSP tour that serves all requests and returns to the origin\nandασ=ασ/prime= 1. Therefore, we have again that (12) and (13) hold.\nConsequently, at each time t, a general dominating permutation σ/primedominates permutation\nσ. J\nNext, we give the formal deﬁnition of a general dominating set Di.\nIDeﬁnition 25 (General dominating set) .We deﬁne the general dominating set Di, with\ni∈{0,1,2,...,n}, as the set which contains all general dominating permutations that are\ngenerated with sets R(ti),U(ti)and every possible selection of R/prime(ti)⊆R(ti)andu∈U(ti).\nFor the set Sof permutations SWAGuses each time, it holds that S(t)⊆S(t/prime)for every\nt≤t/prime, since we provide the algorithm at time tiwith the union of all Dk,k≤i≤n.\nMoreover, the general dominating set Didominates all permutations for all t<ti+1. Thus,\nwe will show that an oracle Dwhich outputs at any time t∈[ti,ti+1)the general dominating\nsets/uniontexti\nj=0Djfor eachi∈{0,1,2,...,n}, is a domination oracle. Before doing that, let us\ncompute the running time of such an algorithm. First, we show that the number of general\ndominating permutations which are contained in the set/uniontexti\nj=0Djwithi≤n, can always be\nupper bounded by 2n.\nILemma 26. There always exists a set/uniontexti\nj=0Djwhich consists of at most 2ndistinct\ngeneral dominating permutations, for all i∈{0,1,...,n}.\nProof.Consider a general dominating permutation as it is deﬁned in Deﬁnition 23. We\nonly consider the closed variant here, the proof is analogous for the open variant. Suppose\nthat we always take the permutation corresponding to the tour which consists of the\n(unique) lexicographically ﬁrst optimal TSP paths TSPO−R/prime−uandTSPu−B−O. Any such\npermutation is completely determined by the set Q/prime=R/prime(ti)∪{u}for any value of i, as\nuis the only unreleased request in Q/prime. Also, all sets Q/primeare subsets of the set of all n\nrequests, and thus there can be at most 2ndistinct ones. Note that if udoes not exist,\ni.e., all requests have been released, there exists only a single lexicographically ﬁrst optimal\nTSP tour. Consequently, we can always construct the set/uniontexti\nj=0Djconsisting of at most 2n\ndistinct (general dominating) permutations for all i∈{0,1,...,n}. J\nNext, we use Lemma 26 to show the following theorem for the running time of LA-SWAG.\n\nBampis et al. 19\nILemma 27. LA-SWAG that uses the general dominating sets runs in O(n2·2n)time\ncomplexity for both closed and open variants of OLTSP.\nProof.From Lemma 26, there are at most N= 2npermutations in the set Sthe algorithm\nuses. Att= 0, we can precompute a set Dof general dominating permutations of size at most\n2nby Lemma 26 in time O(n22n)using dynamic programming [ 15,24]. Then, every time tj\na request is released, we can select the right set Dj⊆Dof general dominating permutations\n(from all the possible general dominating permutations we have precomputed), add it to the\nprevious ones and provide them to the algorithm acting as the oracle. From Corollary 13, we\nget that LA-SWAG with the general dominating sets runs in O(n2·2n)time. J\nNow we are ready to state and prove the main theorem of this section.\nITheorem 4 (General Metrics) .LA-SWAG with an oracleDwhich uses the general dominating\nsets runs in single-exponential time and is min{3/2 + 5η,2.75}-competitive for the closed\nvariant and min{3/2 + 5η,3−1/6}-competitive for the open variant of LA-OLTSP.\nProof.If the two conditions of the domination oracle are satisﬁed for the general dominating\nsets, then we can use LA-SWAG and Lemma 11 to get an exponential time algorithm for open\nand closed LA-OLTSP that is 3/2-consistent. It is obvious that Condition 1is satisﬁed as\nS(t)⊆S(t/prime)for everyt≤t/prime. Condition 2is also satisﬁed since for each time twe have a\ncorresponding dominating permutation for every possible subset of R(t)and choice of u,\nand thus for every permutation σ. Therefore, we apply Lemma 11 and get a consistency of\n3/2. For smoothness and robustness, we use Theorems 1, 2 and 3 directly, completing the\nproof. J\n6 Polynomial/FPT time algorithms for speciﬁc metric spaces\nIn this section, we show how to build polynomial/FPT time algorithms based on the general\nframework for speciﬁc metric spaces, namely trees, rings and ﬂowers. Speciﬁcally, we show\nhow to build (in polynomial/FPT time) a dominating set of polynomial/FPT size in each\nof these cases. These will dominate a so-called sensible set of permutations in each case,\nwhich we deﬁne later. We focus now on the closed variant and explain later how to deal\nwith the open case. Also, for the sake of simplicity, we will deﬁne the “new” dominating\npermutations that will be added to the oracle’s set whenever a request is released. It is to be\nunderstood that the oracle maintains the union of all permutations generated and provides\nthat to LA-SWAG.\nWe also need to implement the “cleanup” step of LA-SWAG, where a computation of an\noptimal classical (oﬄine, without release times) TSP path/tour is required. We describe\nbrieﬂy how this is done in Subsection 6.5. Note, however, that these runtimes are small\nenough (in fact, in O(n)) so that the bottleneck will be the cardinality of the set of dominating\npermutations for the runtime of LA-SWAG.\nNow, let us start working towards the deﬁnitions and constructions promised.\nIDeﬁnition 28 (Safe Set) .LetXbe a set of request locations. A set of permutations Π\nis safe forXif for any assignment fof release times to each location in X, there exists a\npermutation π∈Πwhich is optimal for the resulting input Q={(x,f(x))|x∈X}.\nNote that the set of all permutations is safe. However, as we will see, we can deﬁne sets\nof permutations that follow some desirable structure but are still safe. We will call such sets\nsensible. It is these sets which we will dominate instead of the set of all permutations. Recall\n\n20 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\nthat LA-SWAG provides all the guarantees it does if the oracle that it uses dominates a safe\nset, which motivates this entire section.\nIn general, we will show domination by the following steps. First, we will argue that\nthe dominating permutation serves a superset of the requests served by the dominated\npermutation in no more time before reaching the ﬁrst unreleased request q(in the dominated\npermutation). Afterwards, an optimal solution that serves the rest of the requests will be\nfollowed. The above imply domination.\n6.1 Trees\nIn this section, we consider metric spaces that are shaped like a tree. That is, we have\ncontinuous spaces that can be embedded into trees with lengths on the edges, where these\nare positive (and correspond to the traversal time of the edge) and the edges incident to a\nleaf can have “inﬁnite” length. The request may appear on nodes of the tree or at some\npoint along the edges. For example, a request may appear 1 unit away from qand 2 units\naway fromp, wherepandqare nodes of the tree connected by an edge with length 3. This\ncorresponds to requests along some street between crossings in a real-world scenario. It is\nimportant that we allow the leaf edges to have inﬁnite length in order to be able to subsume\nthe line and star metrics.\nSensible set.\nFor such a metric space, we can focus on a very speciﬁc set of sensible permutations. Let us\ndescribe the idea behind the deﬁnition of these ﬁrst. Suppose that an algorithm serves a\nrequestqat timet. When the algorithm ﬁnishes, say at time tf, it will be located at the\noriginO. There is only one path PqfromqtoO, and it must be traversed after t. Hence,\nany request q/primeonPqwill be visited at some point after tanyway. Therefore, there is no\nreason for the algorithm to try and serve q/primebefore time t(i.e., before serving q), since it\nwould serve q/primeon the way back to the origin after tanyway. From this, it follows that for\nany sequence of requests Sqencountered along a path Pqtowards the origin may be safely\nassumed to be a subsequence of the optimal permutation. This motivates the following.\nIDeﬁnition 29 (Sensible Set for Trees) .LetTbe a tree rooted at the origin OandXa\nset of request locations on T. The set Πs(T,X)of sensible permutations consists of all\npermutations πwhere the following holds. Let π=xπ(1),xπ(2),...,xπ(n). For anyxπ(i)and\nanyxπ(j)on the pathPxπ(i)fromxπ(i)to the origin, we have j >i.\nBClaim 30. For any treeTand any set of request locations X, the set Πs(T,X)is safe.\nProof.Letπbe an arbitrary permutation and fan arbitrary assignment of release times\ntoX. We will show that there exists πs∈Πs(T,X)with|πs|≤|π|, where|π|denotes\nthe completion time of the tour associated to permutation πunderf. Letz(t)denote\nthe position of a server following πat timet. Letli=max{t|z(t) =xi}. Now, we sort\nthelivalues and extract the sorted indices to get πs=xπs(1),xπs(2),...,xπs(n). In other\nwords,πsis derived by the ordering of the requests based on their last visit by a server\nfollowingπ. By construction, πs∈Πs(T,X). Now, let us see why |πs|≤|π|. Lettrun\nbe the ﬁnal time that πswaits on a request location xπs(f). It is easy to see that the\nrelease time of xπs(f)is at leasttrun. This means that πstill has to perform a superpath of\nPrun=xπs(f)→xπs(f+1)···→xπs(n)→O, after time trun. Letlrundenote the length of\nPrun. It is clear that|π|≥trun+lrun=|πs|. J\n\nBampis et al. 21\nDominating set.\nFor the above sensible set, we will deﬁne a dominating set whose cardinality is of order\nO(2l·n), wherelis the number of leaves of the underlying tree. This yields an algorithm\nfor the problem in trees that runs in FPT time parameterized by the number of leaves. As\nthe reader may have already guessed, the idea is to look at subsets of leaves and, more\ninterestingly, at the paths of those leaves to the origin. That is, for each subset of the paths\nof the leaves to the origin and each selection of intermediate request q, we will deﬁne the\npermutation which ﬁrst optimally visits the selected subset of leaves ﬁnishing at qand then\n“cleans up” the rest of the requests starting from qand ending at the origin. The intuition\nexplaining why this is enough is that any sensible permutation can only have served a request\nq/primebeforeqif it already has served the leaves “below” q/prime.\nWe can now formally deﬁne the dominating permutations. To do that, we consider the\nrestriction of the tree space to the span of the requests. That is, for every leaf, if there\nis a request along its incident edge, we replace it with a new node which is the request\nfurthest along the possibly inﬁnitely long edge of the leaf and replace the inﬁnite length by\nthat request’s distance from the original leaf’s parent. Additionally, we “trim” the tree past\nrequests when there is no other request along the path to a leaf. Now, every leaf is a request.\nIDeﬁnition 31 ((q,L/prime)-Scan).LetTbe a rooted tree and Lits set of leaves. Let L/primebe a\nsubset ofLandqbe some request on the tree with location xsuch thatxis on some path to a\nleaf inL/prime(xcould be along an edge). Now, let Pbe the optimal path starting at the root and\nﬁnishing at xwhile also visiting all leaves in L/primealong the way. We call Pthe(q,L/prime)-scan of\nT.\nIDeﬁnition 32 ((q,L/prime)-Dominator) .LetR,Ube the set of released and unreleased requests\nat timet. LetL⊆Rbe the subset of released leaves and also let L/primebe a subset of those leaves.\nLetq∈Ube a furthest unreleased request along a path to some leaf. Let P/primebe the (q,L/prime)-scan\nofT. Now, let U/primebe the set of unserved requests after this scan. That is, U/prime=U∪R/prime,\nwhereR/primeis the subset of released requests not served by P/prime. Construct the tree T/primerooted at\nq, trimmed according to U/primeand preserving the origin. Let L/prime/primebe the leaves ofT/prime. LetP/prime/primebe\nthe(O,L/prime/prime)-scan ofT/prime. The implied permutation πof the tourP/primeP/prime/primeis the (q,L/prime)-dominator\nofT. We will use the notation dR,U,T(q,L/prime)to refer to it.\nIDeﬁnition 33 (Dominating Set for Trees) .LetR,Ube as in deﬁnition 32 and T,Las in\ndeﬁnition 31. The tree dominating set is:\nDomg(R,U,T,L) =/uniondisplay\nq∈U∗,L/prime⊆LdR,U,T(q,L/prime),\nwhereU∗is the set of furthest unreleased requests along the paths to leaves.\nWe will now show that this set does indeed dominate the sensible permutations for trees.\nRecall that a permutation is sensible for the tree if all sequences of requests along a single\npath from a leaf to the root (origin) ordered decreasingly by distance to the origin are found\nin the same order in the permutation.\nILemma 34 (Tree Domination) .Letπbe a permutation which is sensible for a tree T\n(trimmed according to the input requests). Let tbe the current time and R,Uthe released and\nunreleased requests at time t. Also, letLbe the set of leaves of T. ThenDomg(R,U,T,L)\ncontains a permutation πdomwhich dominates π.\n\n22 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\nProof.Letπ=qπ(1),qπ(2),...,qπ(n). Letqπ(u)be the ﬁrst unreleased request in π. Let\nRserved ={qπ(1),qπ(2),...,qπ(u−1)}be the requests served by πbeforeqπ(u). LetL/prime=\nL∩Rserved. Then, the (qπ(u),L/prime)-dominator πdom=dR,U,T(qπ(u),L/prime)∈Domg(R,U,T,L)\ndominates π. Due to the construction of πdom, speciﬁcally because an optimal path is\ncalculated for the parts before and after qπ(u), we need only show that πdomserves a superset\nof whatπserves before qπ(u)in no more time. Note that because πis sensible,Rservedmust\nbe closed under path-extension. That is, for every q∈Rservedand every pathPthatqis on,\nall requests further down the path Pthanqmust also be in Rserved. This implies that all\nrequests in Rservedare along some path to a leaf in L/prime. But,πdomtraverses all these paths\nbefore reaching qπ(u), which proves that πdomserves a superset of Rservedbeforeqπ(u). It\nremains to show that it does so at least as fast as πservesRserved. This follows because\nπdomis chosen to optimally serve L/primeonly and end up at qπ(u), whichπalso has to do anyway,\ncompleting the proof. J\nNow, using the above lemma, we obtain our main theorem for trees. The complexity\nstems from the term related to the cardinality of the dominating set in Lemma 12, since\nsolving classical TSP on trees is later shown to take O(n)time.\nITheorem 5 (Trees).There exists a Domination oracle for LA-SWAG in trees which yields a\ntime complexity of O(2l·n3)for the closed variant and O(2l·n4)for the open variant, where\nlis the number of leaves of the input tree.\n6.2 Ring\nSensible set.\nThe ring turns out to be quite similar to the line. In fact, to deﬁne the sensible permutations\nfor it, we simply need to make the following observation. If a permutation makes more\nthan one “full” loops around the ring, it can drop all but the last, since any loop will move\nthrough every request. Since it does not make sense to serve anything before doing a full\nloop, the loop can be the ﬁrst movement after leaving O. After such a loop, if it even exists,\nwe can assume that the permutation moves along the ring as if it were a line, i.e., it never\ncrosses the antipodal point of the origin. Hence, we can deﬁne the sensible permutations by\nbranching on whether a loop is performed and then reduce to the tree case.\nIDeﬁnition 35 (Sensible Set for the Ring) .LetXbe a set of request locations on the ring.\nThe sensible set of permutations Π◦\ns(X)consists of all permutations πresulting from the\nconcatenation of πloopandπlinewhereπloopis a subpermutation covering X/prime⊆Xin a cyclic\nfashion and πline∈Πs(T,X\\X/prime), whereTis the tree resulting from splitting the ring at the\nmidpoint across from the origin.\nBClaim 36. There is always an optimal solution which follows a sensible permutation.\nProof.We can assume that the ring is a circle with a circumference of 1. Let us now consider\nan optimal solution OPT, and denote by σ∗the order in which OPTserves the requests (a\npermutation of the requests). We recall that w.l.o.g. OPTfollows the tour/path σ∗, waiting\nonly at requests’ positions: it goes from Oto (the position of) σ∗[1])in timed(O,σ∗[1]),\nwaits at (the position of) σ∗[1]if the request is not released, then from σ∗[1]toσ∗[2]in time\nd(σ∗[1],σ∗[2]), ...We will then prove that for every optimal solution OPT, there is another\noptimal solution OPT/primethat is a sensible permutation.\nConsider the last time OPTmoves from the one semicircle \\OAO/primeto the other one\\OBO/prime\n(or vice versa) through the antipodal point O/primeof the origin (Figure 3). If OPTdoesn’t cross\n\nBampis et al. 23\nOAσ∗[il]O/prime\nσ∗[il+ 1]\nB\nFigure 3 Ring for the proof of Claim 36.\nO/primein any moment, then OPT/primecan just follow OPTwhich has a zig-zag motion and is a\nsensible permutation. Otherwise, there is a pair of consecutive requests σ∗[il],σ∗[il+1]in the\npermutation between which the crossing of O/primeoccurs. Assume w.l.o.g. that σ∗[il]∈\\OAO/prime\nandσ∗[il+1]∈\\OBO/prime. Then, OPThas to move from σ∗[il+1]to the origin without crossing\nO/primeagain. Let t∗be the ﬁrst time that OPTreaches the origin after serving the request at\nσ∗[il+ 1]. Instead of following OPT,OPT/primecan wait in the origin for time t∗−1and then\nmake a full circle \\OAO/primeBOwithout stopping anywhere. In this case, it reaches Oat time\nt∗(the same as OPT) serving at least the requests OPThas served until that time. Next,\nOPT/primejust follows OPTwhich has a zig-zag motion since it never crosses O/primeagain. Therefore,\nOPT/primeis a sensible permutation and |OPT/prime|≤|OPT|.\nJ\nDominating set.\nAs we have discussed, a sensible permutation for the ring can have at most one full loop in\nthe beginning. Note that if this loop is missing, the case degenerates to the line, for which\nwe have already deﬁned the dominators. Therefore, it only remains to deﬁne the dominators\nunder the assumption that πdoes indeed have a loop in the beginning, since then we can\njust take the union of the two sets to construct the set of all dominators.\nA crucial distinction is whether the current request qofπis part of the loop or not. In\nthe ﬁrst case, πhas only traveled a portion of the loop so far and in the second case it has\ntraveled a full loop and then taken some possibly complex line-like tour. For every choice of\nq, we deﬁne two permutations, one pertaining to the ﬁrst case and another to the second one.\nThe ﬁrst permutation serves all released requests within π’s traveled portion of the loop\n(in the same direction) and then moves to q. From there, it follows an optimal permutation\nserving the rest of the requests (disregarding release times), which can easily be computed for\nthe ring. The second permutation serves all released requests with a full loop (in clockwise\norder ifqis to the left arc of the ring and vice versa) and then moves to q. It ﬁnishes in\nthe same way by computing an optimal path from qto the origin. We now deﬁne this set of\ndominating permutations more formally.\nIDeﬁnition 37 (Crescent Permutations) .LetRbe a set of released requests and Ube the\ncorresponding set of unreleased requests on the ring at time t. Letr1,...,rmbe the released\nrequests in clockwise order from the origin. For every q∈U, theleft-crescent permutation\n\n24 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\nofqis\n(r1,...,rl)||(q)||optq((R∪U)\\{r1,...,rl}),\nwherelis the largest index such that rlis to the left of qin clockwise order from the origin\nandopts(S)denotes the fastest path without release times that starts from s, visits every point\ninSand ends at the origin. The right-crescent permutation ofqis deﬁned analogously.\nWe will use lcR,U(q)andrcR,U(q), respectively, to refer to these permutations.\nIDeﬁnition 38 (Full-Moon Permutation) .LetR,Ube as in Deﬁnition 37 and q∈U. Ifqis\non the left arc of the ring, i.e., it is encountered before the antipodal point of the origin in a\nclockwise traversal of the ring, then the full-moon permutation of qis\n(r1,...,rm)||(q)||optq(U).\nIfqis on the other arc, the order of serving the released requests is reversed. We will use\nfmR,U(q)to refer to this permutation.\nIDeﬁnition 39 (Dominating Set for the Ring) .For givenR,Uas in Deﬁnitions 37 and 38,\nthe ring dominating set of R,Uis\nDom◦(R,U) =/uniondisplay\nq∈U{rcR,U(q),lcR,U(q),fmR,U(q)}.\nNow that we have deﬁned the dominators, it remains to show that indeed they dominate\nthe sensible set of permutations which contain a loop.\nILemma 40 (Ring Domination) .Letπbe a sensible permutation whose tour contains a full\nloop in the beginning. Let tbe the current time and R,Uthe released and unreleased requests\nat timet. Then,Dom◦(R,U)contains a permutation πdomwhich dominates π.\nProof.Letπ=q1,q2,...,qn. Assume without loss of generality that π’s loop is clockwise.\nAlso, letqx∈Ube the ﬁrst unreleased request in πat timet. We distinguish two cases:\nThe request qxis on the loop part of π. Then,lcR,U(qx)∈Dom◦(R,U)is a dominator\nforπ. This is because both permutations travel the same distance to qx(the clockwise arc\nto it) andlcR,U(qx)serves a superset (all released request in that arc) of what πserves\n(some released requests of that arc) until this point. Also, after reaching qx,lcR,U(qx)\noptimally serves a subset of what πhas to serve, and is thus faster on that part too,\nwhich means that it dominates π.\nThe request qxis after the loop part of π. Then,fmR,U(qx)∈Dom◦(R,U)is a dominator\nforπ. This can be seen because fmR,U(qx)serves all released requests in its loop part\nand moves to qxafter the loop at the least possible time (with cost 1 for the loop and\nthen the smallest arc to qx). Thus, it serves a superset of what πserves until reaching qx\nin no more time than the tour induced by πneeds. Then, it optimally serves a subset of\nwhatπhas to serve, and is thus faster on that part too, which means that it dominates π.\nJ\nThus, our main theorem for the ring follows.\nITheorem 6 (Ring).There exists a Domination oracle for LA-SWAG in the ring which yields\na time complexity of O(n3)for the closed variant and O(n5)for the open variant.\n\nBampis et al. 25\n6.3 Flowers\nFigure4\nA ﬂower with\n7 petalsIn this section we extend the reasoning used in the previous subsections on\nrings and trees to the so-called ﬂowers. A ﬂower consists of a number of\nrings (petals), all of which are attached to the origin point (receptacle). For\nreasons of artistic completion, a semiline (stem) disjoint from the petals is\nalso attached to the origin point3. An illustration is given in Figure 4. In\nthe following, we deﬁne the sets of sensible and dominating permutations for\nthese kinds of graphs.\nSensible set.\nThe central idea is the following. We can assume that any sensible solution\ntraverses a petal of the ﬂower in a cyclic fashion at most once, for the same\nreason that this is true for the ring. Moreover, the petal is not visited before\nwithout loss of generality. After such a traversal (if it ever occurs), we can safely “snip” the\npetal in its halfpoint from the origin and view it as two diﬀerent branches of a tree, since\nthe halfpoint will never be crossed again. Thus, the sensible set here is deﬁned to include\nthe permutations which have at most one loop for each petal, such loops are the ﬁrst visit\non the corresponding petal (but may be carried out fully during any contiguous part of the\npermutation) and the restrictions of the sensible set on trees also apply to every petal (which\nbecomes a line) after such a loop (if it even exists) is carried out.\nDominating set.\nUtilizing this observation, we can construct the dominating permutations as follows. First,\nchoose an unreleased request q. This will be the “current” request of the sensible permutation\nfor which we want to deﬁne the dominator. Let πrefer to that permutation. Note that π,\nthroughout its entirety, will utilize a subset of the petals in a cyclic fashion. So, we “guess”\nthis subset and call it P. Moreover, a subset PdoneofPwill have been fully traversed before\nreachingq. We also guessPdone. This also deﬁnes Pleft=P\\Pdone. Then, the dominator\nis deﬁned in the following way. First, we traverse all petals in Pdonein an arbitrary order.\nNext, we “snip” every petal except the ones in P. This leaves us with a tree T(actually, a\nstar) and the petals in P, which are disjoint from each other. Note that this is safe to do if\nwe correctly guessed the sets of petals, since πwill behave as if it is on a tree when visiting\nthe petals not in P.\nNow, we also guess the subset L/primeof the leaves LofTto be visited before q. Having ﬁxed\nthat, we append to our initial petal loop subtour the optimal path from Otoqthat visits\nevery leaf in L/prime, and also possibly serves the arc that πmight have served if it is currently\nperforming a loop on q’s petal. Finally, we append the optimal path from qthat “cleans up”\nthe remaining unserved requests.\nNote that to make all these diﬀerent guesses, one has at most six choices for every petal\n(loop done, loop later, or any of the 4 choices of subsets of the two leaves after snipping).\nSo, if the graph has ppetals, the cardinality of the dominators is O(6p·n) =O(22.59p·n).\nThe above calculation considers the stem as a petal for simplicity. Again, this yields an FPT\nalgorithm for the ﬂower case.\n3In fact, one could do the same for graphs which are trees plus some edge-disjoint cycles attached to a\nsingle vertex of the tree. Thus, one can even include the ﬂower’s (ground) roots.\n\n26 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\nHere we give a proof sketch of why this works. Recall that we only need to show that any\nsensible permutation πis dominated at all times by some dominator πdomout of the above.\nSo, forπat timet, we claim that πdomwhich corresponds to the correct guess of q,P,Pdone\nandL/primedominatesπ. Let us ﬁrst focus on the petals of Pdone. It is clear that πdomserves all\nreleased requests in these petals in the least time necessary to traverse the petals in loops,\nan amount of time which πalso pays by the correct guess of Pdone. Now, we shift our focus\ninto the part of πdomafter the initial loops and until reaching q. By construction, it is the\noptimal path visiting L/primeand any possible requests that πmight have served if currently\non a loop traversal of q’s petal. But, by a similar reasoning as in the trees subsection (the\npath-extension property of the served requests of π),πalso has to accomplish this task,\nindependently of visiting Pdonein loops. This independence is because L/primehas no leaves in\npetals ofPdone, since all released requests there are served in the initial loops of πdomand\nalso because in the case that qis part of a loop, its petal is not in Pdone. Moreover, πdom\nserves all requests that πhas served until reaching q, since each request that πhas served is\neither in a petal of Pdone, along a path to a leaf in L/prime, or along the (correctly chosen) arc to\nq. Hence,πdomserves a superset of what πserves and reaches qat least as fast. Domination\nnow follows by the optimality of the “cleanup” path.\nWe will now make the above more formal by precisely deﬁning the dominators and proving\nthat they dominate the sensible set of permutations.\nIDeﬁnition 41 (Hippie Permutations) .LetR,Ube the sets of released requests and unreleased\nrequests at time t. Letq∈Ube an unreleased “current” request. Let Pbe a subset of the\npetals of the input ﬂower metric space. Let Pdone⊆P. For now, let us assume that qis not\non a petal ofP. LetTbe the tree obtained by replacing the petals not inPby two “branches”\neach with half the length of the original petal (snip the petal at its halfpoint). Tpossibly also\ncontains the stem of the ﬂower. Finally, let Lbe the leaves ofT(trimmed according to the\nreleased requests) and L/prime⊆L. The hippie permutations hpR,U(q,P,Pdone,L/prime)are deﬁned as\nfollows:\nFirst, all released requests in the petals of Pdoneare served by looping through each petal\nonce in an arbitrary way, e.g. clockwise and by prioritizing the petals according to some\nﬁxed ordering.\nThen, an optimal path is calculated which visits each leaf in L/primeand ends up at q. We\nappend this path (more accurately, the subpermutation associated to it) to the permutation.\nFinally, the optimal path which starts at qand visits any unserved until now request\nbefore ﬁnishing at the origin is calculated and appended.\nIn the case that qis in a petal ofP, we slightly modify the above deﬁnition by requiring that\nin the second part, not only leaves in L/primeare visited but also all requests along a petal arc to q.\nWe deﬁne two such permutations, one for each arc leading to q. Thus,hpR,U(q,P,Pdone,L/prime)\nwill refer to the set of permutations generated in the above way (one or two permutations\nactually).\nIDeﬁnition 42 (Dominating Set for Flowers) .Let us reuse the notation of Deﬁnition 41. We\nwill describe now how the dominating set for ﬂowers is generated. We simply take the union\nof the hippie permutations for all (valid) choices of P,Pdone,q,L/prime. That is, we deﬁne the set:\nDomP(R,U) =/uniondisplay\nq∈U\nPis a subset of petals ,\nPdone⊆P,\nL/primeis a subset of the leaves of ThpR,U(q,P,Pdone,L/prime)\n\nBampis et al. 27\nFinally, we can now show that the above set dominates the set of sensible permutations\nfor the ﬂower.\nILemma 43 (Flower Domination) .Letπbe a sensible permutation for the ﬂower and let R,U\nbe the released and unreleased requests at time t. Then,DomP(R,U)contains a permutation\nπdomwhich dominates π.\nProof.Letqbe the ﬁrst unreleased request in πat timet. Also, letPbe the set of petals\nthatπwill loop through (or have already done so) at some point. Let Pdone⊆Pbe the\nsubset of those which have already seen their loop completed before reaching q. LetTbe\nas in Deﬁnition 41. Let L/primebe the subset of leaves that πvisits before q. We claim that\nhpR,U(q,P,Pdone,L/prime)contains the permutation πdomwe are looking for.\nLet us assume for now that qis not on a petal of P. Then,hpR,U(q,P,Pdone,L/prime)is the\nsingleton{πdom}. To see why, note that we can split the “movement” of πdomup toq\ninto two independent parts, one for the initial loops and one for the rest. The ﬁrst part\ncosts as much as the total length of the petals in Pdone, whichπalso has to pay since\nit has fully looped through these petals at some point before reaching q. Now, notice\nthat none of the leaves of L/primeare in petals ofPdone, by construction. Therefore, πdom\noptimally visits these leaves and πalso has to additionally pay at least this cost (on top\nof and independently of the cost associated with the loops of Pdone), before reaching q.\nTherefore, we have shown that πdomfollows a not longer path until q. It only remains\nto show that with that path it serves every request that πhas served until q. For the\nloop petals, this is obvious, since πdomserves every released request there. Then, for\nall requests outside of P, we can view the problem as if we are on a tree. Thus, the\narguments of the tree subsection apply (closure under path-extension etc.). It remains\nto show that there is no request in Pleftwhichπhas served but πdomhas not. This is\ntrivial, since there is no such request because of the assumption that qis not on a petal\nofPleft.\nNow we can resolve the case where qis on a loop petal. This means that πis currently\nundergoing a loop. We choose πdomto be the permutation following the corresponding\narc toq. The fact that πdompays a not higher cost until reaching qcan be established in\nmuch the same way (we split the costs into the ﬁrst loops and then Tplus the ﬁnal arc).\nThe only extra thing we need to show is that πdomserves every request in Pleftthatπ\ndoes untilq. But these are just the requests in the correctly chosen arc to q, and thus\nthe claim follows.\nJ\nAgain, the lemma above establishes our main theorem for ﬂowers. As for the trees, the\ncomplexity comes from the term related to the cardinality of the dominating set in Lemma\n12, since solving classical TSP on ﬂowers is later shown to take O(n)time.\nITheorem 7 (Flowers).There exists a Domination oracle for LA-SWAG in ﬂowers which\nyields a time complexity of O(6p·n3)for the closed variant and O(6p·n5)for the open\nvariant, where pis the number of petals of the input ﬂower.\n6.4 Dealing with the open variant\nMuch of the above analysis was based on exploiting the closed nature of the problem,\nspeciﬁcally the fact that OPTis required to return to O. This is no longer true in the open\ncase. However, we can artiﬁcially impose a similar restriction by enumerating all possible\n\n28 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\nendpoints of OPT’s path. That is, we will assume that a speciﬁc request qfwill be served\nlast by OPTand build the dominating permutations under this assumption. In the end,\nwe consider the union of all these sets (i.e., for all choices of the ﬁnal request), which will\ndominate the sensible sets for the open case, since any sensible permutation has to ﬁnish\nwithsomerequest.\nTrees.\nFor the case of trees, this turns out to be quite simple. Once we ﬁx qf, we simply need to\nreroot the tree at qf. Then, all sensible permutations which terminate at qfmust respect the\norder of requests along paths to leaves of the rerooted tree; a simpliﬁcation very similar to\nthe one we had for the closed case. Hence, we can build the set of dominating permutations\nby considering the union of tree dominators for all nrerootings of the input tree. Note that\nrerooting cannot increase the number of leaves by more than 1. The cases where this happens\noccur only when the new root is actually along an edge, and then we have to split that edge\ninto two. This set dominates the sensible set of permutations for the open case in trees and\nhas sizeO(2l·n2), yielding an FPT algorithm once again.\nRing.\nFor the case of the ring, we take a diﬀerent approach altogether compared to the closed\nvariant. Instead of specifying the sensible set and then dominating it, we simply dominate\nthe set of all permutations with a relatively simple case distinction.\nThe ﬁrst easy case is when the permutation πto be dominated has not crossed the point\nO/prime, the antipodal point of the origin before reaching the current request q. In such a\nscenario, we view the ring as a line and the already deﬁned dominators for trees suﬃce.\nThe correspondence here would be that a permutation πis dominated by the dominator\nπdomwhich visits the same set of extreme requests (leftmost or rightmost) as πbeforeq.\nNow, let us assume that πhas indeed crossed the point O/primebefore reaching x, the location\nofq. Let us be rid of the case where πhas moved a distance of at least 1 +d(x,O)before\nreaching request q, as then the permutation that serves all released requests with a loop\nand then goes to xas soon as possible dominates π. Let us assume w.l.o.g. that between\nthe last touch ofOand the ﬁrst subsequent touch of O/prime,πmoves through the right arc.\nNow, let us focus on the left arc. Let q1be the request closest to O/primeon the left arc\nthatπhas served before its last visit of O. Letq2be the request closest to Oon the\nleft arc that πhas served after the last visit of Oand before leaving q(it could happen\nthatq2=q). Byx1andx2, we denote their location, respectively. Because these points\nhave to be traveled while moving a distance not more than 1 +d(x,O), we deduce that\nd(x1,O)< d(x2,O). Note that no request in the left arc of (x1,x2)could have been\nserved byπbefore request q.\nFor suchπ, we deﬁne the following dominator. First, πdommoves tox1and serves all\nrequests on the way back to the origin. Then, it serves all requests along the right arc to\nO/prime, in that order. After reaching O/prime, it continues moving towards x2, serving all requests\non the way along the left arc. Finally, it moves to x, after which point it optimally cleans\nup the still unserved requests. We see that πdomserves all requests outside the left arc of\n(x1,x2), i.e., it serves a superset of what πserves, before serving q. Also, the movements\nofπdomcan be charged independently to movements of π, and so the distance traveled is\nnot higher, which implies domination.\n\nBampis et al. 29\nThe majority of the above dominators are of the ﬁnal type where we have to choose q,q1\nandq2(we do not need to choose qfas in the case of trees). Hence, there are O(n3)\ndominators, which yields a polynomial time algorithm.\nFlowers.\nFor non-trivial ﬂowers (i.e., not just a single ring), the situation is a bit more complex, but\nwe can still retrieve an FPT algorithm. Note that the ﬁnal request qfwill either lie on a\npetal or not. If not, the argument that allpetals may be traversed in a cyclic fashion at\nmost once (and not visited at all before such a loop) still holds. Thus, simply rerooting the\ntree and guessing the parameters of the closed variant ﬂower dominators for the modiﬁed\ntree (but afterwards appending the optimal solution to the open variant) still works.\nNow, ifqfhappens to lie on a petal, we have some extra work to do. Note however that\nin this case, any path from a request qtoqfwhereqisnoton the same petal as qfmust\npass through the origin. Thus, we can still assume that the sensible permutations respect\nthe order of requests along paths to leaves of the (possibly snipped) tree rooted at the origin,\nat least as far as requests not on the ﬁnal petal are concerned. We do not reroot the tree in\nsuch cases. Plus, all non-ﬁnal petals may be traversed cyclically at most once. We thus only\nhave to deal with the requests on the same petal as qf. Fortunately, these can be dealt with\nrelatively simply, essentially by viewing the ﬁnal petal as a single ring in the open variant.\nSuppose the “current” request qis not on the ﬁnal petal. Then, we can deal with the\nﬁnal petal with either a loop or snipping it and guessing the leaves, as we would originally\ndo. This is because before reaching q,πwill have either visited the ﬁnal petal’s midpoint\nor not. In the ﬁrst case, it must have made a full loop, since qis not on that petal. In the\nother, we view the ﬁnal petal as a tree.\nThe remaining case is the interesting one, where both qandqfare on a single petal. In\nsuch a case, we ﬁrst guess the otherpetals and tree leaves and serve them optimally in a\nclosed manner, i.e., we return to the origin. Now, we ignore everything but the petal of q\nandqfand append a ring-type dominator for that speciﬁc petal.\nOverall, we get a dominating set whose cardinality is O(n3·6p) =O(n3·22.59p), wherepis\nthe number of petals of the ﬂower. This is because we have roughly a quadratic multiplicative\nfactor more dominators over the closed case, since we additionally choose eitherqforq1and\nq2. The ﬁrst case corresponds to when qfis on the tree part (in which case we do not need\nto chooseq1andq2) and in the second case the choices of q1andq2imply the choice of petal\non whichqfis, which is all we need to know to deﬁne the ring-type dominator we append.\n6.5 Solving classical TSP fast\nHere we describe how we compute an optimal classical TSP solution within suitable runtime\nbounds. This is used in the “cleanup” step of Algorithm 2, but also in the deﬁnition of the\ndominating permutations.\nFor trees, we can simply perform a DFS traversal (from the startpoint) while deprioritizing\nthe edges that lead to q, whereqis the endpoint of the optimal path we would like to calculate.\nThe corresponding path traced by the DFS is optimal with cost twice the sum of edge lengths\nminus the length of q’s path to the startpoint. Note that for our intents and purposes, we\ncan assume that DFS runs in O(n)time, where nis the number of requests. To see this,\nwe need to show that we can bound the size of the actual tree by a constant multiple of\nn, since then the complexity of DFS boils down to O(n). As a ﬁrst preprocessing step and\nonly once, we do the following. We trim the tree so that only the paths from the requests\n\n30 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\nto the root (can be any point, might as well be the origin) are retained. This means that\nwe havel≤n, wherelis the number of leaves of the modiﬁed tree. Moreover, we assume\nthat there exists no vertex of the tree with degree exactly 2 (except possibly the origin),\nas these are non-essential for the OLTSP problem (one can view the two incident edges as\none). Now, notice that any vertex of the tree has degree at least 3, except for the leaves.\nLetibe the number of non-leaf vertices of the tree. By the handshaking lemma, we have\n2e=/summationtext\nvdeg(v)≥3i+l=⇒i≤l, whereeis the number of edges of the tree and by\nrecalling that e=i+l−1. Hence, the tree does indeed have size O(n), which shows that we\ncan solve classical TSP in O(n)time.\nFor ﬂowers (which subsume the ring), we ﬁrst conclude which petals are better traversed\nas a cycle or as two diﬀerent branches. This is easy to decide by comparing the cost of the\nfull cycle versus a zig-zag type traversal that visits all requests. Afterwards, we run a DFS\non the part of the ﬂower that is decided to be traversed as a tree and append the petal cycles\nat any part of said DFS traversal where the origin is touched. The case where no such part\nexists is degenerate and easily dealt with (just the semiline is traversed by the DFS). It is\neasy to see that this whole procedure runs in O(n)time as well, provided we have discarded\npetals empty from requests as a preprocessing step.\nWe note that these overheads do not matter asymptotically for LA-SWAG, since the\nbottleneck of the runtime already comes from the cardinality of the dominating sets times\nn2, whereas for the computation of the dominating permutations we only pay O(n)for each\nand there are up to n+ 1calls to the domination oracle overall.\n7 Conclusion\nWe studied Online TSP augmented with predictions regarding the locations of the requests.\nOur algorithm, LA-SWAG, achieves a competitive ratio of 3/2under the assumption of perfect\npredictions, which is tight in most cases we considered. Additionally, it is smooth and\nprovides robustness guarantees below 3, improving over previous work. The runtime of\nLA-SWAG is single-exponential; however, we show how to remove the exponential dependency\non the number of requests for speciﬁc metric spaces.\nWe believe that our techniques can be generalized to obtain FPT algorithms for other\nclasses of graphs also; cactus graphs, graphs of bounded treewidth in general, as well as planar\ngraphs are interesting options. Additionally, extending the algorithm to the Dial-A-Ride\nProblem seems like a reasonable direction to follow. Finally, having slightly improved the\nconsistency lower bound in the line open variant, we conjecture that it is possible to extend\nour construction and establish tightness in this case also; we suggest this as future work.\nAnother interesting direction is to leverage the ideas behind the PTAS for classical TSP\non the Euclidean plane [ 6,7] (or any other space which admits an approximation scheme for\nthat matter) to obtain consistency guarantees which approach 3/2 arbitrarily close as the\ncomputational time is allowed to increase. Note that, since our smoothness proof follows\nfrom consistency itself and robustness from solving a classical TSP instance, these results\nwould automatically extend, modulo some worsening of the bounds as a function of the\napproximation quality. For this, one possible approach is to extend the notion of a sensible\nset to that of /epsilon1-sensible, meaning that a (1 +/epsilon1)-approximation of the optimal Online TSP\nsolution is guaranteed to exist within the set. A similar relaxation would also make sense for\nthe idea of dominating sets.\n\nBampis et al. 31\nReferences\n1Luca Allulli, Giorgio Ausiello, and Luigi Laura. On the power of lookahead in on-line vehicle\nrouting problems. In COCOON , 2005.\n2Spyros Angelopoulos, Christoph Dürr, Shendan Jin, Shahin Kamali, and Marc P. Renault.\nOnline computation with untrusted advice. In ITCS, 2020.\n3Antonios Antoniadis, Christian Coester, Marek Eliás, Adam Polak, and Bertrand Simon.\nOnline metric algorithms with untrusted predictions. In ICML, 2020.\n4AntoniosAntoniadis, PeymanJabbarzadeGanje, andGolnooshShahkarami. Anovelprediction\nsetup for online speed-scaling. CoRR abs/2112.03082 , 2021.\n5Antonios Antoniadis, Themis Gouleakis, Pieter Kleer, and Pavel Kolev. Secretary and online\nmatching problems with machine learned advice. In NeurIPS , 2020.\n6Sanjeev Arora. Polynomial time approximation schemes for euclidean TSP and other geometric\nproblems. In FOCS, 1996.\n7Sanjeev Arora. Nearly linear time approximation schemes for euclidean TSP and other\ngeometric problems. In FOCS, 1997.\n8Norbert Ascheuer, Martin Grötschel, Sven O. Krumke, and Jörg Rambau. Combinatorial online\noptimization. In Peter Kall and Hans-Jakob Lüthi, editors, Operations Research Proceedings\n1998, pages 21–37, Berlin, Heidelberg, 1999. Springer Berlin Heidelberg.\n9Giorgio Ausiello, Marc Demange, Luigi Laura, and Vangelis Paschos. Algorithms for the\non-line quota traveling salesman problem. Inf. Process. Lett. , 92(2):89–94, 2004.\n10Giorgio Ausiello, Esteban Feuerstein, Stefano Leonardi, Leen Stougie, and Maurizio Talamo.\nAlgorithms for the on-line travelling salesman. Algorithmica , 29:560–581, 2001.\n11Étienne Bamas, Andreas Maggiori, Lars Rohwedder, and Ola Svensson. Learning augmented\nenergy minimization via speed scaling. In NeurIPS , 2020.\n12Étienne Bamas, Andreas Maggiori, and Ola Svensson. The primal-dual method for learning\naugmented algorithms. In NeurIPS , 2020.\n13Evripidis Bampis, Bruno Escoﬃer, Niklas Hahn, and Michalis Xefteris. Online TSP with\nKnown Locations. To appear in WADS , 2023. CoRR abs/2210.14722.\n14Evripidis Bampis, Bruno Escoﬃer, and Michalis Xefteris. Canadian traveller problem with pre-\ndictions. In Parinya Chalermsook and Bundit Laekhanukit, editors, Approximation and Online\nAlgorithms , pages 116–133, Cham, 2022. Springer International Publishing.\n15Richard Bellman. Dynamic programming treatment of the travelling salesman problem. J.\nACM, 9(1):61–63, Jan 1962.\n16Giulia Bernardini, Alexander Lindermayr, Alberto Marchetti-Spaccamela, Nicole Megow, Leen\nStougie, and Michelle Sweering. A universal error measure for input predictions applied to\nonline graph problems. In NeurIPS , 2022.\n17Antje Bjelde, Jan Hackfeld, Yann Disser, Christoph Hansknecht, Maarten Lipmann, Julie\nMeißner, Miriam Schlöter, Kevin Schewior, and Leen Stougie. Tight bounds for online TSP\non the line. ACM Trans. Algorithms , 17(1):3:1–3:58, 2021.\n18Michiel Blom, Sven O. Krumke, Willem E. De Paepe, and Leen Stougie. The online TSP\nagainst fair adversaries. INFORMS J. Comput. , 13(2):138–148, 2001.\n19Shuchi Chawla and Dimitris Christou. Online time-windows TSP with predictions. CoRR,\nabs/2304.01958, 2023. arXiv:2304.01958 ,doi:10.48550/arXiv.2304.01958 .\n20Paul Dütting, Silvio Lattanzi, Renato Paes Leme, and Sergei Vassilvitskii. Secretaries with\nadvice. In EC, 2021.\n21Franziska Eberle, Alexander Lindermayr, Nicole Megow, Lukas Nölke, and Jens Schlöter.\nRobustiﬁcation of online graph exploration methods. Proceedings of the AAAI Conference on\nArtiﬁcial Intelligence , 36(9):9732–9740, Jun. 2022.\n22Sreenivas Gollapudi and Debmalya Panigrahi. Online algorithms for rent-or-buy with expert\nadvice. In ICML, 2019.\n23Themis Gouleakis, Konstantinos Lakis, and Golnoosh Shahkarami. Learning-Augmented\nAlgorithms for Online TSP on the Line. To appear in AAAI , 2023. CoRR abs/2206.00655.\n\n32 Learning-Augmented Online TSP on Rings, Trees, Flowers and Everywhere Else\n24Michael Held and Richard M. Karp. A dynamic programming approach to sequencing problems.\nJ. Soc. Indust. Appl. Math. , 10(1):196–210, 1962.\n25Hsiao-Yu Hu, Hao-Ting Wei, Meng-Hsi Li, Kai-Min Chung, and Chung-Shou Liao. Online\nTSP with predictions. CoRR, abs/2206.15364, 2022.\n26PatrickJailletandMichaelR.Wagner. Onlineroutingproblems: Valueofadvancedinformation\nas improved competitive ratios. Transportation Science , 40:200–210, 05 2006.\n27Vinay A. Jawgal, V. N. Muralidhara, and P. S. Srinivasan. Online travelling salesman problem\non a circle. In T.V. Gopal and Junzo Watada, editors, Theory and Applications of Models of\nComputation , pages 325–336, Cham, 2019. Springer International Publishing.\n28Murali Kodialam and T. V. Lakshman. Prediction augmented segment routing. In 2021 IEEE\n22nd International Conference on High Performance Switching and Routing (HPSR) , pages\n1–6, 2021.\n29Tim Kraska, Alex Beutel, Ed H. Chi, Jeﬀrey Dean, and Neoklis Polyzotis. The case for learned\nindex structures. In SIGMOD , 2018.\n30Eugene L. Lawler, Jan K. Lenstra, Alexander H. G. Rinnooy Kan, and David B. Shmoys. The\nTraveling Salesman Problem: A Guided Tour of Combinatorial Optimization . Wiley Series in\nDiscrete Mathematics & Optimization, 1991.\n31Alexander Lindermayr and Nicole Megow. Alps. https://algorithms-with-predictions.\ngithub.io/ .\n32Thodoris Lykouris and Sergei Vassilvitskii. Competitive caching with machine learned advice.\nJ. ACM, 68(4):24:1–24:25, 2021.\n33Michael Mitzenmacher. A model for learned bloom ﬁlters and optimizing by sandwiching. In\nNeurIPS , 2018.\n34Michael Mitzenmacher. Scheduling with predictions and the price of misprediction. In ITCS,\n2020.\n35Michael Mitzenmacher and Sergei Vassilvitskii. Algorithms with predictions. In Beyond the\nWorst-Case Analysis of Algorithms . Cambridge University Press, 2020.\n36Benjamin Moseley, Sergei Vassilvitskii, Silvio Lattanzi, and Thomas Lavastida. Online\nscheduling via learned weights. In SODA, 2020.\n37Harilaos N. Psaraftis, Marius M. Solomon, Thomas L. Magnanti, and Tai-Up Kim. Routing\nand scheduling on a shoreline with release times. Manag. Sci. , 36(2):212–223, 1990.\n38Manish Purohit, Zoya Svitkina, and Ravi Kumar. Improving online algorithms via ml\npredictions. In NeurIPS , 2018.\n39Dhruv Rohatgi. Near-optimal bounds for online caching with machine learned advice. In\nSODA, 2020.\n40Shufan Wang and Jian Li. Online algorithms for multi-shop ski rental with machine learned\npredictions. In AAMAS, 2020.\n41AlexanderWei. Betterandsimplerlearning-augmentedonlinecaching. In APPROX/RANDOM ,\n2020.\n\nBampis et al. 33\nA Consistency lower bound on the line for the open case\nIProposition 44. No algorithm can have a better consistency than1+√\n61\n6for open LA-\nOLTSP on the line.\nProof.Letλ=1+√\n61\n6≈1.468, which satisﬁes λ=5\n3λ−1.\nLetA,O,Bbe the points on the line with coordinates xA=−1,xO= 0andxB= 1.\nWe consider that we have a continuous set of requests between AandB(this can be easily\ndiscretized to get the same asymptotic lower bound with a ﬁnite number of request). None\nare released until t= 1. Let also denote δ= 5−3λ(note thatδis slightly larger than 0.5).\nWe consider two cases at t= 1. Letsdenote the position of the algorithm at t= 1. We\nassume w.l.o.g. that s≥0.\nIfs≥1−δ, then we release all the requests at unit speed, starting at Aatt= 1tillBat\nt= 3. Then|OPT|= 3. If the algorithm serves BbeforeA, it needs at least 5. If it serves A\nbeforeB, it needs at least 1 + (1−δ) + 1 + 2 = 3 λ. Hence, the competitive ratio is at least λ.\nOtherwise, 0≤s<1−δ. Then we release the requests from Aand fromBat unit speed,\nuntil the ﬁrst time t0such that the algorithm is at some position s/primewith|s/prime|= (2−t0)−δ,\ni.e., the server is at distance δfrom the “released part” of the requests. We distinguish two\ncases, depending on t0. We assume w.l.o.g. that s/prime≥0att0, sos/prime= (2−t0)−δ. LetCand\nDbe the points at positions xC=−(2−t0)andxD= 2−t0, respectively (i.e., at t0the\nrequests are released on [A,C]and on [D,B ]).\nIft0≥3λ−3(intuitively slightly less than half of the requests are released, and\nALGis close toO), then we release the requests from CtoDat unit speed, starting\natt0. Then again|OPT|= 3. If ALGservesAbeforeB, as previously it needs\nt0+(2−t0−δ)+3 = 5−δ= 3λ. IfALGservesBbeforeA, itneedst0+(1−(2−t0−δ))+2 =\n2t0+δ+ 1 = 2t0+ 6−3λ≥3λ. The competitive ratio is at least λ.\nFinally, ift0≤3λ−3 = 2−δ(intuitively, ALGis not “too close” to the origin): we\nrelease att0all the requests but the one in D. Then intuitively either ALGwent towards\nA, and we will act as previously. Or it went towards B, and we will block the release in\nD. More formally, at t=t0+ 1:\nif the algorithm is at a position s/prime/prime<0, then we release the last request (in D). Note\nthat ALGcannot have served A(as we hads/prime>0att0) norB(no time to have s/prime/prime<0\natt0+1). Then, the best ALGcan do after t=t0+1is to go toA(ass/prime/prime<0), and then\ntoB. As we had s/prime= (2−t0)−δatt0, we have|ALG|≥t0+(2−t0)−δ+3 = 5−δ= 3λ,\nwhile|OPT|= 3, so the competitive ratio is at least λ.\nifs/prime/prime≥0, we release the last request in Datt1= 3 + (1−xD) = 2 +t0. Then\n|OPT|=t1(be inAat time 1, then go to B(time 3) and back to D). If ALGserves\nAbeforeD, ass/prime/prime≥0att0+ 1, it needs at least t0+ 1 + 2 +xD= 5. If it serves\nDbeforeA, asDis released at t1, it needs at least t1+xD+ 1 = 5. Hence, the\ncompetitive ratio is at least5\nt1=5\nt0+2≥5\n3λ−1=λ(by deﬁnition of λ).\nJ",
  "textLength": 110085
}