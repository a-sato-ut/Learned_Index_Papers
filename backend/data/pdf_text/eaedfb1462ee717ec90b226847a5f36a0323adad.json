{
  "paperId": "eaedfb1462ee717ec90b226847a5f36a0323adad",
  "title": "RSATree: Distribution-Aware Data Representation of Large-Scale Tabular Datasets for Flexible Visual Query",
  "pdfPath": "eaedfb1462ee717ec90b226847a5f36a0323adad.pdf",
  "text": "©2019 IEEE. This is the author’s version of the article that has been published in IEEE Transactions on Visualization and\nComputer Graphics. The ﬁnal version of this record is available at: 10.1109/TVCG.2019.2934800\nRSATree: Distribution-Aware Data Representation of Large-Scale\nTabular Datasets for Flexible Visual Query\nHonghui Mei, Wei Chen, Y ating Wei, Yuanzhe Hu, Shuyue Zhou, Bingru Lin, Ying Zhao, Jiazhi Xia\nFig. 1. RSATree facilitates fast answering of aggregate queries in large-scale tabular datasets while allowing ﬂexible binning strategies.\n(a) A case built on a social network check-in dataset with 4.5 million records. A brushing and linking operation is performed by brushing\nworkdays (Monday – Friday) and 13 hours of each day (9am – 9pm) for ﬁltering. (b) Binned scatterplot created from an airline on-time\nperformance dataset with 180 million records. The bin width can be freely modiﬁed and instant previews are shown. (c) Capability\nof RSATree to generate a histogram with varied bin widths by using the same dataset as (b). As shown on the left side of (c), the\ndistribution of “LateAircraftDelay” is relatively unbalanced. Application of log-scale binning produces a recognizable histogram (right\nside). Conventional approaches cannot simultaneously achieve low response time and ﬂexible binning strategy in the three cases.\nAbstract — Analysts commonly investigate the data distributions derived from statistical aggregations of data that are represented by\ncharts, such as histograms and binned scatterplots, to visualize and analyze a large-scale dataset. Aggregate queries are implicitly\nexecuted through such a process. Datasets are constantly extremely large; thus, the response time should be accelerated by calculating\npredeﬁned data cubes. However, the queries are limited to the predeﬁned binning schema of preprocessed data cubes. Such limitation\nhinders analysts ﬂexible adjustment of visual speciﬁcations to investigate the implicit patterns in the data effectively. Particularly,\nRSATree enables arbitrary queries and ﬂexible binning strategies by leveraging three schemes, namely, an R-tree-based space\npartitioning scheme to catch the data distribution, a locality-sensitive hashing technique to achieve locality-preserving random access to\ndata items, and a summed area table scheme to support interactive query of aggregated values with a linear computational complexity.\nThis study presents and implements a web-based visual query system that supports visual speciﬁcation, query, and exploration of\nlarge-scale tabular data with user-adjustable granularities. We demonstrate the efﬁciency and utility of our approach by performing\nvarious experiments on real-world datasets and analyzing time and space complexity.\nIndex Terms —Aggregate query, visual query, large-scale data visualization, R-tree, summed area table, hashing\n1 I NTRODUCTION\nExploratory data analysis (EDA) constantly involves huge size of\ndatasets. Data items must be ﬁltered and aggregated before encoding\nwhen visualizing a large and high-dimensional dataset due to limited\nnumber of screen pixels [28]. Particularly, data are visualized by charts,\nsuch as histograms, binned scatterplots, and heatmaps, which display\nthe aggregations (e.g., count and average) performed in a sequence of\n• H. Mei, Y. Wei, Y. Hu, S. Zhou, B. Lin, and W. Chen are with The State Key\nLab of CAD & CG, Zhejiang University. E-mail: fmeihonghui, weiyating,\ncadhyz, zhoushuyue, linbingru g@zju.edu.cn, chenwei@cad.zju.edu.cn.\n• Y. Zhao and J. Xia are with School of Computer Science and Engineering,\nCentral South University. E-mail: fzhaoying, xiajiazhig@csu.edu.cn.\n• Wei Chen is the corresponding author.\nManuscript received xx xxx. 201x; accepted xx xxx. 201x. Date of Publication\nxx xxx. 201x; date of current version xx xxx. 201x. For information on\nobtaining reprints of this article, please send e-mail to: reprints@ieee.org.\nDigital Object Identiﬁer: xx.xxxx/TVCG.201x.xxxxxxxaxis-aligned subspaces (called bins) divided from the entire data space.\nThe parameters of these aggregate queries , such as ﬁlter conditions\nand bin width, should be frequently modiﬁed during EDA [59]. This\ncondition poses two main challenges to the underlying query implemen-\ntation. The ﬁrst challenge is the capability to answer aggregate queries\nwith low response time because high latency (more than 500 ms) may\ndiscourage user activity and decrease dataset coverage [43]. The second\nchallenge is to support arbitrary queries , that is, aggregation for any\nspeciﬁc range with ﬂexible binning strategy. Analysts should use appro-\npriate range ﬁlters and binning strategy (e.g., equi-width and equi-data)\nbased on their requirements to observe patterns well. However, the two\nrequirements are rarely supported simultaneously.\nMany studies have focused on reducing the response time for\naggregate queries. Data cubes are a commonly used approach,\nwhich precompute answers to possible aggregate queries with fast\nresponse [25, 42, 44, 49]. However, the queries are still limited to the\npredeﬁned binning schema. This limits the ﬂexibility of visual designs\nand the breadth of analysts 'exploration. Support for high ﬂexibility\nrequires considerable preprocessing, which results in large storage\n1arXiv:1908.02005v2  [cs.DB]  11 Oct 2019\n\nconsumption.\nTo reduce unnecessary storage, thereby avoiding huge storage cots,\npreprocessing should be systematically designed on the basis of usage\nscenarios [35, 42, 44, 49, 63]. Thus, obtaining accurate results is not\nconstantly required when conducting exploratory analysis. In some\nscenarios, the answers may be slightly inaccurate in exchange for a\nquick response. For example, an approximate preview of the resulting\nchart during user interaction (e.g., dragging a slider) is shown, and\naccurate values are computed when the interaction stops. Such an idea\nis extended by the concept of approximate query answering [1, 13, 41].\nThus, statistical summaries of the data can be precomputed to provide\nanswers to aggregate queries. Poosala et al. [51] used histograms to\nsummarize the data distribution, in which requested aggregation of\ncorresponding subcubes could be estimated. Response time and storage\nconsumption can be remarkably reduced by allowing certain bounded\nerrors, which support arbitrary queries.\nThe concept of approximate answering has inspired us to construct\nand leverage RSATree for a distribution-aware data representation of a\nlarge-scale tabular dataset with fast approximate query answering. In\nthe design of RSATree, we mainly consider the support of arbitrary\nrange queries and ﬂexible binning strategy with low response time.\nFirst, the preprocessed data representation should be able to answer the\naggregate query with approximately constant response time regardless\nof the speciﬁed range. Second, RSATree is designed to enable ﬂex-\nible binning strategy rather than support of only equi-width binning.\nThird, approximate answers are tolerated, but the error rate should be\nmaintained at an overall low rate. We design a distribution-aware data\nrepresentation to reduce storage consumption and improve accuracy.\nData distribution allows preprocessing with adaptive granularity and\ncan remarkably reduce storage costs and maintain an overall low error.\nWe support arbitrary queries through auxiliary data representation\nbased on integral histograms (IH) [52], which are a useful data structure\nthat supports efﬁcient approximate range query. IHs extend summed\narea table (SAT) [20] and can calculate an approximate data distribution\nunder constant time in any region of discretized Cartesian data space.\nWe adopt R-tree to divide the data space into subspaces and preprocess\nthem with different granularities to achieve a balance between the accu-\nracy of the queries and the storage cost of the precomputed structures.\nIn addition, we employ locality-sensitive hashing (LSH) [21] functions,\nwhich support approximate KNN search in a high-dimensional space,\nto perform point-in-range search and range overlapping test. LSH func-\ntions enable random access to data with a reduced time complexity by\nreformulating the data organization.\nWe design and develop a web-based visual query system for high-\ndimensional tabular datasets using RSATree to determine its usability\nand efﬁciency. Instant visual feedback to frequent and continuous user\ninteractions, such as specifying a ﬁlter range and changing bin settings,\nis enabled by precomputing and leveraging an RSATree structure in the\nentire process. Moreover, we propose a novel interaction scheme called\nscale alignment , which can remarkably improve the accuracy of the\nresults. We evaluate its performance and utility on the basis of various\nexperiments performed on real-world datasets.\nIn summary, the main contributions of this study are as follows: First,\na novel data representation called RSATree, which supports ﬂexible\napproximate query of large-scale tabular datasets, is designed and\ndeveloped. Second, a web-based interactive interface, which leverages\nRSATree to meet the requirements of different scenarios, is proposed.\n2 R ELATED WORK\n2.1 Visual Query\nVisual query plays a central role in visual analysis. It answers the\ndomain of interests in a dataset through visual representations. In\ncomparison with standard data queries that use relational languages\nto perform a search in relational databases, visual query languages\nare used to construct external representations that can be easily per-\nceived by analysts [12, 19]. Visual query enables efﬁcient access to\nvaluable information in a database, thereby allowing analysts to explore\ndatasets and focus on valuable items. This process requires queries to\nbe efﬁciently performed and frequently iterate via dynamic query [57].A direct means to perform a visual query is to allow analysts to\nspecify a visualization form in an available selection list, as conducted\nby many existing visual exploration tools [46], such as VQE [22],\nVisage [54], and Tableau (formerly Polaris [58]). Query results are\ndisplayed by the selected visualization form. Other visualization tools,\nsuch as Spotﬁre [3], allow analysts to make a visual query by interacting\non predeﬁned visualizations, such as brushing and zooming on a map.\nIn this manner, visual queries are intuitively performed.\nThe execution of a visual query frequently produces implicit ag-\ngregate queries in databases. They are performed on tabular datasets\nwith multiple dimensions . For example, analysts should initially select\nparticular dimensions and deﬁne an aggregate function to create a visu-\nalization of a car dataset. In the case of creating a bar chart, analysts\nshould display the average ( function ) horsepower ( dimension ) of cars\ngrouped by different cylinders ( dimension ). During visual analysis,\nvisual queries frequently iterate among different parameters; this pro-\ncess requires an instant answer for the corresponding aggregate query\nperformed in the database.\nHowever, an underlying database management system requires mas-\nsive operations over terabytes of data stored on hard disks [16], which\nresults in a long execution time before queries are completed and a\nprecise answer is returned. Previous research shows that most an-\nalysts prefer fast approximate answers rather than time-consuming\nprecise answers when instant feedback is not available [69]. This re-\nquirement is met by applying approximate query answering, which\nhas been employed by some online analytical processing (OLAP) sys-\ntems [13,51]. Approximate query effectively reduces the response time\nrequired for complex queries by utilizing different types of strategies,\nsuch as sampling- [1], histogram- [14, 45], and wavelet-based [13, 47]\ntechniques.\nSampling is a widely used data abstraction technique to support\nvisual abstraction [10, 17, 68]. Sampling maintains the characteristics\nof the data with few samples. Uniform sampling provides a simple\nsolution but cannot constantly handle datasets with a skewed distribu-\ntion [15]. To address this problem, different non-uniform sampling\nmethods, such as visualization-aware sampling [50] and sampling with\nordering guarantees [36], are used to retain the database structure at\ndifferent levels of visual abstraction (e.g., during zooming). Real-time\nqueries can be achieved through progressive data processing and pre-\nsentation, such as VisReduce [53], DICE [34], sampleAction [24], and\nSeeDB [60], by leveraging an incremental sampling technique [32, 33].\nMeanwhile, approximate queries performed on data cubes [5] have\nbeen conducted to obtain a remarkably reduced response time with\ndegraded accuracy in exchange. Statistical summaries of the data are\nprecomputed to provide answers to aggregate queries on subdata cubes.\nPoosala et al. [51] used histograms to summarize data distribution, in\nwhich the requested aggregation of corresponding subcubes can be\nestimated. IHs [52] are a useful data structure that supports efﬁcient\napproximate query. They extend SAT [20] and enable the computa-\ntion of histograms of all possible regions in Cartesian data space to be\nexecuted under constant time. However, the result of precomputation\nmay be relatively memory-consuming, especially for high-dimensional\ndatasets. Loading data on demand [6] is a possible solution. In de-\nsigning such methods, space partitioning trees [4] are used to create\nan index of data space, which preserves the spatial distribution (e.g.,\nquadtree [55] or k-d tree [9]), value distribution (e.g. R-tree [26]),\nor both (e.g. MRA-tree [38]). The histogram-based approximation\nstrategy has inspired us to propose a novel data representation named\nRSATree for supporting efﬁcient visual query in large-scale tabular\ndatasets.\n2.2 Interactive Visualization of Large Datasets\nVarious interactive visualization systems have been implemented to\nsupport efﬁcient visual exploration of large datasets by performing data\nand visual abstraction techniques.\nStudies have extended the concept of data cube that precomputes\nhierarchical binning and aggregation for multiscale visualization. Pro-\nﬁler [35] recommends binned views for anomaly detection. The prepro-\ncessed data cube is loaded into memory to support scalable brushing\n2\n\n©2019 IEEE. This is the author’s version of the article that has been published in IEEE Transactions on Visualization and\nComputer Graphics. The ﬁnal version of this record is available at: 10.1109/TVCG.2019.2934800\nand linking. ImMens [44] utilizes the parallel computing capability of\nGPU to improve the performance of handling precomputed tiles of data\ncubes that are stored as textures. Nanocubes [42] use a well-designed\nindexing scheme to reduce the size of the data cube. Hashedcubes [49]\nextends Nanocubes with a more compact representation and a consid-\nerably simpler implementation. On the basis of Nanocubes, Gaussian\nCubes [63] further support interactive modeling, such as linear least\nsquares and principal component analysis, by storing multivariate Gaus-\nsian rather than simple aggregation (e.g., count). BigIN4 decompose\nhigh-dimensional queries into low dimensional ones and gives approxi-\nmate answers to reduce storage consumption of cubes [41]. These con-\ncepts have an outstanding performance on real-time visual exploration\nbut still possess several limitations. Their precomputation schema is\nﬁxed, and their capabilities to answer visual queries are limited. The\nﬂexibility of users for visual exploration is diminished in exchange for\nhigh performance and instant interactive response.\nAnother approach to accelerate visual query is by providing approx-\nimate query answers. Analysts prefer a fast and approximate answer\nrather than an exact answer in many situations. Such an idea can be\nenhanced by applying progressive visual analytics [23, 69], which in-\ncrementally processes the queries and provides a dynamic tradeoff\nbetween the result accuracy and response time. Generally, progressive\nsystems apply sampling-based computation with increasing sample\nrate to produce accurate results with time. Progressive visual analytics\nhas been proven to provide better insight than typical visualizations\nthat process the entire dataset before displaying the result [69]. In\npractice, progressive systems should estimate and depict the uncertain-\nties, which are usually conﬁdence intervals, in the current calculation\nprocess [24, 29]. Other efforts have been conducted to select the best\ndata subset to be initially reﬁned [53] or prune the possible candidates\nof queries by using decision-making strategies [60].\nGenerally, these systems aim to compute and present the most valu-\nable data to users by allowing them to steer the exploration process and\nreﬁne the query range and presentation method. Users 'areas of interests\nin the dataset should be identiﬁed [27, 66, 70], and proper views should\nbe selected [8, 65]. RSATree naturally supports these methods through\na progressive exploration process. Meanwhile, RSATree can support\nﬂexible speciﬁcation on data and views, which is useful for exploratory\nnavigation and analysis in large spaces (e.g., V oyager [64]).\n3 D ESIGN METHODOLOGY\nIn this section, we present our methodology for designing the data\nrepresentation that supports ﬂexible approximate query of a large-\nscale tabular dataset. We discuss the design considerations and raised\nchallenges by investigating several usage scenarios.\n3.1 Scenarios\nSeveral typical scenarios occur when working with large-scale tabular\ndatasets through interactive analysis tools. As an example, Fig. 1(a)\nshows a common visual analytics system for spatiotemporal data [18,\n31, 42, 67, 71]. The main body of the system interface consists of a\nmap with overlaid heatmap and statistical charts that display related\nattributes, such as histograms and line charts. Common interactions\ninclude panning and zooming on the map and ﬁltering by brushing or\nselection in analyzing such spatiotemporal data.\nAnalysts assume that the map can be quickly refreshed during pan-\nning and zooming. Flexible and continuous zooming may be helpful,\nbecause the effect of heatmap representations depends on reasonable\nbinning. Bins that are very ﬁne may fail to capture the distribution,\nwhile bins that are very coarse will lose most details. The lack of con-\ntinuous transition during zooming can also confuse analysts. Moreover,\nanalysts may select any arbitrary range as a ﬁlter in performing ﬁltering\noperations. All other charts are quickly updated when ﬁltering, which\nis a common brushing and linking operation. Instant previews during\nsuch operations can provide a good exploration experience. At this\npoint, a fuzzy result is also acceptable in exchange for fast exploration,\nwhile the error rate of the preview must be controlled within a certain\nrange without affecting data investigation.Besides the smooth exploration experimence, ﬂexible visual repre-\nsentation methods are also required [40, 46, 64]. For example, a simple\nequi-width binning cannot guarantee desired charts that can exhibit a\nparticular pattern due to skewed data distribution. At this point, analysts\nrequire considerable binning strategies, such as a log-scale binning, to\nproduce a well-distributed histogram (Fig. 1(c)).\n3.2 Design Considerations\nWe have identiﬁed some usage scenarios to determine the require-\nments when working with EDA tools. We obtain the following design\nconsiderations by summarizing the requirements and combining our\nexperience.\nR1. Answer arbitrary range queries. We consider a type of query\nto the data cube called range queries to support the brushing and\nlinking operation properly. Range queries request aggregation within a\nspeciﬁed contiguous range in the domains of involved dimensions. The\nunderlying data structure should be designed to answer any arbitrary\nrange query due to the importance of data coverage during exploratory\nanalysis.\nR2. Flexible binning strategy. An important step in EDA is to\nﬁnd an appropriate binning strategy for aggregation. The selection of\nthe width and number of bins is related to whether the characteristics\nand patterns of data can be correctly displayed. Most of the previous\nwork only support a predeﬁned equi-width binning strategy, which is\nuseful but frequently insufﬁcient. A ﬂexible binning strategy should be\nsupported to provide a good analysis.\nR3. Low accuracy loss. We can use approximate queries that can\nsacriﬁce accuracy to reach the goals that are otherwise difﬁcult to\nachieve, such as fast response speed and low storage consumption.\nHowever, such losses must be limited within a reasonable range. The\ndegree of tolerance is determined on the basis of the usage scenario.\nIn addition, the introduced uncertainty should be presented to the user\nthrough appropriate visual design.\nR4. Low response time and low storage consumption. Fast re-\nsponse is the primary goal that should be achieved to provide a good\nexploratory analysis environment. Moreover, low storage consumption\nis important because it allows the entire precomputed data structure to\nbe loaded in the main memory for high access efﬁciency.\n3.3 Design Challenges\nA clear picture of our data representation can be observed after orga-\nnizing possible usage scenarios and design requirements. We construct\nan RSATree based on such requirements. However, we still experience\nmany challenges based on three aspects.\nThe ﬁrst challenge is answering arbitrary aggregate queries with\nlow response time (R1, R4) . We follow the common practice and\ncalculate a data cube that provides a multidimensional summarization\nof the raw data and allows fast access to aggregated results. However,\nconventional data cubes rely on rollup operations and traversal, which\nis time-consuming, because the range may cover a large number of\nvalues when answering range queries. In summary, the ﬁrst challenge\nis to modify the data cube representation to enable aggregate queries\nover arbitrary ranges efﬁciently.\nThe second challenge is optimizing storage consumption while al-\nlowing a ﬂexible binning strategy (R2, R4) . A data cube consumes\nconsiderable storage space, especially with the increase in the resolu-\ntion and number of dimensions. Moreover, query answering is limited\nby the predeﬁned binning schema due to the nature of the data cube.\nTherefore, high ﬂexibility of binning strategy requires considerable\npreprocessing and ﬁne granularity, which leads to considerable storage\nconsumption problems. Approximate answering can alleviate such a\nproblem to some extent. Nevertheless, an optimized preprocessing\ndesign that minimizes space consumption is still required, which is our\nsecond challenge.\nMeanwhile, approximate answering creates a third challenge, which\nis reducing the effects of inaccurate answers (R3) . Inaccurate answers\nare allowed to accelerate the response and reduce storage consumption,\nthereby improving usability in actual usage scenarios. However, the tol-\nerance for errors is limited. Particularly, two aspects should be mainly\n3\n\nconsidered. One is the reduction of overall error level by systemati-\ncally designing the precalculation and query processes. Second is the\ndata structure adjustment to minimize the inﬂuence on results (such as\ngenerated statistical charts) when the overall error is constant.\n4 RSAT REE\nWe design and implement a novel data representation called RSATree,\nwhich adaptively approximates the aggregated values of the underly-\ning dataset. The response time of aggregate queries is remarkably\nreduced by placing the precomputed RSATree structure into memory\nand querying for the approximation at controllable and low error rates.\n4.1 Representation\nRSATree is a precomputed data structure used to support efﬁcient\naggregate query for large-scale tabular data. The design of RSATree\nis enlightened on the basis of the observation that the data points of a\nmultidimensional dataset are not uniformly distributed; thus, piles of\ndata points can be packed in which their spatial similarity is preserved\nand summarized at a controllable information loss.\nConsider a high-dimensional tabular data cube Vwithndimen-\nsionsD=fd1;\u0001\u0001\u0001; dng. An RSATree reformulates Vintopsmall\nnon-uniform data cubes with different levels of details based on the\ndistribution ofV, which is denoted as V0=fv0\n1;\u0001\u0001\u0001; v0\npg. As shown\nin Fig. 2, an RSATree is basically a nested three-level representation\nthat ﬂattens the input dataset. The top level is the index of partitioned\nspaces by LSH, the next level is the IH, and the innermost layer contains\nthefeature descriptor that represents the underlying data points. Each\nitem in the upper level is constructed by the items in the next lower\nlevel, thereby forming a nested structure\nFig. 2. Nested RSATree representation: (a) LSH buckets used to store\nsimilar leaf nodes of an R-tree (b). Each node stores a set of IHs (c).\nIn the ﬁrst level, each v0\ni2 V0is grouped into an LSH bucket.\nThe group result is determined on the basis of the applied LSH func-\ntions. With the arrangement of coherent subspaces, buckets of hash\ntables ensure an efﬁcient spatial locality by grouping similar (v0\ni; v0\nj)\npairs together. Thus, operations imposed on spatial neighborhood are\nempowered, such as range query.\nIn the second level, a set of IHs His calculated to construct all the\nsubspacesfv0\nijv0\ni2V0g. Each hi2His a cube, where each cell\ncontains a feature descriptor of all data points in the cell (contents of\nthe third layer). After preprocessing, IH can quickly respond to range\nqueries and return a feature descriptor of all data within a certain range.\nThe last level is the feature descriptor, which takes many forms. The\nsimplest form is by directly recording the aggregated values of the\nunderlying data. This form works for the measures that are distributive\n(e.g. count andsum) or algebraic (e.g. mean =sum=count ). For other\nmeasures (e.g. median ), RSATree can estimate the answer by recording\nthe data distribution on the dimensions with statistical histograms.\nThis form is used in the original IH; however, we have made some\nadjustments to suit our algorithm.\nThe nested RSATree representation is a reformulation, abstraction,\nand simpliﬁcation of the input data. The elements of an RSATree are\nplaced in a hybrid linear tree structure, which supports random access\nand maximizes the query performance. Particularly, the following func-\ntionalities are provided: First, aggregate query efﬁciency is improved\nby searching the approximation of data distribution, where time com-\nplexity is independent of the number of data points. Second, efﬁcient\nonline visual query is achieved by reducing the storage consumption,which is independent of the number of data points. Third, random\naccess to data is enabled when querying on large-scale datasets.\n4.2 Construction\nFig. 3 illustrates the construction of an RSATree. For a given tabular\ndataset, we initially partition its data space into multiple subspaces with\ndifferent granularities based on data distribution. The approximation\nof each subspace is computed and stored to support efﬁcient aggregate\nquery, which can be used to estimate the distribution of input data.\nApproximation sets are then re-organized into a compact storage. All\nthese computations are preprocessed, and a progressive construction\nscheme is applied to reduce its time and space complexity.\n4.2.1 Space Partitioning\nIHs enable range query to be performed under an approximately con-\nstant time at a huge storage cost ( O(N1\u0002\u0001\u0001\u0001\u0002 Nd\u0002K), where\nN1;\u0001\u0001\u0001; Ndare the number of bins of each dimension, and K is the\nnumber of bins in the histograms). We partition the entire data space\ninto subspaces with different granularities (Fig. 3(a)) and compute IHs\nfor each subspace (Fig. 3(b)) instead of compressing the produced\nhistograms, as proposed by previous studies [39].\nWe use R-tree to partition the space. The core idea of R-tree is\nto place nearby nodes under the same parent, which is represented\nas the minimum bounding rectangle of all the nodes it contains. The\nrectangle of each leaf node represents an object (in RSATree, each\nobject is a data point represented as a rectangle with side lengths of\nzero). All non-leaf nodes are the aggregation of data points, and the\nincreasing number of points are aggregated at high levels. Each level\ncan be assumed as an approximation of the dataset. The leaf level is the\nﬁnest-grained approximation (completely accurate), and the coarser the\napproximation is, the higher the level will be. We adopt the R\u0003-tree [7]\nstrategy among multiple R-tree variants. This strategy outperforms\nother existing R-tree variants with a minimization of coverage and\noverlap of the partitioned result, which ﬁts our requirements.\nAs the core of RSATree, the distribution-based partition of the data\nspace determines the approximation quality of the input data. Our goal\nis to make the data points as evenly distributed as possible within each\nsubspace. Thus, the proper granularity can be chosen for each subspace,\nmaking the underlying data points be represented with less storage\nspace and minimal loss. Therefore, we modify the R\u0003-tree strategy for\ninserting points by taking into account the density changes within each\nnode. To determine which branch the newly inserted node should fall\ninto, the original algorithm selects the branch with the smallest change\nin area, that is, arg minnode(area new\u0000area). We also consider the\ndensity, which changes fromn\nareaton+1\nareanew. We multiply the ratio\nof the density change by the area change as the ﬁnal new optimization\ntarget, that is, arg minnoden\nn+1\u0002areanew\narea\u0002(area new\u0000area). It can\nbe simpliﬁed as arg minnodeareanew\narea\u0002(area new\u0000area)because\nnis always very large.\nIn this manner, the divided subspaces have the following features.\nFirst, most of the empty spaces are eliminated. Second, few overlaps\nexist with one another. Third, each subspace contains a similar num-\nber of data points, which causes data-intensive regions to have ﬁne\ngranularities and vice versa. Fourth, the data points contained in each\nsubspace are distributed as evenly as possible. This feature allows the\npartition to capture the distribution characteristics of the original data\npoints well. Then, we begin to build an approximation of underlying\ndata points in each partitioned subspace.\n4.2.2 Building Integral Histograms\nIntegral histograms [52] is an extension to summed area table [20].\nAs shown in Fig. 4(a), an SAT can generate the sum of values in an\narbitrary rectangular area of a data grid in constant time. The value in a\ngrid at position (x; y)of an SAT is the sum of all grids in the rectangle\nbounded by (0;0)and(x; y). IHs summarize the distribution of data\npoints falling in each grid rather than storing a single scalar in each\ngrid. This process efﬁciently returns the answer of an aggregate query\nby computing the histograms of all data points within the query range\n4\n\n©2019 IEEE. This is the author’s version of the article that has been published in IEEE Transactions on Visualization and\nComputer Graphics. The ﬁnal version of this record is available at: 10.1109/TVCG.2019.2934800\nFig. 3. Overview of RSATree operation. The construction of RSATree consists of three consecutive stages, namely, (a) partitioning of the data space\ninto subspaces on the basis of data distribution using R-tree; (b) computation of IHs as the approximation of the original data for each subspace; (c)\nand storing and indexing of IHs by LSH, thereby preserving the spatial coherence of subspaces. (d) Possible subspaces that intersect with the\nspeciﬁed range are fetched from LSH buckets when RSATree is used to execute an aggregate query. After validation, involved IHs are merged and\nused to estimate the actual distribution of the requested values.\nin a manner similar to computing the sum of a rectangular area via\nSAT [14, 45].\nFormally, for a d-dimensional dataset binned by N1\u0002\u0001\u0001\u0001\u0002 Ndgrids\nand summarized by histograms with Bbins, the IH H(x1;\u0001\u0001\u0001; xD; b),\nwhere x1;\u0001\u0001\u0001; xDare indices of bins on different dimensions, and bis\nthe index of the histogram bin, is deﬁned as\nH(x1;\u0001\u0001\u0001; xD; b) =x1X\nx0\n1=1\u0001\u0001\u0001xDX\nx0\nD=1bX\nb0=1h(x0\n1;\u0001\u0001\u0001; x0\nD; b0) (1)\nwhere h(x1;\u0001\u0001\u0001; xD;\u0001)calculates the values of all histogram bins b\nand represents the histogram of values in each binned grid. The IHs of\nany rectangular area in the data space can be calculated asX\np2f0;1gd(\u00001)d\u0000kpk1H(xp;\u0001) (2)\nwhere xpare the corners of the rectangular area with p2f0;1gd.\nFig. 4. (a) By using an SAT, the sum of values inside area can be\ncalculated as D+A\u0000B\u0000C= (¬+­+®+¯)+¬\u0000(¬+­)\u0000(¬+®) =\n¯. (b) Misaligned computational grids and SAT cells. (c) Errors occured\ndue to the mismatching of computational grids (blue rectangles) and data\ncells (the red region).\nMoreover, the feature descriptor in each cell in RSATree is not\nnecessarily a histogram. The feature can also be one or more aggregated\nvalues (such as sum orcount ) or their combination (e.g., store sum\nandcount to calculate the average). However, the feature descriptor\ncan be regarded as an array of length Bregardless of its type and be\ntreated similar to a histogram when calculating .\nLocal histogram binning. Binning IHs on the basis of the global\nrange of all data points results in skewed distributions of histograms\nbecause each histogram is only built upon a small portion of data points\nin the same subspace with similar values on all dimensions. Thus,\nwe calculate the local range of data points in each subspace to enable\ndynamic binning, thereby providing high approximation accuracy.\n4.2.3 Generating LSH Buckets\nWe adopt the LSH strategy to enable efﬁcient random access of IHs that\npossibly have intersections with query ranges. LSH can be used as an\napproximate nearest neighbor search, which is a point-to-point search,\nfor multidimensional points. To support point-in-range searches and\nrange overlapping tests, we extend LSH by applying a uniform sampling\non the edges of the range (a hyper-rectangle). Thus, the extended LSHcan be used to accelerate the RSATree construction and range query\nprocesses by hashing generated IHs into locality-preserving buckets\n(Fig. 3 (c)). More details can be found in Section 1 in the supplementary\nmaterial. The LSH functions we use satisfy the p-stable distribution of\npoints in the Euclidean space [21].\n4.2.4 Progressive Construction\nThe three aforementioned steps denote a standard process of construct-\ning an RSATree. Its performance is inversely proportional to the data\nsize because a standard R-tree keeps all data points in memory. Our\nsolution for that is a progressive construction scheme.\nWe initially uniformly sample the input data and construct an R-tree\nbased on the sampled data points. We preserve the nodes of the R-tree\nand obtain a staged partition. When inserting the remaining points, the\nexpansion and splitting of the nodes are no longer processed, and only\nthe node containing the point is selected. If the node containing the\npoint does not exist, then the nearest node is searched and its rectangle\nis expanded to include the new point. IHs are computed for each\nnode by re-inserting all points inside it. Feature descriptors are stored\nand updated when inserting points rather than keeping the original\npoints. Progressive construction not only reduces the storage cost by\nloading parts of data into the memory but also improves the construction\nefﬁciency by reducing the calculation of branch selection and splitting,\nthereby making it relatively suitable for large-scale datasets. However,\nnew coming points that cannot ﬁt in any existing subspace of the staged\npartition may exist during the formulation of a complete partition. The\nresulting expansion of the existing subspaces may cause the original\npartition to be distorted to some extent. These IHs cover a large space\nand are slightly inaccurate due to the decreasing granularity.\n4.3 Usage\nWe denote a high dimensional dataset as Vwithndimensions\nD=fD1;\u0001\u0001\u0001; Dng. Assume that the domain of dimensions is\nf[a1; b1];\u0001\u0001\u0001;[an; bn]g.\nAggregate query. We can deﬁne an aggregate query with range\nR=f[x1\n1; x2\n1];\u0001\u0001\u0001;[x1\nn; x2\nn]gand an aggregation function A, denoted\nasQ(R; A), which applies aggregation to the set of all data points\nlocated within range R(fvjv2V and8d;vd2[x1\nd; x2\nd]g).\nComputational grids. We consider a subset S=fDi1;\u0001\u0001\u0001; Dikg\nofDand an aggregation function Aof interests when drawing a k-\ndimensional statistical chart (e.g., a histogram when k= 1, or a binned\nscatterplot when k= 2). With given aggregate dimensions Dm2D and\na range ﬁlter Rf=f[y1\n1; y2\n1];\u0001\u0001\u0001;[y1\nn; y2\nn]g, the result is denoted as a\nbinned k-dimensional cubeGonS. Each dimension Dd2S is splitted\nintoNdbins[h0\nd; h1\nd);\u0001\u0001\u0001;[hNd\u00001\nd; hNd\nd], where h0\nd=y1\ndandhNd\nd=\ny2\nd. Thus,Gcontains a total of Ni1\u0002\u0001\u0001\u0001\u0002 Nikcomputational grids .\nEach grid inGcan be identiﬁed by a k-tuple T=hti1;\u0001\u0001\u0001; tikiand\ncontains an aggregated value. Each value can be fetched by performing\n5\n\nan aggregate query Q(RT; A), where RTis the intersection of the\nrange deﬁned by ﬁlter Rfand the bin, which is denoted as\nRT=(\nrj\f\f\f\f\frj=(\n[htj\u00001\nj; htj\nj]; j2fi1;\u0001\u0001\u0001; ikg\n[y1\nj; y2\nj]; otherwise)\nIn addition, the computational grids do not have to be equidistant.\nQuerying using IH. The result of an aggregate query can be calcu-\nlated from the preprocessed IH by using Equation 2. However, making\nan aggregate query of an arbitrary query range on the constructed IH\ncan result in an imperfect ﬁt between the corners of the queried rectan-\ngular area and the boundary of binned grids (Fig. 4(b)). In practice, the\ncoordinates of 2dcorners of the rectangular area are rounded before\ntaking into Equation 2. We also implement an algorithm that can reduce\nthe number of required additions or subtractions when batching the\naggregated results that correspond to the computational grids G[30].\nSee more details in the supplementary material (Section 1.2).\nQuerying using RSATree. Fig. 3(d) illustrates the operation of an\naggregate query in an RSATree. When an aggregate query Q(R; A)\ncomes with a dimension subset Sand an aggregate dimension Dm2D,\nan RSATree initially leverages LSH functions to narrow down the\nsearching spaceGinto a candidate range, in which IHs that are possibly\noverlapping with Rare stored. The RSATree collects a set of histogram\ntables overlapping with Rby comparing the bounding boxes of all\ncandidate IHs onStoR. This set is then used to calculate the histogram\nfrom which the approximation of aggregation result A(Dm)can be\nestimated.\n5 V ISUAL QUERY WITH RSAT REE\nIn this section, we explain the manner in which an RSATree can be\nused in visual analytics. We initially introduce the general ﬂowchart of\nan RSATree-based visual query. Then, we present the visual interface\nand related optimization. Moreover, the inﬂuence of approximate query\nis discussed.\n5.1 Flowchart\nVisual query with RSATree forms a seamless composition of multi-\nple ofﬂine and online steps. First, an RSATree representation is pre-\ncomputed ofﬂine on the basis of the selected dimensions in a dataset.\nRSATree representation adaptively partitions the entire data space on\nthe user-deﬁned binning dimensions and uses IHs to depict the dis-\ntribution of each data subspace. Each histogram or other descriptors\nare computed to summarize the data distribution of the user-deﬁned\naggregate dimension. Second, the binning strategy is determined on the\nbasis of the predeﬁned schema or user-deﬁned parameters to generate\nvisual charts that display the data attributes. On the basis of the binning\nstrategy, computational grids are generated before performing aggre-\ngate queries. These aggregate queries are then answered by searching\nthe corresponding IH in the RSATree to estimate the distribution of\nthe binned area. Subsequently, the requested visualization can be cre-\nated. The construction of the visualization and aggregate queries are\nperformed online because the RSATree is stored in memory. Moreover,\nanalysts are allowed to adjust interactively the visualization parameters,\nsuch as ﬁlters, bin widths, and dimensions to query. These interactions\nupdate the computational grids and trigger a new series of aggregate\nqueries, which are efﬁciently answered by the RSATree. Therefore,\ninstant visual feedback is provided in the visualization.\nBy supporting arbitrary range queries and ﬂexible binning strategies,\nRSATree enables serveral useful operations for visual query systems.\nTable 1 compares RSATree to existing approaches for visual query.\n5.2 Interface\nTo show how an RSATree is used to support visual query, we implement\na visual interface that can be accessed through a web browser. The\nvisual interface has two forms, corresponding to the two scenarios\ndiscussed in Sect. 3.1: brushing and linking for spatial-temporal data\n(Fig. 1(a)), as well as customized speciﬁcation of charts (Fig. 1(b)(c)).\nThe brushing and linking operations are achieved by regenerating\nthe computational grids and querying during brushing. When creating\ncustom charts, users can modify parameters, such as query ranges andTable 1. Comparison of different data cube approaches for visual query.\nHashedcubes is not shown as it share similar properties with Nanocubes.\nSquare\nCrossﬁlterimMens Nanocubes RSATree\nArchitecture ClientClient\n(Server)Client-\nServerClient\n(Server)\nDemonstrated\ndata size105101210121012\n2D binning No Yes Yes Yes\nBinning\nstrategiesPredeﬁned\ngroupingEqui-width Equi-widthFlexible\nstrategies\nMultiple\nbrushesYes No Yes Yes\nZooming NoPredeﬁne\nlevelsQuad-tree\nlevelsContinuous\nzooming\nSupported\nmeasuresAlgebraic Count only Algebraic Not limited1\nApproximation No No No Yes\n1Non-algebraic measures are estimated from data distributions.\nbin widths, by dragging the sliders. Although a slider is designed\nto allow the selection of any value within a certain range of the real\nnumber ﬁeld, only a certain number of discrete values can be actually\ntaken due to the limitation of screen pixels. This conclusion also\napplies to the generation of computational grids. On this basis, we can\nfurther optimize the usage efﬁciency of RSATree without affecting user\ninteractions.\nScale alignment can reduce the error of the results through better\nintegration of the interface and precomputation process. We can gener-\nate queries that are suitable for our preprocessed data structure without\naffecting the users exploration by reasonably deﬁning and limiting the\ndesign space for user interaction.\nTo support a ﬂexible binning strategy, RSATree applies selection\nof adaptive granularities, which makes a ﬁne overall granularity (with\nstorage space remaining the same). However, such an approach causes\nsome problems. The computational grids cannot be perfectly matched\nto the cube cells similar to using traditional data cubes due to the dif-\nferent sizes of cube cells. This process requires interpolation to derive\nthe answer, which is the main source of the error. In principle, the error\nshould be limited in a reasonable range as long as the granularity is ﬁne.\nHowever, in practice, a slight shift will cause the ﬁne-grained precom-\nputation results to completely fail to provide accurate answers, thereby\nresulting in an actual error that is higher than expected (Fig. 4(b)).\nTo solve such issue, we consider scale alignment, which is a good\nintegration of the interface and precomputation.\nScale alignment is based on an observation. Although the user\nspeciﬁes the query range and parameters in ﬂoating point numbers (by\nbox selection or sliders), the actual execution still occurs in discrete\nspaces due to the limitation of screen pixels. As such, we can align\nthe design space of user interaction, such as the slider scale and the\n“scales” of cube cells. This condition makes the computational grids\nand the cube cells to have a large probability of full coincidence when\nperforming range queries, particularly when the granularity is ﬁne\n(Fig. 8(e-f)). In practice, the domains of each dimension are divided into\nscales, and the size of IH cells and computational grids are represented\nby the number of scales. These numbers are calculated on the basis of\ntheir original size and automatically adopt a close number containing\nonly 2, 3, and 5 as prime factors (e.g., 3600). This condition makes\nthe size of computational grids likely to be a multiple of related IH\ncells, thereby resulting in accurate queries. The size of the scales can\nbe automatically determined on the basis of the screen resolution (e.g.,\na pixel on the slider) or manually speciﬁed for a dimension with special\nmeaning (e.g., seconds for time dimension).\n5.3 Performance-Accuracy Tradeoff\nErrors are produced because the answer returned by RSATree is an\napproximate. We provide an option that allows users to toggle between\ndisplaying aggregated values and errors.\n6\n\n©2019 IEEE. This is the author’s version of the article that has been published in IEEE Transactions on Visualization and\nComputer Graphics. The ﬁnal version of this record is available at: 10.1109/TVCG.2019.2934800\n5.3.1 Estimating Error\nWhen using a distributive measure, the margin of error due to the\nmismatching of computational grids and data cells can be quickly deter-\nmined. As shown in Fig. 4(c), the aggregated value of the red region lies\nin the range of two values of the two blue rectangles. Therefore, we can\ndetermine the error of the result by two additional queries. Calculating\nthe error in this manner does not require access to raw data, although\nit increases the time complexity to 3 times of the original query. We\ndeﬁne the error to be (Vmax\u0000Vmin)=Vreturned . A switch is provided\nin the interface to open the error display rather than the original results,\nwhich are encoded by color (heatmap and binned scatterplot), error\nbars (bar chart and histogram), or y-axis (line chart).\nHowever, estimating errors for non-distributive measures is non-\ntrivial. Algebraic measures can be calculated based on its deﬁnition\n(e.g.mean max=sum max=count min). Other measures can only be\nestimated using the distributions recorded by IHs, which may produce\nhuge uncertainties.\n5.3.2 LSH\nGenerally, LSH improves the performance in exchange for reduced\naccuracy. In many situations, analysts may have different requirements\non the accuracy of the answer; hence, analysts may be allowed to mod-\nulate the performanceaccuracy tradeoff when making visual queries.\nTherefore, LSH can be reasonably applied to accelerate the query and\nguarantee a reduced but still acceptable accuracy. When visualization\nis used as a data preview (e.g., analysts navigate a map to identify\ninteresting regions), RSATree with the LSH scheme is preferred to\naccelerate online data exploration.\n5.3.3 R-Tree Hierarchy\nIn addition to the resolution of IHs, the ﬁneness of R-tree partition\nand the tree height directly affect the response time and accuracy of\nthe queries. Fig. 8 shows the query performance with different R-tree\nheights. Moreover, we can construct IHs at different levels of the R-tree\nto obtain a multiresolution data representation. This condition provides\nmany options to the scenario-based performanceaccuracy tradeoff.\nWe can design a progress exploration scheme based on such hier-\narchy. The progressive exploration scheme allows analysts to view\nthe result returned from a coarse level and apply ﬁlters to focus on\na small region of the input data based on observations received from\nthe approximate preview. Therefore, a small number of IH tables are\ninvolved with such coarse grain. On the basis of this preliminary op-\ntion, the R-tree can be pruned to eliminate irrelevant subtrees. Analysts\nthen receive an accurate observation for the small region. This process\ncontinuously iterates during progressive exploration.\n5.4 Implementation\nWe implement a prototype system to demonstrate the visual query with\nRSATree using a clientserver architecture. The server runs Node.js\nwith JavaScript code that can ﬂexibly handle various types of data.\nThe client requests data from the server through a deﬁned API. The\ninterface is written by means of HTML5, JavaScript, SVG, Canvas, and\nD3.js [11]. WebGL is not used.\n6 E XPERIMENTS\nIn this section, we present the experiments to evaluate the capabilities\nof RSATree. The evaluation was performed on a synthetic dataset and\nseven real-world datasets to test the construction of RSATree and its\nperformance for three interactive tasks. All experiments are performed\non a 3.40 GHz Intel(R) Xeon(TM) E3-1245 CPU with 32 GB main\nmemory. The web-based interface is viewed in Chrome 71.0.3578.98.\nIn the experiments, we use an average relative error (ARE) metric\nto evaluate an approximate query. Suppose that a query computes an\naggregation Aovernbins of data X1;\u0001\u0001\u0001; Xnand returns nrepresen-\ntative values v1;\u0001\u0001\u0001; vn. The ARE of the query is deﬁned as\nARE =1\nnnX\ni=1jvi\u0000A(Xi)j\nmax(vi; A(Xi))\nwhere A(Xi)is the exact aggregate over the ith bin.6.1 Datasets\nThe datasets we collected range up to over 1 billion elements. In addi-\ntion, a synthetic dataset is included, which is widely used for evaluation\nin previous studies. Table 2 summarizes the relevant information of the\nexperimental datasets, including the ScatterPlot Matrix (SPLOM) [35]\nand six real-world datasets. The number of data records in the dataset,\nstorage consumption, and construction time of RSATree are reported in\nthe ﬁrst three columns. Column “Schema” indicates the dimensions of\neach dataset that are used to build RSATree. The height of constructed\nR-tree, number of partitioned subspaces, and bin number of each cre-\nated SAT are shown in the last three columns. Deatails of the datasets\ncan be found in the supplementary material (Section 2).\n6.2 RSATree Construction\nWe show the effect on construction time, storage consumption, and\nresponse time through an example by using the SPLOM dataset [44].\nFig. 5 shows the results. We evaluate 10 different datasets. Fig. 5(a)(c)\nuse datasets with ﬁve dimensions, and the number of bins of each\ndimension set from 10 to 50. The number of bins of datasets used in\nFig. 5(d)(f) is 30, and the number of dimensions changes from 1 to\n5. We adjust the parameters to achieve accurate answers to queries,\nexcluding the inﬂuence of accuracy. The response time is the average\ntime to generate a heatmap that consists of two dimensions (the two\ndatasets with only one dimension use a one-dimensional heatmap). Ta-\nble 2 summarizes the relevant information in constructing an RSATree\nfor the datasets.\nFig. 5. Number of records and (a and d) storage consumption, (b and e)\nconstruction time, and (c and f) response time when creating an RSATree\nusing different SPLOM datasets. The dashed lines show the number of\npoints sampled for the progressive construction.\nThe growth of storage consumption and response time gradually de-\ncrease after the progressive construction starts, and remain unchanged\nwhen the number is larger than a certain number. This condition remark-\nably improves the efﬁciency of RSATree built on large-scale datasets.\nThe construction time nearly linearly increases with the number of\nrecords. However, a slight slow down can be observed after enter-\ning the progressive construction. The number of dimensions and bins\nconsiderably affect the storage consumption but not the construction\ntime. The response time is dependent on the number of bins because\nit directly affects the number of aggregated results. By contrast, the\nnumber of dimensions has little inﬂuence on response time.\nFig. 6. The growth of storage consumption and construction time when\ninserting records into RSATree for (a) Urban-POI, (b) Brightkite, and (c)\nFlight datasets.Fig. 6 presents the curves for construction time and storage consump-\ntion of three real-world datasets (urban-POI, brightkite, and ﬂight).\nUrban-POI is a small dataset that the progressive construction is not\ninvolved, while the curves for the other two datasets are similar to\nthose of SPLOM datasets. Fig. 7(a) shows that the construction times\nof RSATree are shorter than Nanocubes, especially on big datasets.\nStorage consumptions of RSATree, as shown in Fig. 7(b), are larger\n7\n\nTable 2. Information of experimental datasets and their associated RSATree representations. The numbers in parentheses on the “#Records” column\ndenote the sampling rates when using the progressive construction.\nName #Records Storage Time Schema Tree height #Sub-spaces #Bins\nsplom-10 1.0B (0.02) 1.3M 9:11m d1, d2, d3, d4, d5 2 100 10\nsplom-50 1.0B (0.02) 1.1G 10:55m d1, d2, d3, d4, d5 2 90 50\nbrightkite 4.5M (0.2) 7.8GB 63s lon, lat, weekday, hour, time 3 854 60\nﬂight 180 (0.05) 10.2G 3:48m Distance, LateAircraftDelay, CarrierDelay, year, month, weekday 5 934 60\ntaxi-yellow 1.5B (0.01) 4.9G 17:24m lon, lat, weekday, hour, time 6 1974 60\ntaxi-green 69M (0.02) 296.5M 54s lon, lat, weekday, hour, time 6 1945 60\nurban-poi 0.9M 10.4M <1s lon, lat 5 1346 60\nurban-gps 375M (0.01) 2.5G 5:10m lon, lat, time, speed, direction 6 1992 60\ndidi 1.5B (0.01) 1.4G 12:18m lon, lat, month, day, time 4 171 60\nFig. 7. Comparisons of (a) construction time and (b) storage consumption\nto Nanocubes. The x-axis is ordered by the record number of each\ndataset.\nthan Nanocubes on small datasets, but take up relatively less space on\nbig datasets. The exception is the Flight dataset, which may because of\na speciﬁc distribution [42]. We discuss this issue in Sect. 7.1.\n6.3 The Response Time\nIn summary, RSATree fulﬁlled the three design requirements in the\nuser study. The underlying data structure of RSATree can answer\narbitrary range queries. RSATree can achieve fast response speed and\nlow storage consumption during the query by using approximate queries\nand control the loss of accuracy to a reasonable range. The supported\nﬂexible binning strategies can provide a more efﬁcient exploration than\nonly using equi-width binning strategy.\nWe have asked 8 participants (all computer science students with\nknowledge of visual analysis) to explore three datasets using our proto-\ntype system and recorded the response time of queries. Three datasets\nrepresent three typical scenarios, namely, an individual heatmap, spa-\ntiotemporal analysis, and exploring by specifying custom charts. The\nparticipants are assigned speciﬁc tasks. The results of user study in\nsupplementary materials show that the response time can meet the\nrequirements for exploratory analysis, as shown in Table 3. Moreover,\nthe result of an objective questionnaire shows that supported ﬂexible\nbinning strategies can provide a more efﬁcient exploration than only\nusing equi-width binning strategy.\nWe also compare the performances with Nanocubes [42]. Because\nNanocubes is limited to spatial-temporal datasets, only the Brightkite\ndataset is tested in Nanocubes. Results show that the response time\nusing RSATree is weaker than Nanocubes, as a trade-off for ﬂexible bin-\nning. Another reason might be that our backend algorithms are run on a\nNodeJS server, which leads to lower performance than C++. Moreover,\nthere are opportunities for both inter- and intra-IH parallelization [30].\nTable 3. Statistics of response times over three datasets in microseconds\nstatistic/dataset urban-poi brightkite brightkite nanocubes ﬂight\ncount 426 1864 2024 6383\nmedian 266.86 222.39 31.27 28.21\nmean 267.14 223.25 38.28 28.75\nstdev 8.72 5.94 27.58 1.53\nmax 281.66 234.72 173.34 31.79\n90-percentile 273.21 230.37 69.88 30.82\nmean ARE 1.08% 8.05% \u0000 9.01%\nmean JSON size 882.0KB 732.3KB 506.8KB 68.2KB6.4 Performance-Accuracy Tradeoff\nAs discussed in Sect. 5.3, several factors, such as response time and ac-\ncuracy, may inﬂuence the query performance of RSATree. We analyze\nthe inﬂuences of R-tree height, LSH, and scale alignment with RSATree\nbuilt on the Urban-POI dataset. The Urban-POI dataset is part of the\nurban data collected from January 10 \u000031, 2014 in a city [61, 62, 72]. It\ncontains information on approximately 1 million POI locations. We use\ntheir longitudes and latitudes to build the RSATree. To show clearly\nhow data distribution can be captured and affect the performance of\nRSATree, we evaluate the response time and ARE rate of three regions\nwith different densities, that is, a global region with 933230 data points,\nRegion 1 with 133118 data points, and Region 2 with 8333 data points\n(Fig. 8(a)). For each region, experiments are performed by using LSH\nor R-tree search, which is returned at different heights, as well as the\nbaselines. We choose two different raw SAT structures as baselines,\nincluding one with very ﬁne granularity (S1) and the other with a\nsimilar size to RSATree whose tree height is 5 (S2). The scale align-\nment scheme is used in these experiments. The accuracy improvement\ncaused by the scale alignment scheme is then evaluated (Fig. 8(e-f)).\nStorage Consumption. Fig. 8(b) shows the relations between stor-\nage consumption and tree height. Moreover, it can be seen that the\nstorage consumption of S1 is much larger than RSATree and S2 has a\nsimilar storage consumption to RSATree.\nResponse Time. As shown in Fig. 8(c), querying on Region 1\nrequires more time than querying on the global region and Region\n2. This condition is probably because Region 1 has a higher average\ndensity and is partitioned into more subspaces to reach a higher query\naccuracy in comparison with the other two regions. Interestingly, raw\nSAT does not have the fastest response time for all the cases. The\nreason may be that the excessive storage space makes the system cache\nless efﬁcient.\nError Rate. Fig. 8(d) shows that the error rates of different regions\nare maintained at the same level. Thus, distribution-aware adaptive\ngranularity can balance the overall accuracy well. Queries using LSH\nhave the lowest response times but highest ARE rates. The response\ntime increases and ARE changes in the opposite direction with the\nincrease of the R-tree height. This condition satisﬁes expectations, in\nwhich the response time and accuracy can be balanced by selecting\nthe appropriate query parameters based on usage scenarios. S1 has the\nlowest ARE (less than 0.1%) at the expense of storage consumption.\nOn the other hand, S2 has relative high AREs, especially with the\nhighest ARE in Region 1. In contrast, RSATree can better balance the\ngranularities of different regions.\nScale Alignment. As shown in Fig. 8(e), the scale alignment scheme\nreduces more than 50% of ARE rates in all regions. Particularly, the\nARE rate of Region 1 is mostly reduced in comparison with the other re-\ngions, thereby verifying the effectiveness of the scale alignment scheme\non querying in dense regions. Scale alignment is effective because it\ncan make many computational grids that completely coincide with\nIH cells, thereby reducing the rounding operation during calculation\n(described in Sect. 4.3). Fig. 8(f) shows the rates of computational grids\nthat coincide with IH cells and does not require to be rounded. Scale\nalignment can eliminate many of the misalignments, especially in the\nregion with high density.\n8\n\n©2019 IEEE. This is the author’s version of the article that has been published in IEEE Transactions on Visualization and\nComputer Graphics. The ﬁnal version of this record is available at: 10.1109/TVCG.2019.2934800\nFig. 8. Applying RSATree in querying a heatmap of Urban-POI distribution in three regions. From left to right: Global region, Region 1 with high\ndensity, and Region 2 with low density. (a) Map view, (b) storage consumption, (c) Response time, and (d) ARE rates when using R-tree with different\nheights and LSH, as well as two raw SATs. The scale alignment scheme is used in (a-d). (e) ARE and (f) coincident rates of querying in an RSATree\nwith and without the scale alignment scheme.\n7 D ISCUSSIONS\n7.1 Technological Choices\nSpace Partitioning Algorithms. In addition to R-tree, many space\npartitioning algorithms, such as quadtree, k-d tree, and their variants\n(e.g., k-d-b tree) are used. R-tree ﬁts our requirements because it\ncan compactly partition the space into subspaces and discard empty\nsubspaces. We test k-d tree using the “median of the most spread\ndimension” splitting strategy. The cores of high-density regions are\nconstantly split from the middle when using k-d tree to partition the data\nspace. This process makes the generated subspaces to be irregularly\ndistributed, and a large number of data points gather in the corners of\nthe rectangular area. Meanwhile, k-d tree and quadtree are designed\nto contain the entire data space by leaving large subspaces partitioned\nin the marginal area of space. These problems make the use of His\ninefﬁciently because most data are gathered in a few cells. These\nproblems also tremendously increase the errors because the values of\nhigh-density regions are shared by empty spaces. By contrast, R-tree is\nﬂexible in selecting leaf nodes.\nSupporting Categorical Dimensions. Categorical dimensions can\nbe regarded as the numerical dimension, in which the only difference\nis that their values are discretely distributed across the entire domain.\nHowever, this dimension does not produce the desired effect. With the\nscale alignment scheme, we can take each category as a “scale”, which\nyields fair results when the number of categories is large ( >100). We\nprocess the categories as the dimensions of the IH when the number of\ncategories is small. Visual query requires to accumulate the results of\nall relevant categories after normal calculation. This process results in\nlow accuracy loss at a cost of an acceptable computational overhead.\nSampling for Progressive Construction. As described in\nSect. 4.2.4, RSATree use uniform sampling to select data points for\nconstructing the “skeleton” of the R-tree in the progressive construc-\ntion process. We choose uniform sampling because it has the best\nadaptability. Analysts do not need to have prior knowledge of the data\nbefore applying uniform sampling. Thus the whole preprocessing can\nbe completed automatically (only a sample rate is required). However,\nin some cases, uniform sampling shows its limitations. As shown in\nFig. 6 (c), the curve of inserted record number and storage consumption\nfor the Flight dataset does not perfrom like the SPLOM dataset (Fig. 5)\nand other real datasets (Fig. 6 (a) (b)). The storage consumption keeps\ngrowing fast after entering the progressive construction. The reason\nmay be that the uniform sampling fails to capture the data distribution\nwell. The same problem may occur when applying ﬁltering and group-\ning across multiple attributes. These operations may fundamentally\nchange the underlying data distributions observed, rendering the origi-\nnal approximation irrelevant. In these cases, a stratiﬁed sampling [2] or\nmachine learning [41] approach might be better.7.2 Limitations\nSimilar to regular data cubes, the memory consumption of RSATree\nincreases with the dimension. Although the distribution-aware parti-\ntioning of subspaces can alleviate the considerable increase to some\nextent, the effect in the case of high dimensions is not ideal due to the\nnature of R-tree. The effectiveness of R-tree will be affected by the\nsparsity of the data and the complexity of data distribution when it is\nused on high-dimensional data. Therefore, RSATree does not support\ndata with more than ﬁve dimensions well.\nR-tree is not perfect for all data and situations. Several complex data\ndistributions cannot be captured because R-tree divides the space into\northogonal subspaces. This issue can be avoided to a certain extent by\nﬁne binning of SAT. However, this process still results in storage over-\nhead, especially when the dimension is high. This may be addressed by\na tighter integration with the interaction design. Falcon [48] shows that\nthe dimensions of the required data cubes can be reduced to less than 3\nby initializing only the data cubes slices associated with the active view.\nThis can also enable a cold-start of exploration. Combining with such\nan interaction design may be a good solution, because R-tree performs\nbetter when the number of dimensions is lower.\nTo illustrate the capability of RSATree, we implement visual query\ninterfaces for spatial-temporal data (Fig. 1(a)) and visual speciﬁcation\n(Fig. 1(b)(c)), which are widely used [42, 44, 49]. However, our current\nimplementation does not fully utilize the beneﬁts of RSATree. We\nsuppose that RSATree has the potential to combine with more novel vi-\nsualizations and interactions for providing ﬂexible exploratory analysis.\nFor example, Sarvghad et al. [56] proposed an embedded interaction\ntechnique for ﬂexible adjusting of data bins, whose scalability can be\npowered by RSATree.\n8 C ONCLUSIONS AND FUTURE WORKS\nIn this study, we propose RSATree, which is a novel data representa-\ntion that supports efﬁcient web-based aggregate query for large-scale\ntabular datasets. An RSATree returns approximate answers to generate\ninstant visual feedback in interactive visualizations by reformulating,\nabstracting, and simplifying the input data into a nested three-level\nrepresentation. The advantages of an RSATree include: 1) answering\naggregate query of arbitrary ranges and 2) supporting ﬂexible binning\nstrategies; 3) moreover, its response time is low, and its storage cost is\nacceptable.\nSeveral directions can be investigated in future work. First, a better\npartition algorithm, such as deep learning models that can adapt to the\ndata distributions [37] may produce a better accuracy. Second, a mixed\nstorage mode that can separately handle outliers may be required. Third,\nwe plan to implement RSATree on GPU to improve its parallelism.\n9\n\nACKNOWLEDGMENTS\nWe wish to thank all the anonymous reviewers for their valuable com-\nments, and all the participants for their active participation. The work\nis supported by the National Science & Technology Fundamental Re-\nsources Investigation Program of China (2018FY10090002), the Na-\ntional Natural Science Foundation of China (61772456, 61761136020,\nU1609217,61672538, 61872388, 61872389).\nREFERENCES\n[1]S. Acharya, P. B. Gibbons, V . Poosala, and S. Ramaswamy. Join Synopses\nfor Approximate Query Answering. In ACM SIGMOD Record , vol. 28,\npp. 275–286. ACM, 1999.\n[2]S. Agarwal, B. Mozafari, A. Panda, H. Milner, S. Madden, and I. Stoica.\nBlinkdb: queries with bounded errors and bounded response times on\nvery large data. In Proceedings of the 8th ACM European Conference on\nComputer Systems , pp. 29–42. ACM, 2013.\n[3]C. Ahlberg. Spotﬁre: an Information Exploration Environment. ACM\nSIGMOD Record , 25(4):25–29, 1996.\n[4]H. Ahn, N. Mamoulis, and H. M. Wong. A Survey on Multidimensional\nAccess Methods. Technical report, Hong Kong University of Science and\nTechnology, 1997.\n[5]D. Barbar ´a and M. Sullivan. Quasi-Cubes: Exploiting approximations in\nmultidimensional databases. ACM SIGMOD Record , 26(3):12–17, 1997.\n[6]L. Battle, R. Chang, and M. Stonebraker. Dynamic Prefetching of Data\nTiles for Interactive Visualization. In Proceedings of the 2016 International\nConference on Management of Data , pp. 1363–1375. ACM, 2016.\n[7]N. Beckmann, H.-P. Kriegel, R. Schneider, and B. Seeger. The r*-tree:\nan efﬁcient and robust access method for points and rectangles. In Acm\nSigmod Record , vol. 19, pp. 322–331. Acm, 1990.\n[8]M. Behrisch, F. Korkmaz, L. Shao, and T. Schreck. Feedback-Driven\nInteractive Exploration of Large Multidimensional Data Supported by\nVisual Classiﬁer. In Visual Analytics Science and Technology (VAST),\n2014 IEEE Conference on , pp. 43–52. IEEE, 2014.\n[9]J. L. Bentley. Multidimensional Binary Search Trees in Database Ap-\nplications. IEEE Transactions on Software Engineering , (4):333–340,\n1979.\n[10] E. Bertini and G. Santucci. Give chance a chance: modeling density to\nenhance scatter plot quality through random data sampling. Information\nVisualization , 5(2):95–110, 2006.\n[11] M. Bostock, V . Ogievetsky, and J. Heer. D3Data-Driven Documents. IEEE\nTransactions on Visualization and Computer Graphics , 17(12):2301–2309,\n2011.\n[12] T. Catarci, M. F. Costabile, S. Levialdi, and C. Batini. Visual Query Sys-\ntems for Databases: A Survey. Journal of Visual Languages & Computing ,\n8(2):215–260, 1997.\n[13] K. Chakrabarti, M. Garofalakis, R. Rastogi, and K. Shim. Approximate\nquery processing using wavelets. The International Journal on Very Large\nData Bases , 10(2-3):199–223, 2001.\n[14] A. Chaudhuri, T. H. Wei, T. Y . Lee, H. W. Shen, and T. Peterka. Efﬁcient\nRange Distribution Query for Visualizing Scientiﬁc Data. In Visualization\nSymposium (PaciﬁcVis), 2014 IEEE Paciﬁc , pp. 201–208. IEEE, 2014.\n[15] S. Chaudhuri, G. Das, M. Datar, R. Motwani, and V . Narasayya. Over-\ncoming limitations of sampling for aggregation queries. In International\nConference on Data Engineering , pp. 534–542. IEEE, 2001.\n[16] S. Chaudhuri and U. Dayal. An Overview of Data Warehousing and OLAP\nTechnology. ACM Sigmod record , 26(1):65–74, 1997.\n[17] H. Chen, W. Chen, H. Mei, Z. Liu, K. Zhou, W. Chen, W. Gu, and K.-L.\nMa. Visual abstraction and exploration of multi-class scatterplots. IEEE\nTransactions on Visualization and Computer Graphics , 20(12):1683–1692,\n2014.\n[18] W. Chen, F. Guo, and F.-Y . Wang. A survey of trafﬁc data visualization.\nIEEE Transactions on Intelligent Transportation Systems , 16(6):2970–\n2984, 2015.\n[19] W. Chen, Z. Huang, F. Wu, M. Zhu, H. Guan, and R. Maciejewski. Vaud:\nA visual analysis approach for exploring spatio-temporal urban data. IEEE\nTransactions on Visualization and Computer Graphics , 24(9):2636–2648,\n2017.\n[20] F. C. Crow. Summed-Area Tables for Texture Mapping. In ACM SIG-\nGRAPH computer graphics , vol. 18, pp. 207–212. ACM, 1984.\n[21] M. Datar, N. Immorlica, P. Indyk, and V . S. Mirrokni. Locality-Sensitive\nHashing Scheme Based on p-Stable Distributions. In Proceedings of thetwentieth annual symposium on Computational geometry , pp. 253–262.\nACM, 2004.\n[22] M. Derthick, J. Kolojejchick, and S. F. Roth. An Interactive Visualization\nEnvironment for Data Exploration. In KDD , pp. 2–9, 1997.\n[23] J.-D. Fekete and R. Primet. Progressive analytics: A computation paradigm\nfor exploratory data analysis. arXiv preprint arXiv:1607.05162 , 2016.\n[24] D. Fisher, I. Popov, S. Drucker, et al. Trust Me, I’m Partially Right:\nIncremental Visualization Lets Analysts Explore Large Datasets Faster. In\nProceedings of the SIGCHI Conference on Human Factors in Computing\nSystems , pp. 1673–1682. ACM, 2012.\n[25] J. Gray, S. Chaudhuri, A. Bosworth, A. Layman, D. Reichart, M. Venka-\ntrao, F. Pellow, and H. Pirahesh. Data Cube: A Relational Aggregation\nOperator Generalizing Group-By, Cross-Tab, and Sub-Totals. Data mining\nand knowledge discovery , 1(1):29–53, 1997.\n[26] A. Guttman. R-trees: A Dynamic Index Structure for Spatial Searching.\nInProceedings of the 1984 ACM SIGMOD International Conference on\nManagement of Data , pp. 47–57. ACM, 1984.\n[27] C. G. Healey and B. M. Dennis. Interest Driven Navigation in Visual-\nization. IEEE Transactions on Visualization and Computer Graphics ,\n18(10):1744–1756, 2012.\n[28] J. Heer and B. Shneiderman. Interactive Dynamics for Visual Analysis.\nQueue , 10(2):30, 2012.\n[29] J. M. Hellerstein, P. J. Haas, and H. J. Wang. Online Aggregation. In Acm\nSigmod Record , vol. 26, pp. 171–182. ACM, 1997.\n[30] J. Hensley, T. Scheuermann, G. Coombe, M. Singh, and A. Lastra. Fast\nsummed-area table generation and its applications. In Computer Graphics\nForum , vol. 24, pp. 547–555. Wiley Online Library, 2005.\n[31] Z. Huang, Y . Lu, E. Mack, W. Chen, and R. Maciejewski. Exploring the\nsensitivity of choropleths under attribute uncertainty. IEEE Transactions\non Visualization and Computer Graphics , 2019.\n[32] C. Jermaine, A. Dobra, S. Arumugam, S. Joshi, and A. Pol. The Sort-\nMerge-Shrink Join. ACM Transactions on Database Systems (TODS) ,\n31(4):1382–1416, 2006.\n[33] S. Joshi and C. Jermaine. Materialized Sample Views for Database Ap-\nproximation. IEEE Transactions on Knowledge and Data Engineering ,\n20(3):337–351, 2008.\n[34] N. Kamat, P. Jayachandran, K. Tunga, and A. Nandi. Distributed and\ninteractive cube exploration. In Data Engineering (ICDE), 2014 IEEE\n30th International Conference on , pp. 472–483. IEEE, 2014.\n[35] S. Kandel, R. Parikh, A. Paepcke, J. M. Hellerstein, and J. Heer. Pro-\nﬁler: Integrated Statistical Analysis and Visualization for Data Quality\nAssessment. In Proceedings of the International Working Conference on\nAdvanced Visual Interfaces , pp. 547–554. ACM, 2012.\n[36] A. Kim, E. Blais, A. Parameswaran, P. Indyk, S. Madden, and R. Rubinfeld.\nRapid Sampling for Visualizations with Ordering Guarantees. Proceedings\nof the VLDB Endowment , 8(5):521–532, 2015.\n[37] T. Kraska, A. Beutel, E. H. Chi, J. Dean, and N. Polyzotis. The case\nfor learned index structures. In Proceedings of the 2018 International\nConference on Management of Data , SIGMOD ’18, pp. 489–504. ACM,\nNew York, NY , USA, 2018. doi: 10.1145/3183713.3196909\n[38] I. Lazaridis and S. Mehrotra. Progressive Approximate Aggregate Queries\nwith a Multi-Resolution Tree Structure. In ACM SIGMOD Record , vol. 30,\npp. 401–412. ACM, 2001.\n[39] T.-Y . Lee and H.-W. Shen. Efﬁcient Local Statistical Analysis via Integral\nHistograms with Discrete Wavelet Transform. IEEE Transactions on\nVisualization and Computer Graphics , 19(12):2693–2702, 2013.\n[40] D. Li, H. Mei, Y . Shen, S. Su, W. Zhang, J. Wang, M. Zu, and W. Chen.\nEcharts: A declarative framework for rapid construction of web-based\nvisualization. Visual Informatics , 2(2):136–146, 2018.\n[41] Q. Lin, W. Ke, J.-G. Lou, H. Zhang, K. Sui, Y . Xu, Z. Zhou, B. Qiao,\nand D. Zhang. BigIN4: Instant, Interactive Insight Identiﬁcation for\nMulti-Dimensional Big Data. In Proceedings of the 24th ACM SIGKDD\nInternational Conference on Knowledge Discovery & Data Mining , pp.\n547–555. ACM, 2018.\n[42] L. Lins, J. T. Klosowski, and C. Scheidegger. Nanocubes for Real-Time\nExploration of Spatiotemporal Datasets. IEEE Transactions on Visualiza-\ntion and Computer Graphics , 19(12):2456–2465, 2013.\n[43] Z. Liu and J. Heer. The Effects of Interactive Latency on Exploratory\nVisual Analysis. IEEE Transactions on Visualization and Computer Graph-\nics, 20(12):2122–2131, 2014.\n[44] Z. Liu, B. Jiang, and J. Heer. imMens: Real-time Visual Querying of Big\nData. In Computer Graphics Forum , vol. 32, pp. 421–430. Wiley Online\nLibrary, 2013.\n10\n\n©2019 IEEE. This is the author’s version of the article that has been published in IEEE Transactions on Visualization and\nComputer Graphics. The ﬁnal version of this record is available at: 10.1109/TVCG.2019.2934800\n[45] S. Martin and H.-W. Shen. Transformations for V olumetric Range Dis-\ntribution Queries. In Visualization Symposium (PaciﬁcVis), 2013 IEEE\nPaciﬁc , pp. 89–96. IEEE, 2013.\n[46] H. Mei, Y . Ma, Y . Wei, and W. Chen. The design space of construction\ntools for information visualization: A survey. Journal of Visual Languages\n& Computing , 44:120–132, 2018.\n[47] X. Mingliang, L. Pei, L. Mingyuan, F. Hao, Z. Hongling, Z. Bing, L. Yu-\nsong, and Z. Liwei. Medical image denoising by parallel non-local means.\nNeurocomputing , 195:117–122, 2016.\n[48] D. Moritz, B. Howe, and J. Heer. Falcon: Balancing interactive latency\nand resolution sensitivity for scalable linked visualizations. 2019.\n[49] C. A. Pahins, S. A. Stephens, C. Scheidegger, and J. L. Comba. Hashed-\ncubes: Simple, Low memory, Real-Time Visual Exploration of Big Data.\nIEEE Transactions on Visualization and Computer Graphics , 23(1):671–\n680, 2017.\n[50] Y . Park, M. Cafarella, and B. Mozafari. Visualization-Aware Sampling for\nVery Large Databases. In IEEE 32nd International Conference on Data\nEngineering (ICDE) , pp. 755–766. IEEE, 2016.\n[51] V . Poosala and V . Ganti. Fast Approximate Query Answering Using\nPrecomputed Statistics. In International Conference on Data Engineering ,\np. 252. IEEE, 1999.\n[52] F. Porikli. Integral Histogram: A Fast Way to Extract Histograms in\nCartesian Spaces. In IEEE Computer Society Conference on Computer\nVision and Pattern Recognition , vol. 1, pp. 829–836. IEEE, 2005.\n[53] S. Rahman, M. Aliakbarpour, H. K. Kong, E. Blais, K. Karahalios,\nA. Parameswaran, and R. Rubinﬁeld. I’ve Seen Enough: Incrementally\nImproving Visualizations to Support Rapid Decision Making. Proceedings\nof the VLDB Endowment , 10(11):1262–1273, 2017.\n[54] S. F. Roth, P. Lucas, J. A. Senn, C. C. Gomberg, M. B. Burks, P. J.\nStroffolino, A. Kolojechick, and C. Dunmire. Visage: a User Interface\nEnvironment for Exploring Information. In Information Visualization’96,\nProceedings IEEE Symposium on , pp. 3–12. IEEE, 1996.\n[55] H. Samet. The Quadtree and Related Hierarchical Data Structures. ACM\nComputing Surveys (CSUR) , 16(2):187–260, 1984.\n[56] A. Sarvghad, B. Saket, A. Endert, and N. Weibel. Embedded merge & split:\nVisual adjustment of data grouping. IEEE Transactions on Visualization\nand Computer Graphics , 25(1):800–809, 2018.\n[57] B. Shneiderman. Dynamic queries for visual information seeking. IEEE\nsoftware , 11(6):70–77, 1994.\n[58] C. Stolte, D. Tang, and P. Hanrahan. Polaris: A System for Query, Analy-\nsis, and Visualization of Multidimensional Relational Databases. IEEE\nTransactions on Visualization and Computer Graphics , 8(1):52–65, 2002.\n[59] J. W. Tukey. Exploratory Data Analysis . Reading, Mass., 1977.\n[60] M. Vartak, S. Rahman, S. Madden, A. Parameswaran, and N. Polyzotis.\nSEEDB: Efﬁcient Data-Driven Visualization Recommendations to support\nVisual Analytics. Proceedings of the VLDB Endowment , 8(13):2182–2193,\n2015.\n[61] F. Wang, W. Chen, Y . Zhao, T. Gu, S. Gao, and H. Bao. Adaptively explor-\ning population mobility patterns in ﬂow visualization. IEEE Transactions\non Intelligent Transportation Systems , 18(8):2250–2259, 2017.\n[62] X. Wang, T. Gu, X. Luo, X. Cai, T. Lao, W. Chen, Y . Wu, J. Yu, and\nW. Chen. A user study on the capability of three geo-based features in\nanalyzing and locating trajectories. IEEE Transactions on Intelligent\nTransportation Systems , 2018.\n[63] Z. Wang, N. Ferreira, Y . Wei, A. S. Bhaskar, and C. Scheidegger. Gaus-\nsian cubes: Real-time modeling for visual exploration of large multidi-\nmensional datasets. IEEE Transactions on Visualization and Computer\nGraphics , 23(1):681–690, 2017.\n[64] K. Wongsuphasawat, D. Moritz, A. Anand, J. Mackinlay, B. Howe, and\nJ. Heer. V oyager: Exploratory Analysis via Faceted Browsing of Visu-\nalization Recommendations. IEEE Transactions on Visualization and\nComputer Graphics , 22(1):649–658, 2016.\n[65] J. Xia, G. Jiang, Y . Zhang, R. Li, and W. Chen. Visual subspace clustering\nbased on dimension relevance. Journal of Visual Languages & Computing ,\n41:79–88, 2017.\n[66] J. Xia, F. Ye, W. Chen, Y . Wang, W. Chen, Y . Ma, and A. K. Tung.\nLdsscanner: exploratory analysis of low-dimensional structures in high-\ndimensional datasets. IEEE transactions on visualization and computer\ngraphics , 24(1):236–245, 2017.\n[67] M. Xu, H. Wang, S. Chu, Y . Gan, X. Jiang, Y . Li, and B. Zhou. Trafﬁc sim-\nulation and visual veriﬁcation in smog. ACM Transactions on Intelligent\nSystems and Technology (TIST) , 10(1):3, 2018.\n[68] M. Xu, Y . Wu, Y . Ye, I. Farkas, H. Jiang, and Z. Deng. Collective crowdformation transform with mutual information–based runtime feedback.\nInComputer Graphics Forum , vol. 34, pp. 60–73. Wiley Online Library,\n2015.\n[69] E. Zgraggen, A. Galakatos, A. Crotty, J.-D. Fekete, and T. Kraska. How\nprogressive visualizations affect exploratory analysis. IEEE Transactions\non Visualization & Computer Graphics , (8):1977–1987, 2017.\n[70] Y . Zhao, F. Luo, M. Chen, Y . Wang, J. Xia, F. Zhou, Y . Wang, Y . Chen, and\nW. Chen. Evaluating multi-dimensional visualizations for understanding\nfuzzy clusters. IEEE transactions on visualization and computer graphics ,\n25(1):12–21, 2018.\n[71] Z. Zhou, L. Meng, C. Tang, Y . Zhao, Z. Guo, M. Hu, and W. Chen. Visual\nabstraction of large scale geospatial origin-destination movement data.\nIEEE Transactions on Visualization and Computer Graphics , 25(1):43–53,\n2018.\n[72] M. Zhu, W. Chen, J. Xia, Y . Ma, Y . Zhang, Y . Luo, Z. Huang, and L. Liu.\nLocation2vec: a situation-aware representation for visual exploration of\nurban locations. IEEE Transactions on Intelligent Transportation Systems ,\n2019.\n11",
  "textLength": 80171
}