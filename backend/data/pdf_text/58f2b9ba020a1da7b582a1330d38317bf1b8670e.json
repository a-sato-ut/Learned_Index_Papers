{
  "paperId": "58f2b9ba020a1da7b582a1330d38317bf1b8670e",
  "title": "FeCBF: A Novel Sub-Optimal Cascaded Bloom Filter Structure Based on Feature Extraction",
  "pdfPath": "58f2b9ba020a1da7b582a1330d38317bf1b8670e.pdf",
  "text": " \nVOLUME XX, 20 24 1 \nDate of publication xxxx 00, 0000, date of current version xxxx 00, 0000.  \nDigital Object Identifier 10.1109/ACCESS.20 24.Doi Number  \nFeCBF: A Novel Sub -Optimal Cascaded Bloom Filter Structure \nBased On Feature Extraction  \nQuang -Manh Duong1, Khoa -Sang Nguyen1, Hai-Duong Nguyen1, Xuan -Uoc Dao1, Anh-Tuan \nDo2, Senior Member, IEEE , Quang -Kien Trinh1, Member, IEEE  \n1Faculty of Radio -Electronic  Engineering , Le Quy Don Technical University, Vietnam  \n2Institute of Microelectronics, A*STAR , Singapore  \nCorresponding author: Quang -Kien Trinh (e -mail: kien.trinh@lqdtu.edu.vn).  \n \nABSTRACT  This work proposes an efficient probabilistic data structure by cascading multiple Bloom filters \nin an optimum sequence to form a Feature extraction Cascaded Bloo m Filter (FeCBF).  Furthermore, \nalternating  FeCBF's positive and negative filter layers could effectively suppress False Positive /Negative \nRates  (FPR/FNR), allowing  exact filtering with reasonable resource cost. Compared to other  representative \nstate-of-the-art designs on the same experimental dataset, Fe CBF could save memory space from 4 5% to 76% \nwhile still achieving the best FPR in the class. In addition, a closed -form expression for the proposed model \nhas been deployed to determine the sub -optimal Fe CBF configuration based on the desired filter performance \nmetrics , which can be useful for  automatic design flow.  The proposed architecture of  FeCBF  is targeted for \nhardware implementation . It is readily deployed as the accelerator in many computing  problems , such as \nmassive content filtering, network traffic filtering, and online mal ware /virus detection.  \nINDEX TERMS  Bloom filter, Feature extraction, Pattern matching,  Big-data filter,  Probabilistic filter, \nHardware acceleration . \nI. INTRODUCTION  \nBloom filter (BF), first proposed by Burton Howard \nBloom [1], is a simple data structure that is efficient in terms \nof time and memory consumption in checking an element â€™s \nmembership with an acceptable accuracy trade -off. In [1], \nBF is  ï¬rst described  as a compact probabilistic data structure \nrepresenting  words in a dictionary. Due to the lack of \ntechnological availability, there was little interest in using \nBFs for networking until 1995, after which this area gained \nwidespread interest in academia and industry. BF is a well -\nknown hash data structure for a pproximate ï¬ltering with a \nmodest memory space.  \nIn recent years, BFs and their variants have been widely \nused in applications related to networking (routing [2], Named \nData Networking [3], network security [4]), database \n(duplicate detection [5], content synchronization [6]), and \nbiometric identification [7]. Today, BFs appear in popular \nbrowsers like Microsoft Bing and Google Chrome. Microsoft \nBing search engine uses multilevel hierarchical BFs for the \nBitFunnel search index [8], which provides a lower cost than \nthe previous Bing search index. Google Chrome \npreliminarily identifies malicious URLs using the local BF  \n[9]. Most recently, in the context of the  widespread \nCoronavirus on a global scale, a BF solution was used to \ndetect and warn users about close contact with suspected infected individuals [10], achiev ing almost zero ğ¹ğ‘ƒğ‘…  (~10-15) \nwith a reasonably small memory cost.  \nIn the previous study [11], we used a co-design platform: \na software -based BF using Python language and a hardware -\nbased BF using FPGA. Our co -design platform works based \non extracting features from input data, thereby designing the \nsubsequence filter layers to achieve a lower error rate than \nthe conventional standard BF. However, the BF solutions \npublished in [11] are still limited in specific configurations \nand exhibit only moderate error rate improvement. This  work \nsignificantly extends  our study  in [11], aiming for a more \ngeneral and effective  filter design methodology that could fit \na wide range of real-world data filtering problems. The main \ncontributions of this study are summarized as follows.  \nâ€¢ A novel architecture of a high -precision Bloom -based \nfilter constructed by  cascading data-dependent  \nsubfilter s that is capable of aggressively  suppressing  the \nmisclassification with significant resource -saving ;  \nâ€¢ A complete design methodology based on a close d-form  \nanalytical model to  predict and  locate the sub -optimal \nsolutions for  the proposed BF design under specific \nboundary constraints.   \nThe rest of this work is as follows. Section II introduces \nthe background of BF and related works. Section III presents \na novel concept of the FeCBF structure and  its design flow  \nbased on a sub -optimal analytical design model  that gives  This article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and \ncontent may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2024.3399062\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\n\n Quang -Manh Duong et al. : FeCBF: A Novel Sub -Optimal Cascaded \nBloom Filter Structure Based On Feature Extraction  \n2  VOLUME XX, 20 24 \n10000010100001001000001001000001n  = 3\nm = 32 \nk  = 3 \nTrue Positive True NegativeMember\nH1ADDING\nQUERYINGH2H3a2 a1 a3\nq1 q2Member Member\n0 1 2 3 4 5 7 8 910 11 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 6 12H1\nH2H3H1 H3\nH2\nH1H2\nH3 H1 H3H2\nH1 H3H2\nFalse Positiveq3 \nFIGURE 1.   An example of the standard BF with two basic operations: \nadding and querying.  \ninsights  into the relationship and trade -off between the major  \nFeCBF design and performance metrics . Section IV \npractically  verif ies the FeCBF analytical design model. \nSection V  discusses the efficiency and performance of the \nsub-optimal  FeCBF compared to other prior -arts Bloom -based  \nfilters. Section V I concludes this study .    \nII.  PRELIMINARY  \nA.  BACKGROUND OF BLOOM FILTER  \nA BF compose s a member set {ğ‘1,ğ‘2,...,ğ‘ğ‘›}, a hash \nfunction set {â„1,â„2,â€¦,â„ğ‘˜}, and an array of ğ‘š-bit elements  \ninitialized with all '0'. In the BF construction phase, for \nadding a member ğ‘ğ‘– to BF, the set of ğ‘˜ hash functions is used \nto calculate ğ‘˜ addresses {â„1(ğ‘ğ‘–),ğ‘—=1,ğ‘˜Ì…Ì…Ì…Ì…Ì…Ì…} and write values \n'1' into corresponding memory cells in the  ğ‘š-bit array . In \nworking  mode  (querying), an element ğ‘ğ‘– belong s to the \nconstructed filter only if all memory cells corresponding to \nthe ğ‘ğ‘–-hashed addresses are stored values '1'. Examples of \nadding and querying operations  are illustrated  in Fig. 1 . \nAssuming the BF size ğ‘š = 32  bits, the number of member \nelements ğ‘› = 3, and the number of hash functions ğ‘˜ = 3. The \nelements ğ‘1, ğ‘2, and ğ‘3 after the Adding are represented by \nthe triples of '1' bits at addresses (0, 6, 13) , (8, 16, 22), and \n(16, 25, 31), respectively. In the querying, BF uses three hash \nfunctions to determine  three corresponding  addresses for  the \nquery elements  ğ‘1,  ğ‘2 , and ğ‘3 in the ğ‘š-bit array. Element ğ‘1 \nis a case of \"True Positive ,\" in which all the cells of BF that \ncorrespond to this element are '1'. Element ğ‘2 corresponds to \n\"True Negative \" when at least one contains a '0' bit. \nElement ğ‘3 is \"False Positive ,\" where all the cells \ncorresponding to this element are '1' but intrinsically  ğ‘3 does \nnot match any element in member set. A standard BF (SBF)  \nof finite size may have a non -zero False Positive  Rate (ğ¹ğ‘ƒğ‘… ), \nbut does not allow False Negative  Rate (ğ¹ğ‘ğ‘…=0), i.e., a \nquery returns  either \"element is possibly in BF \" or \"element \nis truly not in BF \" result s.  \nWhen the size ğ‘š is large enough, the theoretical ğ¹ğ‘ƒğ‘…  \n(ğ¹ğ‘ƒğ‘…ğ‘¡â„ğ‘’ğ‘œ) is approximately calculated by the following \nequation . \nğ¹ğ‘ƒğ‘…ğ‘¡â„ğ‘’ğ‘œâ‰ˆ(1âˆ’ğ‘’âˆ’ğ‘˜âˆ™ğ‘›/ğ‘š)ğ‘˜ (1) \nGiven ğ‘› and ğ‘š, the optimal number of hash functions ğ‘˜ğ‘œğ‘ğ‘¡ \nto achieve the minimum value of ğ¹ğ‘ƒğ‘…ğ‘¡â„ğ‘’ğ‘œ is determined by \nthe following equation . ğ‘˜ğ‘œğ‘ğ‘¡=ğ‘š\nğ‘›ğ‘™ğ‘›2â‰ˆ0.6931ğ‘š\nğ‘› (2), \nwhere the minimum ğ¹ğ‘ƒğ‘…ğ‘¡â„ğ‘’ğ‘œ corresponding to the optimal \nvalue ğ‘˜ğ‘œğ‘ğ‘¡ in (2) is calculated by the following equation . \nğ¹ğ‘ƒğ‘…ğ‘¡â„ğ‘’ğ‘œ=(1\n2)ğ‘˜ğ‘œğ‘ğ‘¡\nâ‰ˆ0.6185ğ‘š/ğ‘› (3) \nThe number of bits ğ‘š of the SBF that responds to the given \nelement number of member set ğ‘› and the specific target value \nğ¹ğ‘ƒğ‘…ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡  is calculated by  the following equation . \nğ‘š=âˆ’ğ‘›âˆ™ln (ğ¹ğ‘ƒğ‘…ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡)\n(ğ‘™ğ‘›2)2 (4) \nIn an example illustrating  (4), to ensure that the ğ¹ğ‘ƒğ‘…ğ‘¡â„ğ‘’ğ‘œ \nis not more than 1%, using the optimal number of hash \nfunctions ğ‘˜ğ‘œğ‘ğ‘¡, the average number of bit s per BF member \nhas to be approximately 9.6. Depending on the problems and \npriority design criteria, the fundamental design parameters \n(ğ‘›, ğ‘š, ğ‘˜, ğ¹ğ‘ƒğ‘…ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡ ) must be  appropriately adjusted and  \ncompromised accordingly . \nB.  RELATED WORKS  \nIn the following, we summarize some recent studies on BF \ndesign , categorized by optimization method, including has h \noptimization, applying Machine Learning  (ML)  techniques, and \nfilter structure  modification .  \nSeveral interesting hash optimization methods have been \nproposed in [12], [13], and [14]. Mitzenmacher et al. [12] \nproposed employing two or more independent groups of hash \nfunction s (HF)  for adding and querying operations,  thus \nreducing the ğ¹ğ‘ƒğ‘…  by 43.5%  compared to SBF. Hao et al. [13] \nproposed a partitioned hashing approach by dividi ng the \nmember set into disjoint subsets and using different \nappropriate combinations of HFs for each of them. Unlike \nthe approach in [12], where each query has to use all groups \nof HFs, in [13], each query incurs one additional hash \noperation compared to the SBF. By carefully partitioning the \nmember elements and selecting combinations of HFs, the fill \nfactor of the '1' bits in [13] is reduced, thus reducing the ğ¹ğ‘ƒğ‘…  \nby 54.6%  compared to  that of SBF.  However, solutions in \n[12] and [13] have  high computational  complexity and a lack \nof flexibility in response to c hanges in the BF member set. \nRecently, Xie  et al.  [14] proposed a BF approach that \nsupports the customization of HFs for positive elements in \nthe two -round membership query with customized HFs stored \nin an additional hash table . Compared to the s olutions \nproposed in [12] and [13], the solution in [14] achieves a \nsignificant improvement in ğ¹ğ‘ƒğ‘…  so this model  will be selected \nas the representative of the HF optimization method for  \nfurther  comparison in our work .  \nBased on the optimization method using ML techniques, \nKraska et al. [15] have shown that c ombining ML techniques \ncan improve index structures and related structures such as   \nBFs. The first proposed ML technique is Learned BF  (LBF),  \nwhich comprises a classifier block of Learning functions  This article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and \ncontent may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2024.3399062\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\n\n  Quang -Manh Duong et al. : FeCBF: A Novel Sub -Optimal Cascaded \nBloom Filter Structure Based On Feature Extraction  \nVOLUME XX, 20 24 3 \nserving as the pre -filter  and a backup BF playing the role of \nthe post -filter. If the classification score of a query element \ndetermined by the pre -filter is higher than a threshold level, \nthe element is treated as a member ; otherwise , the element is \nqueried by the post -filter, thereby reducing the number of \nhash operations. The LBF model proposed by Kraska [15] \nserves as  the foundation design for the subsequent  proposed  \nvariants of the LBF. Mitzenmacher et al. [16] are the first to \npropose a reasonably  accurate math ematical model for \nevaluating the effectiveness of the LBF. Furthermore, the \nauthors proposed an enhanced model for LBF , namely \n\"Sandwiched LBF ,\" in which an initial BF is added before \nthe classifier BF and the backup filter. Dai et al. [17] then \nproposed  the \"Adaptive LBF ,\" in which the classifier BF \ndivides the input data into more than two groups, which \npermits the HFs for each group to be adapted  and optimized \nto specific contexts. In [14], Xie et al. independently \nevaluated the Sandwiched LBF and Adaptive LBF models. \nThey showed surprising results where the Adaptive LBF \nmodel exhibited the worst classification accuracy compared \nto all other designs, i.e.,  LBF,  Sandwiched LBF,  and even \nSBF. Also , from that study, the Sandwiched structure  [16] \nwas proven the best and was selected as a representative LBF \nfor comparison  in this work . \nChazelle et al. [18] proposed modifying  the SBF structure  \ncalled the Bloomier filter. Dietzfelbinger et al.  [19] described  \na modifi ed Bloomier filter that could respond to approximate  \nmembership queries. Graf et al.  [20] further proposed an \nimplementation solution of the approach in [19], which they \nnamed the Xor filter and announced that such type of filter \ncould be faster than SBF with more minor  memory utilization . \nXor filter [20] represents  a BF variation used for comparison.   \nIII.  FeCBF GENERIC DESIGN  \nOur proposed FeCBF is inspired by the â€œFeature extractionâ€ \nidea introduced by [1]  and further improved in this study. The \nterm \"Feature extraction \" could be understood as the design \nof subsequent filter layers considering the characteristics of \nthe previous filter layers. The characteristic extraction \nrequires intensive computing power, but as we will show, it \nis feasible and can be done at a reasona ble time cost using \nmodern computing devices. In particular, based on the design \nmethodology and error prediction model presented in this \nstudy, FeCBF could be tuned to achieve the target error rate \nwith sub -optimum cost in resources.  \nThe design of the proposed FeCBF structure includes  \nan Extraction phase and a Tuning phase, as depicted in  \nFig. 2 . The FeCBF consists of three  cascaded filter layers : \nFEBF  (Feature extraction BF), FPBF ( False Positive  BF) and  \nFNBF ( False Negative  BF), each filter layer is designed \nreversely to the previous layer. For example, suppose the first \nFEBF filter layer causes False Positive elements, so the next \nfilter layer should ideally suppress these unexpected elements  \nbut, on the other hand, generat e False Negative elements.  \nTo proceed in such a way, the following filter layer collects \n(maximumly possible) the erroneously filtered elements of  FIGURE 2.  The generic structure of FeCBF includes 1st layer of BF for \nFeature extraction (FEBF), 2nd layer of  BF for False Positive  suppression  \n(FPBF), and 3rd layer of BF for False Negative  suppression (FNBF).  \nthe previous filter layer as its own member set. Thus, the \nnumber of input elements and False Positive /False Negative  \nratio will decrease exponentially as the number of layers \nincreases, and the filter  will also rapidly  shrink in size  at the \nsubsequent  layers.  Many  FeCBF filter layers may be needed \nto eliminate all the filtering errors . However, due to the  actual \nrapid d eterioration of the error rate and filter size , our surveys \nreveal that the filter model consisting of three layers with a \npre-filter layer and two filter layers for False Positive  and \nFalse Negative  suppression could  accommodate  most \nscenarios without cau sing extra lookup latency .  \nIn the descriptions below, we use the following notations: \nğ¼ğµğ¹, ğ‘ğµğ¹ are the input set and  the member set of a filter; ğ‘‡ğ‘ƒğµğ¹, \nğ¹ğ‘ƒğµğ¹, ğ‘‡ğ‘ğµğ¹ are the set s of True Positive , False Positive  \n(if any), and False Negative  (if any) elements of the filter, \nrespectively;  function ğ‘ (ğ‘‡) return s the number of elements \nof the set T.  In the specific case of FeCBF, assum ing that \nFeCBF has the member set ğ‘ğ¹ğ‘’ğ¶ğµğ¹  with ğ‘ (ğ‘ğ¹ğ‘’ğ¶ğµğ¹)=ğ‘›ğ‘– \nand the input set ğ¼ğ¹ğ‘’ğ¶ğµğ¹  that does not include ğ‘ğ¹ğ‘’ğ¶ğµğ¹  with  \nğ‘ (ğ¼ğ¹ğ‘’ğ¶ğµğ¹)= Ï‡ . ğ‘›ğ‘–, typically ğœ’ â‰« 1. The query elements are \nğ¿ bit vectors. For example, if the member set has ğ‘›ğ‘–=1 \nmillion elements , and the input covers the space of data \nstrings ğ¿ = 32 bits , then ğœ’ = (232âˆ’106)/106â‰ˆ4294 . \nA. EXTRACTION PHASE  \nAs shown in Fig. 2 , the Extract ion phase uses an SBF with  \nmember set ğ‘ğ¹ğ¸ğµğ¹=ğ‘ğ¹ğ‘’ğ¶ğµğ¹ and performs query  operations  \nof the input space ğ¼ğ¹ğ¸ğµğ¹=ğ¼ğ¹ğ‘’ğ¶ğµğ¹ to capture the majority of  \nFEBF â€™s False Positive  elements in the ğ¹ğ‘ƒğ¹ğ¸ğµğ¹  set. This set \nreflects the unique relationship with the member set ğ‘ğ¹ğ¸ğµğ¹, \nthe input space ğ¼ğ¹ğ¸ğµğ¹ , the filter size ğ‘š, and the hash type \nğ»ğ‘¡ğ‘¦ğ‘ğ‘’  of FEBF . In other words, ğ¹ğ‘ƒğ¹ğ¸ğµğ¹  could be considere d \nas a \"Feature set \" of FEBF  with the ğ‘ğ¹ğ¸ğµğ¹ member set in \nresponse to the ğ¼ğ¹ğ‘’ğ¶ğµğ¹  input set . ğ¹ğ‘ƒğ¹ğ¸ğµğ¹   hence bears the \ncharacteristic of the first filter layer results, any changes to \nthe input and structure of FEBF  will immediately reflect on \nthe ğ¹ğ‘ƒğ¹ğ¸ğµğ¹ . Because  FEBF  is the  very first filter layer, it can \nbe chosen solely based on available allocated resource  \n(i.e., memory). The theoretical error rates  of this filter layer  \nare calculated as follows .  \n{ğ¹ğ‘ƒğ‘…1ğ‘™ğ‘ğ‘¦ğ‘’ğ‘Ÿ=ğ¹ğ‘ƒğ‘…ğ¹ğ¸ğµğ¹=ğ‘ (ğ¹ğ‘ƒğ¹ğ¸ğµğ¹)\nğ‘ (ğ¼ğ¹ğ‘’ğ¶ğµğ¹) =ğ‘›ğ‘\nğœ’âˆ™ğ‘›ğ‘– \n ğ¹ğ‘ğ‘…1ğ‘™ğ‘ğ‘¦ğ‘’ğ‘Ÿ=ğ¹ğ‘ğ‘…ğ¹ğ¸ğµğ¹=0                                    (5), \nwhere ğ‘›ğ‘= ğ‘ (ğ¹ğ‘ƒğ¹ğ¸ğµğ¹) is the number of  False Positive  \nelements  at the first FeCBF â€™s filter layer . \nFP extraction FP suppression FN suppressionFeature extraction\nFPBF\n FNBF\nFEBF\nOutput\nnoDesign tuning\nnini\nnpnp\nnpnn\nnnnn\nmembers members membersInput1st Layer 2nd Layer 3rd LayerThis article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and \ncontent may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2024.3399062\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\n\n Quang -Manh Duong et al. : FeCBF: A Novel Sub -Optimal Cascaded \nBloom Filter Structure Based On Feature Extraction  \n4  VOLUME XX, 20 24 \nB. TUNING PHASE  \nThe Tuning phase is performed after the Extraction phase. \nIt will  be based on the extracted information from the input \nspace  of FEBF  to select appropriate design parameters for \nsubsequent filters FPBF and FNBF to achieve maximum \nfiltering efficiency . At this point, the design of FPBF and \nFNBF has to consider the results of the previous extraction \nphase for the best optimization rather than a random structure.  \nThis phase is divided into the following two substeps .  \n1)  FALSE POSITIVE  SUPPRESSION  STEP  \nThis filtering step is performed by the FPBF, also known \nas the inverting filter , because it allows FEBF â€™s False Positive  \nelements to pass through but block s the members of FEBF . \nThe input to this filter includes the elements that pass through \nFEBF , i.e., the member set ğ‘ğ¹ğ¸ğµğ¹, and the False Positive \nelement  set ğ¹ğ‘ƒğ¹ğ¸ğµğ¹  of the previous filter layer.  In this way, \nthe queried elem ents that first pass through FEBF  and again \npass through FPBF have a high probability of being  present \nin the set ğ¹ğ‘ƒğ¹ğ¸ğµğ¹ . If ğ¹ğ‘ƒğ¹ğ¸ğµğ¹  is fully defined and FPBF is  an \nideal filter, then all False Positive  elements  of FEBF  (so is \nFeCBF ) would be theoretically identified and , hence, be \nblocked at this layer . On the other hand, t he element that \npasses FEBF  but could not pass FPBF , under that  ideal \nassumption , belong s to ğ‘ğ¹ğ‘’ğ¶ğµğ¹ . \nHowever, the imperfection of FPBF leads to the \nphenomenon that a small proportion of True Positive  \nelements coming from the  ğ‘ğ¹ğ¸ğµğ¹ member set can pass \nthrough FPBF as the False Positive  element s of this subfilter . \nThese elements are classified as  False Negative s of FeCBF. \nAdditionally, in c ases where 100% of the elements in the \nğ¹ğ‘ƒğ¹ğ¸ğµğ¹  set cannot be identified, the possibility of  FEBF â€™s \nFalse Positive  elements still exists, although this possibility \nis very low. The theoretical error rates at the output of  the \nsecond  filter  layer are calculated as follows.    \n{ğ¹ğ‘ğ‘…2ğ‘™ğ‘ğ‘¦ğ‘’ğ‘Ÿğ‘ =ğ‘ (ğ¹ğ‘ƒğ¹ğ‘ƒğµğ¹)\nğ‘ (ğ¼ğ¹ğ‘’ğ¶ğµğ¹) =ğ‘›ğ‘›\nğœ’âˆ™ğ‘›ğ‘– \n ğ¹ğ‘ƒğ‘…2ğ‘™ğ‘ğ‘¦ğ‘’ğ‘Ÿğ‘ â‰…ğ¹ğ‘ğ‘…ğ¹ğ‘ƒğµğ¹=0             (6), \nwhere ğ‘›ğ‘›=ğ‘ (ğ¹ğ‘ƒğ¹ğ‘ƒğµğ¹) is the number of FPBFâ€™s False \nPositive  elements.   \nEquation  (6) shows that eliminating FeCBFâ€™s False Positive  \nelements by the two filter layers , FEBF and FPBF,  is feasible \nat the cost of generating  FeCBFâ€™s False Negative  elements.  \nHowever,  considering tha t the input set of FPBF has been \nlargely suppressed after the first filter layer, it can be predicted \nthat FPBF will not consume as much  memory as FEBF . \n2)  FALSE NEGATIVE  SUPPRESSION  STEP  \nFalse Negative  elements after  the second  filter  layer are \nthe source of 2-layer FeCBFâ€™s filtering error and could be \nrelative ly small  but can become undesirable for some \nspecific applications. Therefore, we propose to use a third \nfilter layer called FNBF to remove those . \nThe input to the third layer filter FNBF consists of the \nmember set ğ‘ğ¹ğ‘ƒğµğ¹  of the second layer FPBF , where  \nğ‘ (ğ‘ğ¹ğ‘ƒğµğ¹)=ğ‘ (ğ¹ğ‘ƒğ¹ğ¸ğµğ¹)= ğ‘›ğ‘ and the False Positive  set \nğ¹ğ‘ƒğ¹ğ‘ƒğµğ¹  of this second layer FPBF, where ğ‘ (ğ¹ğ‘ƒğ¹ğ‘ƒğµğ¹)=ğ‘›ğ‘›. If we use ğ‘›ğ‘› elements of ğ¹ğ‘ƒğ¹ğ‘ƒğµğ¹  as the member set of the \nthird layer FNBF, we could , similarly,  almost remove those  \nFalse Negative  elements  of FeCBF. As a result , the alternate \nuse of False Positive  (FPBF) and False Negative  (FNBF)  \nsubfilters  in the FeCBF structure  can substantially remove \nunwanted elements at the final output . However, a similar \neffect occurs due to the imperfection of FNBF  that leads to \nfalse  identification of some elements belonging to ğ¹ğ‘ƒğ¹ğ¸ğµğ¹  \nand causing False Positiv e elements  of FNBF  itself . The \nfalse identification rate at this step is theoretically very small  \nbecause the number of FNBFâ€™s input and member elements  \nhas been significant ly reduced  compared to the FeCBF â€™s \ninput elements . The error  rates at the output of the third  filter \nlayer are expressed as  follows . \n{ğ¹ğ‘ƒğ‘…3ğ‘™ğ‘ğ‘¦ğ‘’ğ‘Ÿğ‘ =ğ‘ (ğ¹ğ‘ƒğ¹ğ‘ğµğ¹)\nğ‘ (ğ¼ğ¹ğ‘’ğ¶ğµğ¹) =ğ‘›ğ‘œ\nğœ’âˆ™ğ‘›ğ‘– \nğ¹ğ‘ğ‘…3ğ‘™ğ‘ğ‘¦ğ‘’ğ‘Ÿğ‘ â‰…ğ¹ğ‘ƒğ‘…ğ¹ğ‘ƒğµğ¹=0             (7), \nwhere ğ‘›ğ‘œ=ğ‘ (ğ¹ğ‘ƒğ¹ğ‘ğµğ¹) is the number of F NBFâ€™s False Positive  \nelements  and the output False Positive  elements  of FeCBF.  \nIn the 3 -layer FeCBF structure, it is worth noting that  the \ninput and  member set s of the last filter layer FNBF are \nexpected to be very small ; hence , this filter layer will \nconsume  an insignificant  amount of resources and could be \naggressively optimized for suppressing  the final error rate.  \nC. WORKING MODE  \nTo ensure normal operations, each FeCBFâ€™s subfilter  is \ndesigned with four basic  ports : a QI input  port that receives \nany query element ğ‘ğ‘¥; an EN (E NABLE ) port that allows \nfilters to operate ; a QR (Query Result) port to return the \nquery result of the ğ‘ğ‘¥ (QR = '0'/'1'  indicates ğ‘ğ‘¥ not \nbelong/belong to filter member set),  and a Q O output port is \ndesigned to forward the query element ğ‘ğ‘¥ to the next filter \nlayer in case QR = '1'. The QR signals from the filter layers , \nspecifically  QR FEBF, QR FPBF , and QR FNBF, are used as input \ndata for the Decision circuit to synthesize  the final qu ery \nresult of ğ‘ğ‘¥ through the Match signal (i.e. , QR FeCBF ). QR FeCBF  \nequals  '0'/'1' , which means that ğ‘ğ‘¥ is not present /present  in \nğ‘ğ¹ğ‘’ğ¶ğµğ¹   member set.  \nTable I  lists the results of all possible query cases for the \ninput element ğ‘ğ‘¥ by the 3 -layer FeCBF filter structure. \nColumn 1 is the ground truth information about the presence \nof ğ‘ğ‘¥ in the ğ‘ğ¹ğ‘’ğ¶ğµğ¹  member set, and columns 2 -5 list the \nquery  results of t he subfilters and FeCBF , respectively. \nColumn 6 describes whether the query results are True or  False  \nabout the presence (Positive) or absence (Negative) of ğ‘ğ‘¥ \nbased on complete information. FeCBF does not know in \nadvance about the existence of ğ‘ğ‘¥ in the member set and can \nonly conclude as accurately as possible based on query \ninformation from all subfilters (columns 2 -4). For example, \nFeCBF can cause a False Positive  query result (see column 6  \n- row 3), i.e.,  ğ‘ğ‘¥ is not in the ğ‘ğ¹ğ‘’ğ¶ğµğ¹  member set, but the \nMatch signal QR FeCBF  = '1', where the  corresponding ğ¹ğ‘ƒğ‘…  is \ncalculated according to (7).  This article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and \ncontent may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2024.3399062\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\n\n  Quang -Manh Duong et al. : FeCBF: A Novel Sub -Optimal Cascaded \nBloom Filter Structure Based On Feature Extraction  \nVOLUME XX, 20 24 5 \nTABLE  I \nSUMMARY OF FECBF  QUERY RESULT  \nActual \npresence of \nğ’’ğ’™ in the  \nmember set  Subfilterâ€™s  \nquery results  FeCBF \nquery result  Type of  \nquery result  QR FEBF  QR FPBF  QR FNBF  QR FeCBF \n0 0 x x 0 True  Negative  \n1 1 0 0 True  Negative  \n1 1 1 1 False Positive  \n1 1 0 x 1 True  Positive  \n1 1 1 1 True  Positive  \nThe application circuit of FeCBF is shown in Fig. 3 , which \ninclud es the Query circuit, Decision circuit, and Application  \n(optional) . A query element ğ‘ğ‘¥ at the input is fed to the Query \ncircuit and , in another path , fed directly to the Application, \nwhich will wait for the Match signal to make the appropriate \ndecision about FeCBF membership. The Decision circuit \ndetermines its output Match signal, i.e., QRFeCBF, from the \ninput signals QRFEBF, QRFPBF, and QRFNBF shown in \nTable I, and t his circuit can be synthesized based on the \nminimization of the QRFeCBF output logic function (e.g., \nusing the Karnaugh map). The Query circuit provides the \nApplication with an output set ğ‘›0 of non -suppressed \nFeCBFâ€™s False Positive elements to use as a Ch ecklist for \nDecision circuit error correction if the  Match signal of this \ncircuit is not True. This is handled optionally on the software \nif accurate filtering is required.  \nIV.  SUB-OPTIMAL FeCBF DESIGN ANALYTICAL MODEL  \nFilter design optimization is a proc ess to reduce the \nğ¹ğ‘ƒğ‘…/ğ¹ğ‘ğ‘…  of FeCBF under the limited filter size or \nminimize the filter size with a specific ğ¹ğ‘ƒğ‘…/ğ¹ğ‘ğ‘…  target. The \nFeCBF model analysis and evaluation will be implemented \non the software . In addition, all t ime-consuming pre-\nproces sing tasks are  performed offline . For example, the \nFeature extraction process for the entire  32-bit input space \n(4 billion elements) could be performed in ~ 3 hours using a \ntypical PC configuration1. \nA. FeCBF MATHEMATICAL MODEL  \nFor the convenience of mathematical expressions, we \nassume the memory sizes of the FeCBFâ€™s subfilters to be \nğ‘šğ¹ğ¸ğµğ¹, ğ‘šğ¹ğ‘ƒğµğ¹ , and ğ‘šğ¹ğ‘ğµğ¹ , respectively. The size constraint \nof FEBF, FPBF, and FNBF relative to their tot al size â„³ is \ndescribed as follows.  \n{  \nğ‘šğ¹ğ‘ƒğµğ¹=ğ›¼âˆ™â„³                    \nğ‘šğ¹ğ‘ƒğµğ¹=ğ›½âˆ™â„³                    \nğ‘šğ¹ğ‘ğµğ¹=(1âˆ’ğ›¼âˆ’ğ›½)âˆ™â„³ (8), \nwhere ğ›¼ and ğ›½ are, respectively, the size ratios of FEBF and \nFPBF compared to the total size â„³ of FeCBF, their values \nneed to satisfy the condition: 0â‰¤ğ›¼+ğ›½â‰¤1. \n \n1 Intel(R) Core(TM) i5 -12500 3.0 GHz, RAM 16Gb DDR4 2667 MHz, \nSSD 512Gb NVMe; OS Windows 10 Pro v.22H2; IDE Pycharm \nCommunity 2023.2 , Python 3.9 . \nqx\nInput data\nEN QRFNBF\nQR FEBF QR FPBF QR FNBF1qx qx\nFEBF\nQR EN\n EN QRFPBF\nQI QI QO QI QOQuery circuit\nDecision circuit\nMatch signalni np nn\nChecklistnoApplication (optional)\n \nFIGURE 3.  Practical application model of the proposed FeCBF structure.  \nThe error rate of each subfilter  FEBF , FPBF , and FNBF \n(according to (3)) is calculated as follows . \n{                         \n ğ¹ğ‘ƒğ‘…ğ¹ğ¸ğµğ¹= ğ‘›ğ‘\nğœ’âˆ™ğ‘›ğ‘– â‰ˆ0.6185ğ‘šğ¹ğ¸ğµğ¹\nğ‘›ğ‘–\n      \n ğ¹ğ‘ƒğ‘…ğ¹ğ‘ƒğµğ¹=ğ‘›ğ‘›\nğ‘›ğ‘–â‰ˆ0.6185ğ‘šğ¹ğ‘ƒğµğ¹\nğ‘›ğ‘       \n ğ¹ğ‘ƒğ‘…ğ¹ğ‘ğµğ¹=ğ‘›ğ‘œ\nğ‘›ğ‘â‰ˆ0.6185ğ‘šğ¹ğ‘ğµğ¹\nğ‘›ğ‘›        (9) \nThus, the number of False Positive  elements ğ‘›ğ‘, ğ‘›ğ‘›, and \nğ‘›ğ‘œ recorded at the output of each FeCBFâ€™s layer is as follows . \n{      \n ğ‘›ğ‘â‰ˆğœ’âˆ™ğ‘›ğ‘–âˆ™0.6185ğ›¼âˆ™â„³\nğ‘›ğ‘–                   \nğ‘›ğ‘›â‰ˆğ‘›ğ‘–âˆ™0.6185(ğ›½âˆ™â„³\nğœ’ âˆ™ ğ‘›ğ‘– âˆ™ 0.6185ğ›¼âˆ™â„³\nğ‘›ğ‘– )\n \nğ‘›ğ‘œâ‰ˆğ‘›ğ‘âˆ™0.6185(1âˆ’ğ›¼âˆ’ğ›½)âˆ™â„³\nğ‘›ğ‘›              (10) \nLet ğ¶=0.6185ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š, where ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š=â„³/ğ‘›ğ‘– is the \nnormalized size of FeCBF, meaning the average number of \nmemory bits  provided  per element of the member set  ğ‘ğ¹ğ‘’ğ¶ğµğ¹ . \nEquation (1 0) can be rewritten as follow s. \n{    \n ğ‘›ğ‘â‰ˆğœ’âˆ™ğ‘›ğ‘–âˆ™ğ¶ğ›¼                       \nğ‘›ğ‘›â‰ˆğ‘›ğ‘–âˆ™ğ¶(ğ›½\nğœ’ âˆ™ ğ¶ğ›¼ )                   \nğ‘›ğ‘œâ‰ˆğœ’âˆ™ğ‘›ğ‘–âˆ™ğ¶ğ›¼âˆ™ğ¶ [(1âˆ’ğ›¼âˆ’ğ›½)\nğ¶(ğ›½\nğœ’ âˆ™ ğ¶ğ›¼ )] (11) \nFinally , we define the normalized error rate of  (3-layer) \nFeCBF , which can be simplified  as follow s. \n{    \n ğ¹ğ‘ƒğ‘…ğ¹ğ‘’ğ¶ğµğ¹=ğ‘›ğ‘œ\nğœ’âˆ™ğ‘›ğ‘–â‰ˆğ¶ [ğ›¼+ (1âˆ’ğ›¼âˆ’ğ›½)âˆ™ğ¶âˆ’ ğ›½\nğœ’ âˆ™ ğ¶ğ›¼ ]                   \nğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š= ğ¹ğ‘ƒğ‘…ğ¹ğ‘’ğ¶ğµğ¹\nğ¹ğ‘ƒğ‘…ğ¸ğ‘ğ‘†ğµğ¹â‰ˆğ¶ [ğ›¼+ (1âˆ’ğ›¼âˆ’ğ›½)âˆ™ğ¶âˆ’ ğ›½\nğœ’ âˆ™ ğ¶ğ›¼ âˆ’1] (12), \nwhere ğ¹ğ‘ƒğ‘…ğ¸ğ‘ğ‘†ğµğ¹â‰ˆ0.6185ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š=ğ¶ is the theoretical  \nğ¹ğ‘ƒğ‘… (calculated according to (3)) of SBF with the same size  This article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and \ncontent may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2024.3399062\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\n\n Quang -Manh Duong et al. : FeCBF: A Novel Sub -Optimal Cascaded \nBloom Filter Structure Based On Feature Extraction  \n6  VOLUME XX, 20 24 \n1. Determining filtering targets\nPossible targets: FPR FeCBF/FPR norm/M/Mnorm  \n2. Providing input data for scripts\nProvide desired targets and scaling factor Ï‡ \n3. Optimizing FeCBF design parameters\nCalculate the sub -optimal size ratios Î±, Î² \nusing scripts  and try the best hash types\n4. Verifying & calibrating actual results \nCompare actual  FPR FeCBF/FPR norm/M/Mnorm \nwith the target  and calibrate if necessary  \nFIGURE 4. Reduced design flow for determining the sub -optimal \nparameters of the  FeCBF structure to meet the target requirements.  \nâ„³ and input set ğ‘ğ¹ğ‘’ğ¶ğµğ¹ . The ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  represents the \nreduction (optimization) level in  the FeCBFâ€™s  error rate \ncompared to  that of  SBF at iso -memory utilization . The \nsmaller the achievable value of  ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š , the better the \nquality of the FeCBF design . \nB. FeCBF DESIGN FLOW  \nThe formula to predict the error rate improvement of \nFeCBF proposed compared to SBF in ( 12) through the  \nğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  resemble itself a complex multilevel  exponential \nfunction, hence  calculating multilevel derivatives to find the \noptimum values is feasible in theory but not very practical . \nTherefore, we use  a numerical  approach to locate the  \nsub-optimal design configuration for  FeCBF under certain \ninput constraints.  Based on the FeCBF  analytical model in  \nSection IV.A, we developed Python scripts that calculate the \nsub-optimal required  memory to achieve an  expected target \nerror rate ( the algorithm is in Appendix A) or calculate the \nbest possible error rate under the constraints of the m emory \n(the algorithm is in Appendix B).  The output data of the \nscripts are the optimal size ratios of the subfilters FEBF, \nFPBF, and FNBF, predictably calculated according to ğ›¼ and \nğ›½ parameters. The FeCBF design flow based on specific \nmember set ğ‘ğ¹ğ‘’ğ¶ğµğ¹  and input -to-member scaling factor ğœ’ to \nachieve the target parameters is depicted in Fig. 4 . \nThe heatmap plotted in Fig. 5 illustrates a case study of \noptimizing the FeCBFâ€™s subf ilters design with the input \nparameters ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š=23, and ğœ’=4294 . For each ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  \nvalue, the FEBF, FPBF, and FNBF ratios to their total size \nğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  are ğ›¼, ğ›½, and (1 - ğ›¼ - ğ›½). Since (ğ›¼ + ğ›½) â‰¤ 1, the points \nrepresenting ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  are populated only in the upper left \nhalf of the triangle. In this domain, we could estimate the \nvalues of ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  (expressed in decimal logarithmic scale) \ncorresponding to the annotations shown on the color bar of \nthe heatmap. The sub -optimal point  of ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  is located in \na highlighted area in the heatmap; note that its location can \nvary depending on the specific values of ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  and ğœ’. In this \nexample, the region where ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  < 1 corresponds to the \nrange ğ›½ < 0.20, the region w here 10-4 < ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š < 10-2 \ncorresponds to the ranges 0.80 < ğ›¼ < 0.95 and 0.03 < ğ›½ < 0.20 , \nthe region where ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  ~ 10-6 corresponds to the ranges  \n0.90.1FIGURE 5. The dependence of ğ‘­ğ‘·ğ‘¹ğ’ğ’ğ’“ğ’ on the size ratios ğœ¶, ğœ· of FeCBFâ€™s  \nsubfilters in decimal logarithmic scale with the specific normalized size \nğ‘´ğ’ğ’ğ’“ğ’ = 23 and input -to-member scaling factor ğŒ = 4294.  \n0.86 < ğ›¼ < 0.92 and 0.08 < ğ›½ < 0.12, and the sub -optimal \nvalue of ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  in this particular example (~ 10-6.7) \nreached at the point on the heatmap with coordinates ( ğ›¼ = \n0.89, ğ›½ = 0.09) with an accuracy of size ratios ğ›¼, ğ›½ is 10-2, \nwhich could be adjusted in scripts. These  values may change \naccording to the boundary conditions of the design problem \n(member set, input set, etc). However, the general trend is \nvery consistent, where the size of the post -filter is typically \nsignificantly smaller than the size of the pre -filter.  These \nadditional filter layers, however, could bring tremendous \nimprovement in the filtering accuracy, as discussed in the \nfollowing subsection.  \nC. IMPACTS OF FeCBF DESIGN PARAMETERS  \n1)  DEPENDENCE OF ERROR RATE ON THE FILTER SIZE  \nBased on the design analytical model and the support of \nthe developed Python scripts, we evaluated the dependent of \nthe absolute and normalized ğ¹ğ‘ƒğ‘…  according to the allocated \nmemory space of FeCBF ( Fig. 6 ). The experimental data \nwere taken corresponding  to typical values of the input -to-\nmember scaling factor, varying from ğœ’ = 100 up to ğœ’ = 1000. \nThe graph of ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  in Fig. 6  (a) shows that for each value \nof ğœ’, there is a corresponding threshold level of ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  from \nwhich the error reductio n effect of FeCBF compared to SBF \nis becoming significant.  \nSpecifically, at small values of ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š , FeCBF does not \ngive better accuracy than SBF, i.e.  ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘šâ‰ˆ1. Once \nğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  starts to surpass a particular threshold value (from \nğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  â‰ˆ12, 16, and 17 corresponding to ğœ’ = 100, 500, and \n1000), but as soon as it exceeds that threshold, \nğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š decreases rapidly and the filtering accuracy of \nFeCBF is getting much super ior to that of SBF. To acquire \nmore generic data, we conducted a deeper analysis of how \nğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  is dependent on ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  under a broader range of ğœ’ \nfrom 10 Ã· 4294, i.e., covering the entire 32 -bit space. These \ndata are skipped in Fig. 6(a) (for c larity), but the general \ntrend of the ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š dependency on ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  is quite similar. \nSpecifically, the threshold levels of ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  increase \nproportionally from about 7 to 21, corresponding to a change \nof ğœ’ from 10 to 4294.  \nFig. 6(b)  presents  the difference in the absolute error rate \nof FeCBF compared to the normalized, with a slight decrease  This article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and \ncontent may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2024.3399062\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\n\n  Quang -Manh Duong et al. : FeCBF: A Novel Sub -Optimal Cascaded \nBloom Filter Structure Based On Feature Extraction  \nVOLUME XX, 20 24 7 \n \n(a) \n \n(b) \nFIGURE 6.  The dependence of ğ‘­ğ‘·ğ‘¹ğ’ğ’ğ’“ğ’ on (a) the absolute error rate \nğ‘­ğ‘·ğ‘¹ğ‘­ğ’†ğ‘ªğ‘©ğ‘­  (b) the normalized filter size ğ‘´ğ’ğ’ğ’“ğ’ at fixed input -to-member \nscaling factor ğŒ = 100, 500, and 1000, respectively.  \nin the absolute error rate when the normalized size gradually \nincreases but does not exceed its threshold. In contrast,  the \nnormalized error ra te (see Fig. 6(a) ) remains almost \nunchanged under the same memory constraints, i.e., the error \nrate reduction of FeCBF is more rapid than SBF. Fig. 6(a)  \nand Fig. 6(b)  show that the error rate of FeCBF could be \nhundreds of times smaller ( ~1E-02) compared to SBF at \nsmall fil ter sizes, i.e., not yet exceeding the threshold.  \nOverall, without changing the input -to-member scaling \nfactor ğœ’, the error rates of FeCBF are significantly reduced \ncompared to SBF as soon as its normalized size of FeCBF \nexceeds specific threshold values,  which comes with only an \ninsignificant cost of memory resources. For example, in  \nFig. 6(a) , to reduce the ğ¹ğ‘ƒğ‘…  of FeCBF compared to SBF  \nfrom 1%, i.e., ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š = 1E -02 to approximately zero,  \ni.e., ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  = 1E -10, the additional normalized  memory \nallocated for FeCBF corresponding to ğœ’ = 100, 500 and 1000 \nis almost equal and approximately 0.8.  \n2)  DEPENDENCE OF ERROR RATE  ON THE NUMBER \nOF QUERY ELEMENTS  \nThe graph in Fig. 7(a) represents the dependence of \nğ¹ğ‘ƒğ‘…ğ¹ğ‘’ğ¶ğµğ¹  and ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š on the input -to-member scaling \nfactor ğœ’, varied from 100 Ã· 4294. For this analysis, ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  is \nset to be constants with fixed values 20, 21, and 22, \nconsidering those are the moderate ranges for the typical \nfilter size (according to our numerical analysis). As can be \nseen from the plots, for each fixed value of ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š , there \nexists an upper bound of ğœ’ below which the error rate of \nFeCBF remains much superior to that of SBF at iso -size, i.e.,   \n(a) \n \n(b) \nFIGURE 7. The dependence of ğ‘­ğ‘·ğ‘¹ğ’ğ’ğ’“ğ’ on (a) the absolute error rate \nğ‘­ğ‘·ğ‘¹ğ‘­ğ’†ğ‘ªğ‘©ğ‘­  (b) the input -to-member scaling factor ğŒ at fixed normalized \nfilter size ğ‘´ğ’ğ’ğ’“ğ’ = 20, 21, and 22, respectively.  \nğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘šâ‰ª1. In addition, at an extreme case with a small \ninput -to-member scaling factor  (ğœ’ ~ 10, which is not \npresented on the graph), ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š only needs to be no lower \nthan a threshold level (7) to ensure the error rate of FeCBF is \nbetter (lower) than SBF.  \nA similar trend can be observed in Fig. 7(b) , which \nrepresents how  the absolute error  rate ğ¹ğ‘ƒğ‘…ğ¹ğ‘’ğ¶ğµğ¹  changes \nconcerning  ğœ’. With  a large  input set, the error rate has an \nintrinsic upper bound,  which is  the ğ¹ğ‘ƒğ‘…  of the SBF. At small \nand moderate  ranges  of ğœ’, we could observe the rapid \ndecrease of ğ¹ğ‘ƒğ‘…  by reducing the input set size. Nonetheless, \nthese upper bound values of ğœ’ are typically quite large to \nmeet practical requirements , i.e., thousands of times larger \nthan the member set , and could be tuned at a  reasonable cost \nof resources ( by increasing the normalized size ). \n3)  DEPENDENCE OF FILTER SIZE ON THE NUMBER OF \nQUERY ELEMENTS  \nFig. 8(a)  shows the dependence of the ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  on the \nscaling factor ğœ’ when fixing the target ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  to 10-1, 10-5, \nand 10-10. The predictive analytical model shows that  \nğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š increases non -linearly with ğœ’. Still, the difference is \ninsignificant a t various fixed values of target ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š . \nAgain, this  confirms that a reasonable increase  of \nğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š could  substantial ly improve  the filtering accuracy. \nFor example, ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  reduces up to 1,000 times (from 10-1 \nto 10-5) when increasing ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  to about 0.887  Ã· 0.888  \n(bits/element) and it is almost independent of ğœ’ as long as  \nthis factor is large enough ( i.e., from ~500 and above ).  \nOverall, FeCBF offers a significant ğ¹ğ‘ƒğ‘…  reduction compared  1.E-101.E-081.E-061.E-041.E-021.E+001.E+02\n10 12 14 16 18 20 22 24FPRnorm\nMnormÏ‡ = 100 Ï‡ = 500 Ï‡ = 1000\n1.E-101.E-081.E-061.E-041.E-021.E+00\n10 12 14 16 18 20 22 24FPRFeCBF\nMnormÏ‡ = 100 Ï‡ = 500 Ï‡ = 10001.E-101.E-081.E-061.E-041.E-021.E+001.E+02\n0 1000 2000 3000 4000 5000FPRnorm\nÏ‡Mnorm = 20\nMnorm = 21\nMnorm = 22\n1.E-101.E-081.E-061.E-041.E-021.E+00\n0 1000 2000 3000 4000 5000FPRFeCBF\nÏ‡Mnorm = 20\nMnorm = 21\nMnorm = 22This article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and \ncontent may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2024.3399062\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\n\n Quang -Manh Duong et al. : FeCBF: A Novel Sub -Optimal Cascaded \nBloom Filter Structure Based On Feature Extraction  \n8  VOLUME XX, 20 24 \n(a) \n(b) \nFIGURE 8. The dependence of ğ‘´ğ’ğ’ğ’“ğ’ on (a) the input -to-member scaling \nfactor  ğŒ at fixed normalized error rate ğ‘­ğ‘·ğ‘¹ğ’ğ’ğ’“ğ’ = 1E -01, 1E -05, and 1E -10 \n(b) the desired target  ğ‘­ğ‘·ğ‘¹ğ’ğ’ğ’“ğ’ at fixed ğŒ = 500, 1000, and 1500.  \nto SBF at a small cost of resources . This could be achieved \nby proper ly adjusting  the filter parameters  based on our \nproposed model  in (9) Ã· (12). \n4)  DEPENDENCE OF FILTER SIZE ON THE DESIRED \nTARGET ERROR RATE  \nFig. 8(b)   shows the dependence of ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  on the desired \ntarget ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š, varying from 1E+00 to 1E -10 when fixing \nğœ’ = 500, 1000, and 1500.  From the plot, t he normalized sizes \nof FeCBF must reach minimum approximate values of 15, \n16.5, and 17.3 bit s/element, respectively, to ensure an \nabsolute error rate lower than or equal to SBF, i.e ., \nğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘šâ‰¤ 1E+00. To reach 10 ğ‘¥ better, i.e. , ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š = 1E-\n01, the additional normalized bits/element  allocated for \nFeCBF needs to be increased by approximately  2.5 and is \nweakly  dependent on ğœ’. From ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š = 1E -02 until \nğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š = 1E -10, the additional memory for FeCBF is \nalmost  independent of its query element number and incurs \nonly insignificant memory resource. Specifically, to achieve \nlevels of error reduction 1E -02, 1E -03, and 1E -04, the \nadditiona l normalized memory for FeCBF are approximately \n0.41, 0.22, and 0.15, respectively. Until the highest \nğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š =  1E -10, the additional memories for FeCBF are  \nvery small, approximately equal to 0.05, which could be \nconsidered negligible. This is part ially because the error rate \nhas already been reduced to a saturated level.  \n \n2We intentionally choose query elements of 32 bit -length, considering it can \nfit, for example,  the pattern s of IPv4 in the network filtering application.  TABLE  II \nTHE HF PAIRS AND THE CORRESPONDING ğ»ğ‘¡ğ‘¦ğ‘ğ‘’  PARAMETER  \nHT a HF 1 HF 2 HT HF 1 HF 2 H HF 1 HF 2 \n1 farm  spooky  5 farm  metro  9 spooky  xxhash  \n2 farm  mmh3.1  6 farm  FNV  10 spooky  metro  \n3 farm  mmh3.2  7 spooky  mmh3.1  11 CRC  farm  \n4 farm  xxhash  8 spooky  mmh3.2  12 CRC  spooky  \naHash Type.  \nD. PRACTICAL VERIFICATION OF THE FeCBF MODEL  \n1) EXPERIMENTAL SETUP  \nThe model presented in the preceding Section is a \npredictive model base d on the closed -form expression  for \nrelated filter parameter s. In this Section , we conduct an \nactual filter design using  some generic  random  datasets and \nfilter configuration to verify the correctness of the proposed \nmodel and design. Specifically, we consider the data set of \n32-bit length elements randomly distributed2. The Feature \nextraction of input datasets is the most time -consuming task \nbut is a one -time operation, i.e. , performed  in offline mode . \nWe practically show that the average time for the Feature \nextraction of entirely  32-bit input datasets, i.e. , the entire  \ninput space of 232 = 4,294,967,296 elements , might take 3 hours , \nas mentioned in Section III. The sizes of FeCBFâ€™s subfilter \nare pre -determined by the predictive model according to the  \nsub-optim al configuration and ha ve been evaluated with \nadditional HF selection and optimization (see the following  \nSubsection).  This confi rms that the proposed approach is \nfeasible  for a practical problem (limited input of a few \nthousand  million  members ). However,  a faster computing \nhardware  system or distributed filtering approach may be \nneeded when expanding  the input space , but this is not the \nprimary focus of this work . \n2) HF SELECTION  \nFor all the subfilter s of FeCBF, the number of HFs ğ‘˜ is \noptimally calculated according to  (2). Moreover, to reduce \nthe volume of the hash computation without increasing the \nğ¹ğ‘ƒğ‘… , we adopted  the algorithm proposed by Kirsch and \nMitzenmacher  [21], in which the set of ğ‘˜ HFs is generated \nfrom a base HF pair. Each base HF pair (HF1, HF2) \ncorresponds to a hash type and is denoted as ğ»ğ‘¡ğ‘¦ğ‘ğ‘’ , which \ntakes the integer values. The specific base HF pairs and the \ncorresponding values of the ğ»ğ‘¡ğ‘¦ğ‘ğ‘’  parameter are listed in \nTable II . \n3) EXPERIMENT RESULT  \nFrom the FeCBF â€™s desi gn parameters predicted using  our \ndeveloped s cripts and represented on graphs in Fig. 6 , Fig. 7 , \nand Fig. 8 , some representative results  are selected for \nexperimental evaluations on real datasets to verify the \ncorrectness of the proposed  FeCBF design model. \nSpecifically, the verification experiments performed include  \nthe dependence of ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  on ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  at fixed ğœ’ = 100 ( Fig. 9( a)), 1012141618202224\n0 1000 2000 3000 4000 5000Mnorm\nÏ‡FPRnorm = 1E-01\nFPRnorm = 1E-05\nFPRnorm = 1E-10\n1012141618202224Mnorm\nFPRnormÏ‡ = 500 Ï‡ = 1000 Ï‡ = 1500This article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and \ncontent may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2024.3399062\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\n\n  Quang -Manh Duong et al. : FeCBF: A Novel Sub -Optimal Cascaded \nBloom Filter Structure Based On Feature Extraction  \nVOLUME XX, 20 24 9 \n(a) \n(b) \n(c) \n(d) \nFIGURE 9. Practical verification of FeCBF design model (a) Dependence \nof error rate on the filter size, (b) Dependence of error rate on the number \nof query elements, (c) Dependence of filter size on the number of query \nelements, and (d) Dependence of filter size on the desired target error rate.  \nthe dependence of ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  on ğœ’ at fixed ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š = 20 ( Fig. 9(b) ), \nthe dependence of ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  on ğœ’ at fixed ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š = 1E -01 \n(Fig. 9(c) ), and the dependence of ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  on ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  at \nfixed ğœ’ = 500 ( Fig. 9(d) ). FIGURE 10 . The hash type effectiveness is evaluated based on their \nutilization frequency in real-world FeCBF tests.  \nThe member set of FEBF has a standard number of 1 \nmillion randomly generated 32 -bit elements, from which the \nmember sets of FPBF and FNBF are collected by extracting \nFalse Positive  elements of the corresponding previous \nsubfilters.  As can be seen , the actual filtering results of \nFeCBF in all test cases relatively match the predicted ones . \nThe detailed numerical data shows that  the average deviation \nbetween predicted and actual  ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  in Fig. 9(a) , Fig. 9(b) , \nFig. 9(c) , and Fig. 9(d)  is about 1.6%, 2.3%, 0.1%, and 0.3% \nrespectively with a tendency that the  actual filtering \nefficiency to be slightly better than predicted. The \nimprovements of FeCBF in practical implementations are \nachieved by careful selection of the opti mized hash type for \neach subfilter from the entire set of the 12 hash types listed \nin Table II , some of which such as ğ»ğ‘¡ğ‘¦ğ‘ğ‘’ 2, ğ»ğ‘¡ğ‘¦ğ‘ğ‘’ 4, and \nğ»ğ‘¡ğ‘¦ğ‘ğ‘’ 7 are the most frequently used for minimizing \nsubfilter sâ€™s ğ¹ğ‘ƒğ‘…  as show n in Fig. 10 . A critic al parameter \naffecting the choice of a hash type is the subfilter's size, \nwhere a hash type might be the most efficient for a particular  \nsubfilter ; however,  it is not necessarily the best when the size \nof this filter change s. Nonetheless, optimiz ing the HF selections  \nonly has a  minor extra impact ( 0.18 Ã· 1.17 % on average ), \nwhich could be consider ed an optional design step. For \nexample, for practical hardware implementation, the complexity  \nof an HF could be a more critical  design consideration .  \nV.  COMPARISON TO STATE -OF-THE-ART FILTERS  \nA. EVALUATION DATA AND PARAMETERS  \nIn Section IV.D , we demonstrated the superiority of \nFeCBF over SBF in classification accuracy. In some case \nstudies, t he e xperimental  results  show  that Fe CBF could \nsuppress  filtering errors with the  nearly  empty output sets of \nFalse Positive  elements, i.e. , ğ‘›ğ‘œ â‰… 0. In this section, we \ncompare FeCBF to three other selected state -of-the-art \nfilters introduced in Section II.B , including f -HABF [14], \nSLBF [16], and Xor filter [20].  The experimental setup for \nFeCBF is entire ly similar to other representative filters in \nterms of member set s and input dataset s. We use the same \ndataset generated in [14] by the open -source tool YCSB \n(Yahoo! Cloud Serving Benchmark  [22]) for experiments   1.E-101.E-081.E-061.E-041.E-021.E+001.E+02\n10 12 14 16 18 20 22 24FPRnorm\nMnormPredicted Actual\n1.E-101.E-081.E-061.E-041.E-021.E+001.E+02\n0 1000 2000 3000 4000 5000FPRnorm\nÏ‡Predicted Actual\n1012141618202224\n0 1000 2000 3000 4000 5000Mnorm\nÏ‡Predicted Actual\n1012141618202224Mnorm\nFPRnormPredited Actual413\n620\n10\n511\n8\n67\n37\n0510152025Utilization frequency [%]This article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and \ncontent may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2024.3399062\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\n\n Quang -Manh Duong et al. : FeCBF: A Novel Sub -Optimal Cascaded \nBloom Filter Structure Based On Feature Extraction  \n10  VOLUME XX, 20 24 \n| FPR FeCBF = FPR target1  = 3.46E -03 |\n40,042\n| n i = 12,500,611 | M 1   55.36 Mb | M norm1    4.64 | FPR norm1    3.3E -02 |\nFPBF FNBF\nni\nnpnp\nnpniFEBF\n24,074,812 22.92 Mb\n4,599,140 8.91 Mb\n1,021,846 23.53 Mb\n12,500,611nonnnn\nÏ‡   0.926 \n(a) \n| FPR FeCBF = FPR target2  = 3.63E -06 |\n42\n| n i = 12,500,611 | M 2   62.22 Mb | M norm2    5.22 | FPR norm2    4.4E -05 |\nFPBF FNBF\nni\nnpnp\nnpniFEBF\n24,074,812 24.23 Mb\n3,239,919 6.35 Mb\n290,191 31.64 Mb\n12,500,611nonn\nnnÏ‡   0.926\n \n(b) \nFIGURE 11 .  The sub -optimal configurations of the FeCBF with the actual \ndataset of 24,074,812 elements, including 12,500,611 member elements, to \nachieve the desired target ğ‘­ğ‘·ğ‘¹ğ‘­ğ’†ğ‘ªğ‘©ğ‘­  equals (a) 3.46E -03 and (b) 3.63E -06. \nwith f -HABF, SLBF, and Xor filter as the common dataset \nfor evaluation s in this work.  Thus,  the experimental dataset \nfor FeCBF , f-HABF, SLBF, and Xor filter consists of \n24,074,812 elements of 96-bit, in which 12,500,611 \nelements are positive  (member of filter) , and the remaining \n11,574,202 elements are negative , i.e., do not belong to the \nmember set, thus ğœ’ = 11,574,202 / 12,500,611 â‰ˆ 0,925891 . \nThe filter sizes in all the Xor filter, SLBF,  and f -HABF \nexperiments in [14] were the same and varied from 100ğ‘€ğ‘ \nto 260ğ‘€ğ‘. The lowest ğ¹ğ‘ƒğ‘…  was frequently achieved with  \nf-HABF; however, their specific values were reported only \nin the two extreme cases corresponding  to the lower -bound  size \n(100ğ‘€ğ‘) and upper -bound size ( 260ğ‘€ğ‘) of the evaluated \nfilters, equal to 3.46E-03 and 3.63E-06. We take these \nvalues as  the desired  ğ¹ğ‘ƒğ‘…ğ¹ğ‘’ğ¶ğµğ¹  targets to determine  the sub -\noptimal FeCBFâ€™s parameters  by applying  the proposed  \ndesign  flow. Thus, the FeCBF â€™s input parameters are as \nfollows: ğ‘›ğ‘–=12,500,611, ğœ’â‰ˆ0.926, ğ¹ğ‘ƒğ‘…ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡1=\n3.46E-03, and ğ¹ğ‘ƒğ‘…ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡2=3.63E-06. The FeCBFâ€™s \noutput  parameters are the optimized  ğ›¼ and ğ›½ values to get the \nsmallest filter size  and meet the input requirements .  \n B. IMPLEMENTATION RESULTS AND COMPARISON  \nThe optimized design parameters of FeCBF are depicted \nin Fig. 1 1, including the sizes of FeCBFâ€™s subfilter s and their  \ncorresponding numbers of member elements. The actual sub -\noptimal sizes of FeCBF to achieve the pre -defined upper and \nlower bound s of targe t error rate ğ¹ğ‘ƒğ‘…ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡1 and ğ¹ğ‘ƒğ‘…ğ‘¡ğ‘ğ‘Ÿğ‘”ğ‘’ğ‘¡2 \nare â„³1=55.36Mb (size ratios of FEBF, FPBF, and FNBF \nare 0.43, 0.41, and 0.16, respectively) and  â„³2=62.22Mb \n(size ratios of FEBF, FPBF, and FNBF are 0.51, 0.39, and \n0.16, respectively). Compared with SBF of the same size, the \ncorresponding values of ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š  equal  3.3E-02 and 4.4E-05 \nin actual FeCBF evaluations.  \nIn the following, we compare FeCBF with other data filter  \nstructure s proposed in [20], [16], and [14] for some major design   TABLE  III \nCOMPARISON OF FECBF  WITH STATE -OF-THE-ART BLOOM -BASED FILTERS  \n SBF JEA 2020  \n[20] ANIPS 2018  \n[16] ICDE 2021  \n[14] FeCBF  \n(This work)  \nRepresen -\ntative filter  Single \nlayer  Xor filter  SLBF  f-HABF  3-layer \nFeCBF  \nKey ideas  BF \nbaseline  Bloomier \nfilter  Machine \nLearning  Hash \noptimization  Fe a, Inv b, \nDeN c \nMember set  12,500,611  \nFilter size [Mb]    100 Ã· 260  55.36 Ã· 62.22  \nFilter size vs. \nSBF [ğ‘¥] 1 0.55 Ã· 0.24  \nActual ğ¹ğ‘ƒğ‘…   1.78E -02 \nÃ· 2.83E -05 1.57E -02 \nÃ· 1.59E -05 6.81E -03 \nÃ· 1.72E -05 3.46E -03 Ã· 3.63E -06 \nActual ğ¹ğ‘ƒğ‘…  Ì¸ \nTheo. ğ¹ğ‘ƒğ‘…[ğ‘¥] 1 0.88 Ã· 0.56 0.38 Ã· 0.61 0.19 Ã· 0.13  \nConstr. time \nvs. SBF  [ğ‘¥] 1 2.24 > 103 2.3 4.61 Ã· 3.6  \nQuery time vs. \nSBF [ğ‘¥] 1 0.68 > 500  1.04 2.29 Ã· 1.59  \nDesign model  Yes No Yes No Yes \naFeature extraction, bInverse filter, cDe-Negative filter.  \nand performance metrics, which include the filter sizes, the \nfilter error rates, the filter construction time, and the query \ntime (Table III ). The latter is the offline time spen t on the \ndesigning step , such as Feature extraction/hash optimization \nand adding the member set . Note that all the time metrics are \nnormalized to that of SBF for fair comparison since the \nhardware configuration s in each work are not the same.  \nRegarding the filter size, the optimal â„³1 and â„³2 sizes of \nFeCBF are 55%  and 24%  of the  f-HABF, SLBF , and Xor \nuniform sizes , respectively, with the same experimental setup.  \nNote that with that sizing, the ğ¹ğ‘ƒğ‘…  of FeCBF is achieved in \nthe same as that of f -HABF and is the best in the class for the \nğ¹ğ‘ƒğ‘… . This ğ¹ğ‘ƒğ‘…  is about one order of magnitude less than  \nthose of Xor  filter  and SLBF. The SLBF based on ML \ntechnique s achieves a medium level of ğ¹ğ‘ƒğ‘… , which might  be \nreduced  in cases where the  input elements have more correlations .  \nSLBF is much slower than other filter structures in terms \nof filter construction time since building ML models is not \nbest supported on non -GPU machines. FeCBF takes slightly \nlonger for construction time compared to f -HABF and Xor. \nNote that with a larger input set, FeCBF would take much \nlonger for the Feature extraction task, though this metric is \njust the offline time (i.e., one -time) at the filter design step, \nwhich  is not important in practice.  \nA similar trend could be observed r egarding the query time , \nwhere  SLBF is the worst because of the computational \ncomplexity related to ML models . At the same time,  the Xor \nfilter exhibits the faste st. In this specific implementation , the \nquery time of the proposed FeCBF is  slightly greater than  \nf-HABF and about 3-4ğ‘¥ of Xor. The query time of FeCBF \nhighly depends on the filtering context and could be lower \nthan that of SBF. Specifically, the query time of FeCBFâ€™s \nexperiments in Section V.A. compared to SBF ranges from \n0.83ğ‘¥ to 1.13ğ‘¥. The variations in query time of FeCBF in \ndifferent filtering contexts are mainly caused by the variation  \nof ğ›¼, ğ›½, and ğœ’ corresponding to FeCBF configurations.  This article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and \ncontent may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2024.3399062\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\n\n  Quang -Manh Duong et al. : FeCBF: A Novel Sub -Optimal Cascaded \nBloom Filter Structure Based On Feature Extraction  \nVOLUME XX, 20 24 11 \nBased on the evaluation results presented in  Table III , \nFeCBF outperforms the rest in memory  saving, especially in \nresource -utilization eff iciency. Finally, it is worth noting that \nexcluding SBF, only SLBF and FeCBF come with explicit \npredictive models and design procedures to determine the \nsub-optimal filter parameters. This could be important for \ndeploying the filter in practice, especially  in the case of \ndynamically changing targets and boundary conditions.  \nVI. CONCLUSION  \nThis paper presents a novel filter structure , FeCBF, and its \ndesign methodology, which can achieve  high accuracy with  low \nmemory requirement s. FeCBF uses the \"Feature extraction \" \nfrom the input dataset to record potential false -queried \nelements and cascaded interleaved positive/negative \nsubfilters for their correction . We presented a sub -optimal \nanalytical model for the filtering error rate predi ction based \non fine -tuning the fundamental FeCBFâ€™s design parameters. \nCompared to the representative filters employing  ML \ntechniques (SLBF),  hash optimization (f -HABF), and  \nimproved  variation of Bloom filter (Xor filter), FeCBF \noutperforms these filters in  either error rate reduction \ncapability or level of memory saving. Specifically, in \nexperimental evaluations  with the same input  and member set s, \nFeCBF and f -HABF show the best reductions of target ğ¹ğ‘ƒğ‘… s, \nfrom 81%  to 87% , compared to  SBF. Moreover,  FeCBF \nachieved the lowest memory consumption, only about 24%  \nto 55% , compared to the uniform size of SBF, SLBF, Xor  \nfilter , and f -HABF . The evaluated effectiveness of FeCBF is \nthe basis for implementing this filter model on hardware \naccelerators  to enhance accuracy and minimize resource \nconsumption of big -data filtering applications.  \nAPPENDIX A  \nSCRIPT FOR OPTIMIZ ING FeCBF â€™S MEMORY  SIZE  \nAlgorithm 1  Pseudo code for calculat ing the sub-optimal  \nsize of FeCBF to achieve a desired target error rate . \nInput:  target ğ¹ğ‘ƒğ‘…ğ¹ğ‘’ğ¶ğµğ¹ or ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š , scaling factor ğœ’, \nincrement  steps ğ›¼ğ‘ ğ‘¡ğ‘’ğ‘, ğ›½ğ‘ ğ‘¡ğ‘’ğ‘, ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘šğ‘ ğ‘¡ğ‘’ğ‘ of ğ›¼, ğ›½, and  ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š . \nOutput:  sub-optimal size ratios ğ›¼ğ‘œğ‘ğ‘¡, ğ›½ğ‘œğ‘ğ‘¡, and sub -\nminimum normalized size ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘šğ‘šğ‘–ğ‘›. \n1: ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘šâ†ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘šğ‘–ğ‘›ğ‘–ğ‘¡ [Initial estimated ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š ] a \n2: NumLoopOfAlpha â†1/ğ›¼ğ‘ ğ‘¡ğ‘’ğ‘ [Loop number of  ğ›¼] \n3: NumLoopOfBeta â†1/ğ›½ğ‘ ğ‘¡ğ‘’ğ‘ [Loop number of ğ›½] \n4: while  ğ¹ğ‘ƒğ‘…  b is greater than  Target ErrorRate  do  \n5:  ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘šâ† ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š+ ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘šğ‘ ğ‘¡ğ‘’ğ‘ \n6:  ğ¶â†0.6185ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š[Re-Calculate the value of  ğ¶] \n7:  ğ›¼â†0 [Re-Initialize the value of ğ›¼ to 0] \n8: for ğ‘– from  1 to NumLoopOfAlpha do \n9:  ğ›½â†0 [Re-Initialize the value of ğ›½ to 0] \n10: for ğ‘— from  1 to NumLoopOfBeta do \n11: TempVar  â†ğ¹ğ‘ƒğ‘…ğ‘šğ‘œğ‘‘ğ‘’ğ‘™  c \n12: if ğ¹ğ‘ƒğ‘…  is greater than  TempVar do \n13:  ğ¹ğ‘ƒğ‘…â† TempVar  \n14:  ğ›¼ğ‘œğ‘ğ‘¡â†ğ›¼ 15:  ğ›½ğ‘œğ‘ğ‘¡â†ğ›½ \n16: end if  \n17:  ğ›½â†ğ›½+ğ›½ğ‘ ğ‘¡ğ‘’ğ‘ \n18: end for \n19:  ğ›¼â†ğ›¼+ğ›¼ğ‘ ğ‘¡ğ‘’ğ‘ \n20: end for  \n21: end while  \n22: ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘šğ‘šğ‘–ğ‘›â† ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  \naThe initial value of ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š  is roughly estimated based on  the FeCBF \ndesign analytical model  presented  in Subs ection IV.C.3 . \nbğ¹ğ‘ƒğ‘…  is the current value ( haven â€™t reached the desired target ) of \nFeCBFâ€™s error rate, which could be ğ¹ğ‘ƒğ‘…ğ¹ğ‘’ğ¶ğµğ¹  or ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š . \ncğ¹ğ‘ƒğ‘…ğ‘šğ‘œğ‘‘ğ‘’ğ‘™ is the predicted value of FeCBFâ€™s error rate , which could be  \nğ¹ğ‘ƒğ‘…ğ¹ğ‘’ğ¶ğµğ¹  or ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š , and is calculated according  to (12). \nAPPENDIX B  \nSCRIPT FOR OPTIMIZING FeCBF â€™S ERROR RATE  \nAlgorithm 2  Pseudo code for optimizing the error rate of \nFeCBF with a fixed total filter size . \nInput:  normalized size ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š , scaling factor ğœ’, increment \nsteps ğ›¼ğ‘ ğ‘¡ğ‘’ğ‘, ğ›½ğ‘ ğ‘¡ğ‘’ğ‘ of ğ›¼, ğ›½. \nOutput:  sub-optimal size ratios  ğ›¼ğ‘œğ‘ğ‘¡, ğ›½ğ‘œğ‘ğ‘¡, and  sub-\noptimal  error rates ğ¹ğ‘ƒğ‘…ğ¹ğ‘’ğ¶ğµğ¹ğ‘œğ‘ğ‘¡ or ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘šğ‘œğ‘ğ‘¡. \n1: ğ¶â†0.6185ğ‘€ğ‘›ğ‘œğ‘Ÿğ‘š[Calculate the value of ğ¶] \n2: NumLoopOfAlpha â†1/ğ›¼ğ‘ ğ‘¡ğ‘’ğ‘ [Loop number of ğ›¼] \n3: NumLoopOfBeta â†1/ğ›½ğ‘ ğ‘¡ğ‘’ğ‘ [Loop number of ğ›½] \n4: ğ›¼â†0 [Initialize the value of ğ›¼ to 0] \n5: for ğ‘– from 1 to NumLoopOfAlpha do \n6:  ğ›½â†0 [Initialize the value of ğ›½ to 0] \n7: for ğ‘— from  1 to NumLoopOfBeta do \n8: TempVar â†ğ¹ğ‘ƒğ‘…ğ‘šğ‘œğ‘‘ğ‘’ğ‘™  a \n9: if ğ¹ğ‘ƒğ‘…  is greater than TempVar do \n10:  ğ¹ğ‘ƒğ‘…â† TempVar  b \n11:  ğ›¼ğ‘œğ‘ğ‘¡â†ğ›¼ \n12:  ğ›½ğ‘œğ‘ğ‘¡â†ğ›½ \n13: end if  \n14:  ğ›½â†ğ›½+ğ›½ğ‘ ğ‘¡ğ‘’ğ‘ \n15: end for  \n16:  ğ›¼â†ğ›¼+ğ›¼ğ‘ ğ‘¡ğ‘’ğ‘ \n17: end for  \n18: end while  \n19: ğ¹ğ‘ƒğ‘…ğ‘œğ‘ğ‘¡â† ğ¹ğ‘ƒğ‘…  b \nağ¹ğ‘ƒğ‘…ğ‘šğ‘œğ‘‘ğ‘’ğ‘™ is the predicted value of FeCBFâ€™s error rate, which could be \nğ¹ğ‘ƒğ‘…ğ¹ğ‘’ğ¶ğµğ¹  or ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š , and is calculated according  to (12).  \nbğ¹ğ‘ƒğ‘…  is the current value ( non-optimized ) of FeCBFâ€™s error rate, which \ncould be ğ¹ğ‘ƒğ‘…ğ¹ğ‘’ğ¶ğµğ¹  or ğ¹ğ‘ƒğ‘…ğ‘›ğ‘œğ‘Ÿğ‘š . \nREFERENCES  \n[1] Bloom, Burton H. \"Space/time trade -offs in hash coding with \nallowable errors .\" Communications of the ACM 13.7 (1970): 422 -426. \n[2] G. Chen, D. Guo, L. Luo, B. Ren, \"Optimization of multicast source \nrouting based on boom ï¬lter ,\" IEEE Communication Letters, vol. 22, \nno. 4, pp. 700 -703, 2018.   \n[3] Nayak, Sabuzima, Ripon Patgiri, and Angana Bor ah. \"A survey on the \nroles of bloom filter in implementation of the named data networking .\" \nComputer Networks 196 (2021): 108232 . \n[4] Geravand, Shahabeddin, and Mahmood Ahmadi. \"BF applications in \nnetwork security: A state -of-the-art survey .\" Computer Networks  \n57.18 (2013): 4047 -4064.  This article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and \ncontent may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2024.3399062\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/\n\n Quang -Manh Duong et al. : FeCBF: A Novel Sub -Optimal Cascaded \nBloom Filter Structure Based On Feature Extraction  \n12  VOLUME XX, 20 24 \n[5] Kapoor, Aveksha, and Vinay Arora. \"Application of Bloom Filter for \nduplicate URL detection in a web crawler .\" 2nd International \nConference on Collaboration and Internet Computing (CIC). IEEE, 2016.   \n[6] Fu, Wenliang, Hila Ben Abraham,  and Patrick Crowley. \n\"Synchronizing namespaces with invertible bloom filters .\" 2015 \nACM/IEEE Symposium on Architectures for Networking and \nCommunications Systems (ANCS). IEEE, 2015.  \n[7] Gomez -Barrero, Marta, et al. \"Multi -biometric template protection \nbased o n bloom filters .\" Information Fusion 42 (2018): 37 -50. \n[8] Goodwin, Bob, et al. \"Bitfunnel: Revisiting signatures for search .\" \nProceedings of the 40th International ACM SIGIR Conference on \nResearch and Development in Information Retrieval. 2017.   \n[9] \"Issue 10896048: Transition safe browsing from BF to prefix set - \nCode Review .\" Chromiumcodereview.appspot.com. Retrieved 2014 -07-03.   \n[10] Canetti, Ran, Ari Trachtenberg, and Mayank Varia. \"Anonymous \ncollocation discovery: Harnessing privacy to tame the coronavirus .\" \narXiv preprint arXiv:2003.13670 (2020).     \n[11] Duong, Quang -Manh, et al. \"An Analysis of the Effectiveness of \nCascaded and CAM -Assisted Bloom Filters for Data Filtering .\" The \nInternational Conference on Intelligent Systems & Networks. \nSingapore: Springer Nature Singapore, 2023.  \n[12] Lumetta, Steve, and Michael Mitzenmacher. \"Using the power of two \nchoices to improve Bloom filters .\" Intern et Mathematics 4.1 (2007): 17 -33. \n[13] Hao, Fang, Murali Kodialam, and T. V. Lakshman. \"Building high \naccuracy bloom filters using partitioned hashing .\" Proceedings of the \n2007 ACM SIGMETRICS international conference on Measurement \nand modeling of computer systems. 2007.   \n[14] R. Xie et al., \"Hash Adaptive Bloom Filter ,\" 2021 IEEE 37th \nInternational Conference on Data Engineering (ICDE), Chania, \nGreece, 2021, pp. 636 -647, doi: 10.1109/ICDE51399.2021.00061.  \n[15] Kraska, Tim, et al. \"The case for learned index structures .\" \nProceedings of the 2018 International Conference on Management of \nData. 2018.  \n[16] Mitzenmacher, Michael. Kraska, Tim, et al. \"The case for learne d \nindex structures. \" Proceedings of the 2018 International Conference \non Management of Data. 2018. A model for learned BFs and \noptimizing by sandwiching .\" Advances in Neural Information \nProcessing Systems 31 (2018).  \n[17] Dai, Zhenwei, and Anshumali Shrivastava . \"Adaptive learned bloom \nfilter (ada -bf): Efficient utilization of the classifier with application to \nreal-time information filtering on the web .\" Advances in Neural \nInformation Processing Systems  33 (2020): 11700 -11710.  \n[18] Chazelle, Bernard, et al. \"The blo omier filter: an efficient data \nstructure for static support lookup tables .\" Proceedings of the fifteenth \nannual ACM -SIAM symposium on Discrete algorithms. 2004.  \n[19] Dietzfelbinger, Martin, and Rasmus Pagh. \"Succinct data structures for \nretrieval and approxima te membership .\" International Colloquium on \nAutomata, Languages, and Programming. Berlin, Heidelberg: \nSpringer Berlin Heidelberg, 2008.   \n[20] Graf, Thomas Mueller, and Daniel Lemire. \"Xor filters: Faster and \nsmaller than bloom and cuckoo filters .\" Journal of Ex perimental \nAlgorithmics (JEA) 25 (2020): 1 -16. \n[21] Kirsch, Adam, and Michael Mitzenmacher. \"Less hashing, same \nperformance: Building a better Bloom Filter .\" Algorithms â€“ESA 2006: \n14th Annual European Symposium, Zurich, Switzerland, September \n11-13, 2006. Procee dings 14. Springer Berlin Heidelberg, 2006.  \n[22] M. Barata, J. Bernardino and P. Furtado, \"YCSB and TPC -H: Big Data \nand Decision Support Benchmarks,\" 2014 IEEE International \nCongress on Big Data, Anchorage, AK, USA, 2014, pp. 800 -801.  \nQUANG -MANH DUONG  received a B.E. degree in \nradio electronics from the Moscow Aviation Institute, \nMoscow, Russia, in 2006 and an M.S.  degree in \nelectronic engineering from the Le Quy Don Technical \nUniversity in Hanoi, Vietnam , in 2012 . He is pursuing a \nPh.D.  degree  in elec tronic engineering at  Le Quy Don \nTechnical University in Hanoi, Vietnam.  \nFrom 2007 to 2019, h e was a Lecturer and R esearcher \nwith the Department of Microprocessor Engineering, \nFaculty of Radio -Electronic  Engineering, Le Quy Don Techn ical \nUniversity. His research interests include  low-power integrated circuit \ndesign, energy -efficient signal processing , hardware security , in-memory \ncomputing, and emerging memory technologies . KHOA -SANG  NGUYEN  received a B.A. degree in \nelectronic & information engineering from the Nanjing \nUniversity of Science and Technology, Nanjing, China, \nin 2012 and information  & communication engineering \nfrom the Nanjing  University  of Science and \nTechnology , Nanjing, China , in 20 15. \nFrom 20 16, he was a Lecturer and Researcher with \nthe Department of Microprocessor Engineering, \nFaculty of Radio -Electronic  Engineering, Le Quy Don \nTechnical University . His research interests include  low-power integrated \ncircuit design, embedded s ystems , and digital  signal processing .  \n \n \nHAI-DUONG NGUYEN  received a Ph.D.  degree in \nelectronic engineering  from the Bauman Moscow State \nTechnical University , Moscow, Russia, in 200 7. He \nspecializes in teaching computer engineering since 1995  \nat Le Quy Don Technical University, Hanoi, Viet Nam.  \nCurrently, he is working as a Senior Researcher and \nthe Head of the Department of Microprocessor \nEngineering, Faculty of Radio Electronic  Engineering, \nLe Quy Don Technical Univers ity. His research interests include  computing \narchitecture, embedded systems, VLSI architecture for digital signal \nprocessing, and hardware security.  \n \n \nXUAN -UOC  DAO received a B.E. degree in electronic \nengineering from the Bauman Moscow State Technical \nUniversity, Moscow, Russia, in 2017 and an M.S.  \ndegree in electronic engineering from the Le Quy Don \nTechnical University in Hanoi, Vietnam, in 20 22. \nHis research interests include  low-power integrated \ncircuit design, digital  signal processing , and hardware \nsecurity .  \n \n \nANH -TUAN  DO (Senior Member, IEEE) received a \nPh.D.  degree  from the Nanyang Technological \nUniversity , Singapore , in 201 0.  \nHe joined the Digital IC Design Group, Institute of \nMicroelectronics (IME), A*STAR, Singapore, in 2015. \nHe was a Research Fellow with VIRTUS, IC Design \nCentre of Excellence, NTU, from 2010 to 2015 . His \nresearch interests include  CMOS design, neuromorphic \ncomputing, AI hardware, energy -efficient computing architecture, AI \nhardware, neuromorphic computing, and cryogenic circuits for quantum \ntechnologies. He has authored and co -authored more than 100 IEEE  journals \nand conference  papers.  \nHe received the best paper award from ISLPED 2023, ISO CC 2022, \nSOCC 2012, the second prize, and the best presentation award in the \ninnovation contest from the International Ph.D. Student Workshop 2007, \nNational University. He serves as Associate Editor of IEEE Trans. VLSI \nSystems, TPC members of A -SSCC as a r eviewer for several IEEE journals \nand conferences, including the IEEE TCAS  I: Regular Papers, the IEEE \nTCAS  II: Express Briefs, and the IEEE Transactions on Very Large -Scale \nIntegration (VLSI) Systems . \n \n \nQUANG -KIEN TRINH  (Member, IEEE) received a \nPh.D. de gree in computer engineering from the \nNational University of Singapore, Singapore , in 2018.  \nHe is working as the Deputy Head of The \nDepartment of Microprocessor Engineering  , Faculty of \nRadio -Electronic Engineering , Le Quy Don Technical \nUniversity , Hanoi, Vietnam. His research interests \ninclude  low-power integrated circuit design, emerging \nmemory technologies, and hardware security. He is the \nauthor and co -author of more than 40 publications ( mainly  IEEE) and 0 3 \npatents  and was TPC of many international conferences such as McSoC, \nATC, NICS, and INISCOM.  \nThis article has been accepted for publication in IEEE Access. This is the author's version which has not been fully edited and \ncontent may change prior to final publication. Citation information: DOI 10.1109/ACCESS.2024.3399062\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 License. For more information, see https://creativecommons.org/licenses/by-nc-nd/4.0/",
  "textLength": 69021
}