{
  "paperId": "8e8e785856d7af05ad5db7e46a0a84b2c091ac11",
  "title": "Femur: A Flexible Framework for Fast and Secure Querying from Public Key-Value Store",
  "pdfPath": "8e8e785856d7af05ad5db7e46a0a84b2c091ac11.pdf",
  "text": "Femur: A Flexible Framework for Fast and Secure Querying from\nPublic Key-Value Store\nJiaoyi Zhang\njy-zhang20@mails.tsinghua.edu.cn\nTsinghua University\nBeijing, ChinaLiqiang Peng\nplq270998@alibaba-inc.com\nAlibaba Group\nBeijing, ChinaMo Sha\nshamo.sm@alibaba-inc.com\nAlibaba Cloud\nSingapore\nWeiran Liu\nweiran.lwr@alibaba-inc.com\nAlibaba Group\nBeijing, ChinaXiang Li\nlixiang20@mails.tsinghua.edu.cn\nTsinghua University\nBeijing, ChinaSheng Wang\nsh.wang@alibaba-inc.com\nAlibaba Cloud\nSingapore\nFeifei Li\nlifeifei@alibaba-inc.com\nAlibaba Cloud\nHangzhou, ChinaMingyu Gaoâˆ—\ngaomy@tsinghua.edu.cn\nTsinghua University\nBeijing, ChinaHuanchen Zhangâˆ—\nhuanchen@tsinghua.edu.cn\nTsinghua University\nBeijing, China\nAbstract\nWith increasing demands for privacy, it becomes necessary to pro-\ntect sensitive user query data when accessing public key-value\ndatabases. Existing Private Information Retrieval (PIR) schemes\nprovide full security but suffer from poor scalability, limiting their\napplicability in large-scale deployment. We argue that in many\nreal-world scenarios, a more practical solution should allow users\nto flexibly determine the privacy levels of their queries in a theoreti-\ncally guided way, balancing security and performance based on spe-\ncific needs. To formally provide provable guarantees, we introduce\na novel concept of distance-based indistinguishability, which can\nfacilitate users to comfortably relax their security requirements. We\nthen design Femur, an efficient framework to securely query public\nkey-value stores with flexible security and performance trade-offs.\nIt uses a space-efficient learned index to convert query keys into\nstorage locations, obfuscates these locations with extra noise prov-\nably derived by the distance-based indistinguishability theory, and\nsends the expanded range to the server. The server then adaptively\nutilizes the best scheme to retrieve data. We also propose a novel\nvariable-range PIR scheme optimized for bandwidth-constrained\nenvironments. Experiments show that Femur outperforms the state-\nof-the-art designs even when ensuring the same full security level.\nWhen users are willing to relax their privacy requirements, Femur\ncan further improve the performance gains to up to 163.9 Ã—, demon-\nstrating an effective trade-off between security and performance.\nâˆ—Huanchen Zhang and Mingyu Gao are also affiliated with Shanghai Qi Zhi Institute.\nCorresponding authors.\nPermission to make digital or hard copies of all or part of this work for personal or\nclassroom use is granted without fee provided that copies are not made or distributed\nfor profit or commercial advantage and that copies bear this notice and the full citation\non the first page. Copyrights for components of this work owned by others than the\nauthor(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or\nrepublish, to post on servers or to redistribute to lists, requires prior specific permission\nand/or a fee. Request permissions from permissions@acm.org.\n2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany\nÂ©2025 Copyright held by the owner/author(s). Publication rights licensed to ACM.\nACM ISBN 978-x-xxxx-xxxx-x/YY/MM\nhttps://doi.org/XXXXXXX.XXXXXXXACM Reference Format:\nJiaoyi Zhang, Liqiang Peng, Mo Sha, Weiran Liu, Xiang Li, Sheng Wang,\nFeifei Li, Mingyu Gao, and Huanchen Zhang. 2025. Femur: A Flexible Frame-\nwork for Fast and Secure Querying from Public Key-Value Store. In Proceed-\nings of 2025 ACM SIGMOD/PODS Conferences. ACM, New York, NY, USA,\n17 pages. https://doi.org/XXXXXXX.XXXXXXX\n1 Introduction\nThe growing data volumes and pervasive cloud services have spurred\nefforts to protect user data privacy. Protecting user queries to public\ndatasets is as critical as protecting the underlying database. For\nexample, users checking phone numbers against a public scam\ndatabase are vested in keeping the numbers private to the hosting\nserver. Similarly, users querying sensitive health or financial data\nrisk potential discrimination (e.g., biased treatment in insurance or\nemployment) if their queries are revealed. These use cases highlight\nthe need for secure and efficient query mechanisms for accessing\npublic key-value stores while keeping queries confidential.\nPrivate Information Retrieval (PIR) schemes [ 28,29,45,50,59,60,\n64] have emerged to address the above concerns. They allow users\nto upload encrypted keys for confidential server-side computation\nand results return without decryption. The entire process ensures\nthat sensitive information remains secure. Despite advancements\nin PIR techniquesâ€”such as improvements in cryptographic proto-\ncols [ 7,23,31,42,57], encoding strategies [ 13], and pre-processing\noptimizations [ 25,27,31,95]â€”they still face challenges with scaling.\nTo guarantee query path privacy, most designs must process all\ntheğ‘›key-value pairs in the database with up to ğ‘‚(ğ‘›)complexity,\nleading to high query response time in large-scale applications. For\nexample, Pantheon [ 7] takes 1.15 seconds to execute a query on\nonly 65,536 key-value pairs.\nIn this paper, we propose a more practical solution that relaxes se-\ncurity while upholding theoretical guarantees. Existing PIR schemes\nyield impractical processing times for large real-world datasets,\nwith delays ranging from seconds to hours (Pantheon [ 7] takes\nover 2 hours on 224records). Moreover, full dataset obfuscation\n1arXiv:2503.05376v1  [cs.CR]  7 Mar 2025\n\n2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany Jiaoyi Zhang et al.\nmay not be necessary in many applications. For example, an Amer-\nican user may only need to hide their queries within the U.S. phone\nnumbers rather than the global dataset. In fact, industry practices of-\nten relax security by using hash functions [ 43] to partition datasets\ninto smaller buckets to improve query performance by reducing\nthe number of key-value pairs involved per query. However, this\nmethod lacks formal security guarantees: the bucket IDs are ex-\nposed during computation, and an uneven hash partition could\nproduce single-pair buckets, thus revealing the userâ€™s query.\nWe introduce Femur, a framework enabling users to control\nand balance performance and privacy with theoretical security\nguarantees. Femur allows users to configure from no security to\nfull security backed by our formal definition of â€œrelaxed securityâ€\n(i.e., distance-based indistinguishability ). Depending on the chosen\nlevel, Femurâ€™s user-side module automatically sends an obfuscated\nrange of keys (including the userâ€™s real key) to the server, ensuring\nthat the real key is indistinguishable under the relaxed security\nlevel without unnecessary performance loss. When this key range\nextends to the entire database, Femur achieves full privacy as before.\nFemur consists of three main components: key-to-position con-\nversion, obfuscated range generation, and adaptive key-value re-\ntrieval. First, the user-side key-to-position conversion module maps\nquery keys to their storage locations within the database, similar to\nexisting keyword PIR schemes. The novelty lies in that we use the\nPGM-index [ 40], a state-of-the-art, space-efficient learned index for\nthe mapping. The prediction error of PGM-index can be handled\ntogether with the obfuscated query range. Learned indexes are typ-\nically faster and smaller than traditional indexes (e.g., B+trees) and\ncan therefore speed up the conversion while significantly reducing\nthe index size stored on the client side.\nSecond, the obfuscated range generation module adds noise to the\nrange predicted by the PGM-index before sending it to the server so\nthat the server-side computation is confined to the key-value pairs\nwithin the range. This obfuscated range satisfies distance-based\nindistinguishability with a user-specified security level guaranteed\nby our theory. The higher the security level, the slower the query.\nThird, the server-side adaptive key-value retrieval module em-\nploys a cost model to choose the best strategy, trading between com-\nputation and network bandwidth. For high-bandwidth networks,\nthe client side downloads all key-value pairs in the obfuscated\nrange (of length ğ‘ ) in plaintext. This approach conceals the query\nkey without homomorphic computation but incurs ğ‘‚(ğ‘ )transmis-\nsion complexity. When the bandwidth is limited, we propose a novel\nvariable-range PIR scheme with a transmission complexity of ğ‘‚(1)\nbut a computation complexity of ğ‘‚(ğ‘ ).\nOur experiments show that Femur scales well on a dataset con-\ntaining 200 million records (a size infeasible for previous solu-\ntions) and outperforms the two baselines (Chalamet [ 25] and Pan-\ntheon [ 7]) by 1.05Ã—and 7.71Ã—, respectively under full security, and\nby 163.9Ã—and 1206.1Ã—, respectively with a relaxed security guar-\nantee. Additionally, Femurâ€™s offline initialization phase only takes\na few minutes, compared to several hours from previous designs.\nWe also integrated Femur into Redis [ 1], a popular in-memory key-\nvalue store, and demonstrated that Femur also supports efficient\nvalue updates in real-world scenarios.\nWe make the following contributions.â€¢We identify that full security prevents current PIR schemes from\nscaling and is often unnecessary in real-world applications.\nâ€¢We introduce relaxed security by formally defining â€œdistance-\nbased indistinguishabilityâ€ to allow users to trade between perfor-\nmance and privacy while offering provable security guarantees.\nâ€¢We propose Femur, a user-centric framework that eliminates\nunnecessary computational and communication costs by incor-\nporating a learned index with a novel variable-range PIR scheme.\nâ€¢We demonstrate Femurâ€™s superior performance and scalability\nover the baselines via a thorough evaluation.\n2 Preliminaries\n2.1 Private Retrieval From Public Data\nThis paper focuses on user privacy in public key-value stores by\nensuring secure lookups that hide both the usersâ€™ query keys and\naccess patterns. This is often realized by traditional PIR schemes,\nincluding keyword PIRs and index PIRs. Depending on whether pre-\nprocessing is allowed, PIR schemes can be further categorized as\nstateless PIR (without pre-processing ) [ 7,8,13,59] often with linear\ncomputational complexity, and as stateful PIRs [ 25,29,31,45,50,95]\nwhich leverage offline pre-processing to reduce online computation.\n2.1.1 Index-PIR. Index PIRs assume that the user knows the exact\nlocation of the data to be queried. Typically, the user encodes the\nlocation as a one-hot vector, encrypts it, and sends it to one or more\nuntrusted servers for private retrieval. The server then performs\na privacy-preserving inner product between the encrypted query\nand its dataset, returning the encrypted result to the user. We focus\non the single-server scenario, as the multi-server setup relies on\nthe less practical assumption of non-colluding servers.\nExisting index-PIR schemes like SimplePIR [ 45] and FrodoPIR [ 31]\nreduce online computation via one-time pre-computation, where\nusers download specific â€œhintsâ€ in the offline phase. However, their\nonline phase still scales linearly with dataset size. Piano [ 95] takes\na different approach where the user continuously uploads sets of\nmultiple locations during pre-processing and obtains the XOR of\nthese data as hints. The online query must match one of these\nhints, accelerating queries but incurring offline communication\noverhead equal to the dataset size, rendering it impractical. Since\noffline interactions between the user and the server are inevitable\n(e.g., establishing a communication channel), Femur also allows\ntransferring hints during the offline phase. However, it ensures\nthat the hint size remains significantly smaller than the dataset. To\nachieve this, Femur introduces a novel design that leverages learned\nindexes for faster pre-processing and efficient online processing.\nAdditionally, optimizations in cryptographic primitives [ 60,64]\nand batch processing [ 65,87] are orthogonal to our design and\ncould enhance our framework with minor adjustments.\n2.1.2 Keyword-PIR. In real-world scenarios, users often do not\nknow the exact location of the data they wish to retrieve. Keyword\nPIRs address this limitation by allowing queries based on keywords\nand are typically implemented on top of index PIRs. The earliest\napproach [ 28] achieves this by mapping keywords to data locations\nthrough logarithmic rounds of communication. However, this in-\ntroduces substantial overhead, rendering the method inefficient.\n2\n\nFemur: A Flexible Framework for Fast and Secure Querying from Public Key-Value Store 2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany\nFor example, retrieving data from one million key-value pairs may\nrequire up to 21 round trips, resulting in significant overhead.\nRecent keyword PIR schemes reduce rounds to one. Approaches\nbased on fully homomorphic encryption (FHE) [ 23,42] achieve\nthis by using equality operators [ 7,57]. In these schemes, the user\nencrypts the desired keyword and uploads it to the server, which\nperforms an equality check between the encrypted keyword and\nall keys in the dataset. This results in an encrypted one-hot vector\nthat can be used for consequent index PIR. While these methods\nreduce communication, equality checks remain computationally\nexpensive. To further enhance efficiency, Chalamet [ 25] employs\ntechniques such as cuckoo hashing or filters to map keys to multiple\npotential locations, using index PIR to retrieve and combine these\nvalues. Compared to FHE-based methods, Chalamet reduces the on-\nline server-side computations, but still incurs high communication\noverhead and requires substantial pre-processing.\nThese schemes improve retrieval efficiency while maintaining\nfull security. However, Femur provides extra flexibility by allowing\nusers to adjust security levels according to their specific needs,\nachieving a better balance between performance and privacy.\n2.2 Differential Privacy\nDifferential privacy (DP) is a rigorous mathematical method widely\nused in database systems, aimed at preventing adversaries from\ninferring individual data from query results by adding controlled\nnoise. Classical DP applications assume the presence of a trusted\nparty that collects all the data and adds noise to the entire dataset, an\napproach adopted by various organizations including Google [12]\nand Uber [ 46,47]. In contrast, Local Differential Privacy (LDP) re-\nmoves the need for a trusted party by allowing users to obfuscate\ndata locally before sharing, as used by Google [ 9,36], Apple [ 77],\nand Meta [ 61]. Besides, users have the flexibility to choose their de-\nsired privacy level based on the sensitivity of their information [ 11].\nDefinition 1 (Local Differential Privacy, LDP). An obfus-\ncation mechanismM:Dâ†’Osatisfiesğœ–-LDP with privacy level ğœ–\n(ğœ–â‰¥0) if for anyğ‘¥,ğ‘¥â€²âˆˆDand any output ğ‘¦âˆˆO, we have\nPr[M(ğ‘¥)=ğ‘¦]â‰¤ğ‘’ğœ–Â·Pr[M(ğ‘¥â€²)=ğ‘¦] (1)\nThe private parameter ğœ–represents the privacy level, with larger\nğœ–indicating weaker privacy protection provided by M. To sat-\nisfy the condition of LDP, Mmust effectively hide all differences\nbetween data entries, including the difference between the maxi-\nmum and minimum values. In practice, this often requires adding a\nsignificant amount of noise, leading to reduced usability.\nDefinition 2 (Distance-based Local Differential Privacy).\nAn obfuscation mechanism M:Dâ†’Osatisfiesğœ–-dLDP with privacy\nlevelğœ–(ğœ–â‰¥0) if for anyğ‘¥,ğ‘¥â€²âˆˆDsuch that|ğ‘¥âˆ’ğ‘¥â€²|â‰¤ğ‘¡, and for any\npossible output ğ‘¦âˆˆO, we have\nPr[M(ğ‘¥)=ğ‘¦]â‰¤ğ‘’ğ‘¡ğœ–Â·Pr[M(ğ‘¥â€²)=ğ‘¦] (2)\nAccording to this definition, the indistinguishability between\nany two sensitive data points decreases as the distance ğ‘¡between\nthem increases [ 26]. This strikes a balance between privacy and\nutility and is more suitable for practical application scenarios.Theorem 1 (Post-Processing [ 35]).LetM:Dâ†’Obe an\nğœ–-dLDP obfuscation mechanism, and ğ‘“:Oâ†’Oâ€²be any randomized\nfunction. Then, ğ‘“â—¦M remainsğœ–-dLDP.\nImmunity to post-processing is a key property of differential\nprivacy, meaning that arbitrary transformations can be performed\non the output without compromising privacy guarantees.\n2.3 Learned Indexes\nSimilar to PIR schemes that employ filters for keyword PIR, index\nstructures (e.g., B+tree [ 21] or learned indexes) can also be used\nto map keywords to their corresponding locations before retrieval.\nLearned indexes, first introduced by Kraska et al. [ 51], utilize data\ndistribution characteristics to build more efficient index structures.\nSpecifically, it focuses on data distribution and rank to map a given\nkey to its corresponding memory address [ 33,53,84,86,91,92]. This\noperation can be understood as a cumulative distribution function\n(CDF) applied to the key distribution.\nMost learned indexes follow a similar structure and search pro-\ncess. Given a set of key-value pairs, they use a construction algo-\nrithm to create a tree structure, typically consisting of a root node,\none or more levels of internal nodes, and leaf nodes that manage\nthe key-value pairs. Each node contains a simple linear model and a\nsmall amount of metadata representing the distribution of a subset\nof the entire dataset. To query a key, the learned index performs\na top-down traversal. At each level, a model is used to predict the\nnext nodeâ€™s location to be accessed at the next level, continuing\nuntil a leaf node is reached. The model in the leaf node predicts\nthe position (i.e., rank) of the query key, and a last-mile search is\nperformed within a small range to determine the exact key location.\n3 Motivation\nWe focus on a scenario where a server hosts a public key-value store,\nallowing users to retrieve values by their keys without revealing\nwhich specific keys they are querying. Such scenarios are common,\nincluding untraceable browsing [ 44,50,85], contact discovery [ 22,\n32], password leakage detection [ 78], anonymous messaging [ 13,14,\n52,62], etc. For example, at WWDC 2024, Apple introduced a live\ncaller ID lookup feature that enables users to obtain information\nabout incoming calls from a public dataset without revealing the\nqueried phone number to the server. This feature helps safely block\nnuisance calls, offering both security and convenience.\nIn such scenarios, typically the server is the data owner. The\nusers can privately perform read-only lookups to the public key-\nvalue store, but usually not allowed to modify the data. Only the\nserver may periodically update its data as needed. This is funda-\nmentally different from the cases where the users outsource their\nown databases to untrusted servers. But we emphasize that it is\nstill a common and important problem in real world, as exemplified\nabove. For example, an investor may wish to privately retrieve infor-\nmation about a particular stock, such as its trading record, without\nintending to update any public data. However, these queries often\ninvolve sensitive information (e.g., investment interests), necessi-\ntating privacy guarantees.\nMost existing approaches rely on PIR schemes to support such\nscenarios. As discussed in Section 2.1, PIR usually uses an encrypted\none-hot bitmap to represent the location of the desired key-value\n3\n\n2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany Jiaoyi Zhang et al.\npair, and performs homomorphic inner products with all key-value\npairs in the dataset, thereby concealing the queried key. However,\ntheir computational cost scales with the size of the database, making\nthem impractical for large datasets. For example, Pantheon [ 7] takes\nseveral hours to execute a query on a dataset containing 16,777,216\nkey-value pairs. Although Pantheon can parallelize computations\nby distributing the dataset across multiple machines, this does not\nfundamentally reduce the computational complexity of each query,\nleaving the scalability problem unresolved.\nIn this paper, we argue that such impractical performance of\nexisting schemes stems from their rigid guarantees of full security,\nwhich require all key-value pairs to be involved in computation or\ntransmission. Current PIR schemes cannot bypass this requirement,\neven with optimized cryptographic algorithms or preprocessing.\nHowever, this requirement is not always necessary in practical ap-\nplications. In real-world scenarios, usersâ€™ security requirements are\nindependent of the dataset size and often remain fixed. For exam-\nple, when protecting a userâ€™s address, the user may be comfortable\nrevealing her country (e.g., the United States) but not her city (e.g.,\nSan Francisco). This allows the query to be executed securely over\nall addresses within the country, rather than over the entire global\ndataset. Moreover, in a geographic database like Open Street Map,\nwhich is keyed by latitude and longitude, nearby data items in the\ndatabase are geographically close to each other. Practical appli-\ncations often involve scenarios where the storage location in the\ndatabase is correlated with the value of the key. Meanwhile, such\nâ€œweakerâ€ security is common in industrial solutions, which often\nuse hash functions to partition the complete dataset into smaller\nsubsets. However, such methods not only leak the bucket ID where\nthe queried key is located but also fail to provide provable privacy\nguarantees in general scenarios. For example, if a bucket contains\nonly a single entry, the queried key is immediately exposed.\nTo address these issues, we believe it is essential to offer flexible\ndegrees of relaxed security based on the userâ€™s specific needs. This\nflexibility should still offer provable theoretical guarantees at all\nsecurity levels. With a solid theoretical foundation, users can feel\ncomfortable using more practical solutions that are not fully secure.\nTo achieve this goal, the first requirement is to formally define how\nto relax security levels with theoretical guarantees. Then, a practi-\ncal system design is needed to realize flexible privacy and ensure\nefficient query processing at all security levels. In addition, it should\nnot impose significant computational or storage burdens on users,\nmeaning offline computation and storage should be minimized.\n4 Relaxed Security for Private Retrieval\nOur objective is to develop a flexible and scalable framework that\nenables users to privately retrieve the value associated with a key\nfrom a public key-value store. The primary security goal is to hide\nthe userâ€™s lookup queries from the server, while the serverâ€™s key-\nvalue data are public. Our scenario resembles that of the keyword\nPIR [7, 13, 25, 57], with the key distinction that it permits the flex-\nibility of enforcing different levels of relaxed security based on\nspecific user requirements. In this section, we formalize our novel\ndefinition of relaxed security and the corresponding threat model.4.1 Problem Formulation\nLetğ·ğµ={(ğ‘˜0,ğ‘£0),(ğ‘˜1,ğ‘£1),...,(ğ‘˜ğ‘›âˆ’1,ğ‘£ğ‘›âˆ’1)}denote the set of pub-\nlic key-value pairs held by the server, where the key set ğ¾=\n{ğ‘˜0,ğ‘˜1,...,ğ‘˜ ğ‘›âˆ’1}serves as the primary key of the database (no\nduplication). ğ·ğµis sorted by primary keys. Each key-value pair is\nstored in plaintext with a uniform length to prevent attackers from\ninferring the queried key based on length variations. Let ğ‘˜target be\nthe querying key of the user, and ğ‘£target be the corresponding value.\nWe discuss our problem below in terms of correctness and privacy.\n4.1.1 Correctness. Ifğ‘˜targetâˆˆğ¾, the server must return the corre-\nspondingğ‘£target ; otherwise, it returns null, allowing the client to\nreadily verify that ğ‘˜target does not exist.\n4.1.2 Privacy: distance-based indistinguishability. Our privacy defi-\nnition aims to protect query privacy within a distance less than ğ‘¡in\nthe database ğ·ğµ. Here, distance refers to the difference in storage\npositions of two querying keys within the sorted key-value store,\nwithğ‘¡representing the maximum allowable distance specified by\nthe client. Let ğ‘ğ‘–andğ‘ğ‘—represent queries corresponding to keys\nğ‘˜ğ‘–andğ‘˜ğ‘—, respectively (possibly chosen by the adversary), where\n|ğ‘–âˆ’ğ‘—|â‰¤ğ‘¡. The user selects one query to execute, while the ad-\nversary observes the resulting events, denoted by ğ‘‚ğ‘–andğ‘‚ğ‘—(e.g.,\nthe key-value pairs involved in the computation), and attempts to\ndistinguish which query was executed.\nInspired by LDP introduced in Section 2.2, we define a scheme\nas achieving distance-based indistinguishability (denoted as ğœ–-dist\nindistinguishability) for a given maximum allowable distance ğ‘¡\n(ğ‘¡>0), if there exists a non-negative constant ğœ–such that for any\npair of queries ğ‘ğ‘–andğ‘ğ‘—where|ğ‘–âˆ’ğ‘—|â‰¤ğ‘¡(ğ‘–,ğ‘—âˆˆ[0,ğ‘›)), and for all\npossible adversarial observations ğ‘‚in the observation space Î©, the\nfollowing condition holds:\nPr[ğ‘‚|ğ‘ğ‘–]â‰¤ğ‘’ğœ–Â·Pr[ğ‘‚|ğ‘ğ‘—] (3)\nwhere Pr[ğ‘‚|ğ‘ğ‘–]represents the probability of the observation ğ‘‚\ngiven thatğ‘ğ‘–has been issued. This ensures that the adversary can-\nnot distinguish between queries ğ‘ğ‘–andğ‘ğ‘—based on observed events,\nthereby maintaining distance-based indistinguishability. The pa-\nrametersğœ–andğ‘¡together determine the security guarantees, where\nğœ–is the privacy parameter and ğ‘¡is the maximum allowable distance\nbetween two queries for the indistinguishability guarantee to hold.\nWhenğ‘¡is fixed, increasing ğœ–weakens the indistinguishability, re-\nsulting in more relaxed security guarantees. Conversely, when ğœ–is\nfixed, a larger ğ‘¡strengthens the security guarantees. In Femur, the\nratio of these two parameters determines the expected number of\ndata points within the obfuscation range, as discussed in Section 7.\nTo minimize user burden, we set the default value of ğœ–to2âˆ’6,\nsinceğ‘¡is generally more intuitive for users to adjust. This empirical\ndefault value of ğœ–, chosen as a power of 2, aligns with the highest\nsecurity levels in prior DP-related work [ 54]. Users can adjust ğ‘¡\nto specify how many neighboring queries should be included to\nmake the real query indistinguishable among them, allowing for\na trade-off between privacy and performance based on individual\nneeds. For example, consider a dataset of 100 queries and ğ·ğµ=\n{(ğ‘˜0,ğ‘£0),(ğ‘˜1,ğ‘£1),...,(ğ‘˜99,ğ‘£99)}. Suppose the user queries ğ‘˜ğ‘–=ğ‘˜20\nand setsğ‘¡to 10. In this case, any potential output corresponding to\na queryğ‘ğ‘—for any key within the range [ğ‘˜10,ğ‘˜30]and the query ğ‘20\nforğ‘˜20satisfies Equation (3). This ensures that adversaries cannot\n4\n\nFemur: A Flexible Framework for Fast and Secure Querying from Public Key-Value Store 2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany\ndetermine which specific key the user is querying within [ğ‘˜10,ğ‘˜30],\neven when observing the access pattern.\nIntuitively, we can obfuscate the real query by adding fake\nqueries. Let ğ‘†ğ‘–represent the set of queries that includes ğ‘ğ‘–and\nextra fake queries generated by the client through a perturbation\nmechanism that satisfies ğœ–-dist indistinguishability, where |ğ‘†ğ‘–|is\nthe number of queries. Then, the probability of correctly guessing\nğ‘ğ‘–is1\n|ğ‘†ğ‘–|. If|ğ‘†ğ‘–|=ğ‘›, full security and maximum uncertainty are\nachieved. If|ğ‘†ğ‘–|<ğ‘›, it corresponds to relaxed quantity-based ag-\nnosticism, reducing the uncertainty. Finally, if |ğ‘†ğ‘–|=1, no security\nis provided, as the adversary can directly infer the query.\n4.2 Threat Model\nThe user locally owns a trusted client machine. It aims to query\nsome data in the public key-value store on an untrusted server. The\nstored data is in plaintext. A semi-honest adversary may control the\nserver and want to steal sensitive information about which item is\nreturned. The adversary can monitor incoming queries from users,\nobserve server responses, and see any operations performed by\nthe server, including which data are involved in the computations\n(i.e., the data access patterns). It can measure the execution time,\nwhich depends on the number of queries but is not affected by\nwhich specific keys are queried. It can also monitor, record, and\nanalyze data communication between the client and the server,\neven utilizing any prior knowledge and observations, as well as the\nquery history. However, the adversary cannot break cryptographic\nschemes like AES. This ensures that the adversary cannot decrypt\nthe encrypted data (i.e., the querying key and the returned result).\nAnd it will not tamper with any data or code executed on the server.\n5 Design Overview\nFemur allows users to flexibly control the privacy-preserving gran-\nularity of queries for efficiently processing. Femur has two phases:\noffline initialization and online query phase. The initialization phase\nis executed offline only once when there is no database update, al-\nlowing users to gather essential information from the server. The\nonline query phase includes the entire process from client-side\nquery generation to receiving results from the server. In this sec-\ntion, we outline the key components and workflow of Femur.\n5.1 Offline Initialization Phase\nWhen a client arrives, it begins by exchanging one-time information\nwith the server during the initialization phase. Specifically, the\nserver provides the client with essential details about the database,\nincluding the number of key-value pairs, the bit length of each\npair, and the available retrieval schemes with their corresponding\nparameters. Besides, the server supplies an auxiliary index to allow\nthe client to locally convert querying keys into (approximate) server\nstorage locations. Femur offers two optional retrieval schemes:\nplaintext download with no extra parameters, and variable-range\nPIR, which requires three cryptographic parameters: ğ‘,ğ‘, andğ‘\n(as detailed in Section 8.2). The client then constructs the public\nand private cryptographic keys needed to encrypt/decrypt queries\nin the variable-range PIR scheme. Upon completing this step, the\nclient sends its cryptographic public key to the server. The server\nretains each clientâ€™s public key for future interactions.The auxiliary index structure provided by the server is the PGM-\nindex, a space-efficient learned index that does not store the actual\nkey values but only the model parameters (e.g., slopes, intercepts,\nand partitioning keys). This reduces the data transmitted to clients\nto tens of KB to a few MB, greatly cutting initialization overhead.\nIf the key-value store is updated (usually periodically by the\nserver; Section 3), the initialization phase needs to be re-executed.\nParticularly, the new auxiliary index structure needs to be synchro-\nnized with the clients. Section 9 further discusses the details.\n5.2 Online Query Phase\nThe online phase includes the entire query lookup process. After\ndetermining the querying key ğ‘˜and the desired privacy level ğ‘¡, the\nclient generates a secure query range utilizing three components\nprovided by Femur: key-to-position conversion, obfuscated range\ngeneration, and scheme selection. The obfuscated range boundaries\nand the selected retrieval scheme are then sent to the server. The\nserver processes the query using the specified scheme and returns\nthe corresponding key-value pairs. Finally, the client retrieves the\ndesired value by performing a simple verification. Below we briefly\ndescribe the main building blocks of Femur, as shown in Figure 1.\n5.2.1 Key-to-Position Conversion. We employ the PGM-index, a\nlearned index structure, to map the userâ€™s querying key to its pos-\nsible locations within the dataset (Section 6). It guarantees that\nthe querying key will be found within these positions unless it\ndoes not exist in the database. The parameter ğœ€datain the PGM-\nindex determines the range of possible positions. For a given key\nğ‘˜, the PGM-index outputs a predicted position Ë†ğ‘¦, and the possible\nlocations are then bounded by [Ë†ğ‘¦âˆ’ğœ€data,Ë†ğ‘¦+ğœ€data].\n5.2.2 Obfuscated Range Generation. In this step, we efficiently\nconvert the range [Ë†ğ‘¦âˆ’ğœ€data,Ë†ğ‘¦+ğœ€data]into a obfuscated range\n[ğ‘™,ğ‘Ÿ]=[Ë†ğ‘¦âˆ’ğœ€dataâˆ’ğ‘¡ğ‘™,Ë†ğ‘¦+ğœ€data+ğ‘¡ğ‘Ÿ]. Specifically, this obfuscated\nrange is generated using a noise generation mechanism that satisfies\ndistance-based indistinguishability (Section 7). It ensures that the\nserver cannot infer the real key being queried, while eliminating\nthe need for all data points to be involved in the computation.\n5.2.3 Scheme Selection. Once the obfuscated range is determined,\nour framework uses a cost model to select the most efficient re-\ntrieval scheme for the current query between plaintext downloads\nand variable-range PIRs (Section 8). The cost model is lightweight\nand can be executed efficiently on the client side, leading to minimal\noverhead. For plaintext downloads, only the unencrypted bound-\nariesğ‘™andğ‘Ÿare sent to the server. For variable-range PIRs, besides\nğ‘™andğ‘Ÿ, the left boundary ( Ë†ğ‘¦âˆ’ğœ€data) of the predicted range is en-\ncrypted and also sent to the server.\n5.2.4 Server-Side Query Processing. Upon receiving the query re-\nquest, the server processes the query using the designated retrieval\nscheme (Section 8). For plaintext downloads, the server sends the\nkey-value pairs in the range [ğ‘™,ğ‘Ÿ]directly back to the client in\nunencrypted form. For variable-range PIR, the server performs\nhomomorphic encryption computations and returns a single ci-\nphertext containing all key-value pairs in [Ë†ğ‘¦âˆ’ğœ€data,Ë†ğ‘¦+ğœ€data]. We\ncarefully control ğœ€dataand the plaintext encoding scheme to guar-\nantee the queried pair is always returned. Note that the server is\n5\n\n2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany Jiaoyi Zhang et al.\nServerClient\nkey ğ’Œ, privacy param ğ’•Predicted Range: [\"ğ‘¦âˆ’ğœ€!\"#\",\"ğ‘¦+ğœ€!\"#\"]Obfuscated Range: ğ‘™,ğ‘Ÿâ†[&ğ‘¦âˆ’ğœ€!\"#\"âˆ’ğ‘¡$,&ğ‘¦+ğœ€!\"#\"+ğ‘¡%]Obfuscated Range GenerationPGM-Index\nScheme Selection(Cost Model)(1) Plaintext Download      Params: ğ‘™,ğ‘Ÿ(2) Variable-Range PIR      Params: ğ‘™,ğ‘Ÿ,ğ¸\"ğ‘¦âˆ’ğœ€!\"#\"\npublic key-value pairsâ€¦ğ‘€!ğ‘€\"ğ‘€#ğ‘€$%\"ğ‘€$ğ‘…ğ‘œğ‘œğ‘¡â€¦PGM-IndexKey-Value Retrieval(1) Return:(2) Return: ğ¸ğ‘›ğ‘ğ‘Ÿğ‘¦ğ‘ğ‘¡ğ‘’ğ‘‘[2ğ‘¦\nğ‘˜ğ‘£!ğ‘˜ğ‘£\"â€¦â€¦ğ‘˜ğ‘£$â€¦â€¦â€¦â€¦â€¦ğ‘˜ğ‘£&â€¦â€¦â€¦ğ‘˜ğ‘£$â€¦â€¦â€¦â€¦â€¦ğ‘˜ğ‘£&â€¦â€¦â€¦\nFigure 1: The Core Components of Femur Framework.\nunaware of the specific granularity of the querying key or the userâ€™s\nprivacy settings throughout the retrieval and transmission process.\n6 Key-to-Position Conversion\nTo facilitate privacy-preserving data retrieval on the server side, the\nquerying key needs to be converted into the corresponding position\nof the key-value pair in the dataset, as in traditional keyword PIR\nschemes. Database index structures [ 15,21,33,40,53,84,89â€“92]\nare exactly designed for such key-to-position conversion. In Femur,\nwe propose to apply PGM-indexes to perform this conversion on\nthe client side, allowing direct processing of the querying key in\nplaintext. We will discuss the advantages and disadvantages of\nstoring index structures on the client side in Section 6.1, along with\nthe specific requirements for selecting a suitable index structure\nfor our scenario. Then, we introduce the details of our choice, the\nPGM-index, in Section 6.2.\n6.1 Client-Side Indexes\nIn Femur, while the index structure used for key-to-position con-\nversion resides on the client side, it is created and maintained by\nthe server, with the client only storing a static copy. This static\ncopy requires no maintenance on the client side and functions like\npre-downloaded hints in other PIR schemes [ 25,31,45]. Sharing\nthis index of the public database poses no security concerns.\nThe benefits of this approach align with those of PIR schemes,\nas static index copies can be downloaded during the initialization\nphase and serve as a local cache to accelerate query execution\nduring the online phase. Specifically, in Femur, the client-side in-\ndex efficiently maps query keys to predicted locations, which are\nthen expanded using our obfuscated range generation method. This\nnarrows the range of key-value pairs involved in subsequent com-\nputations, significantly enhancing query performance. In contrast,\nprior schemes speed up computations by pre-computing parts of the\nlookup process but fail to reduce the overall data volume processed.\nThe main drawback of storing a static copy on the client side is\nthe potential for index staleness due to database updates. Similar\nto PIR solutions [ 66], Femur restricts to periodic batch updates for\nkeys (Section 9). Thus the overhead for the client to fetch the latest\nindex from the server is insignificant. Moreover, selecting a compact\nindex could mitigate this issue by reducing the time required to\ndownload updated versions, further improving efficiency.\nConsequently, we have two requirements for the index structure.\nFirst, to map querying keys to database locations, the index should\nlookup ğ‘˜!\"ğ‘€#,%(ğ‘˜!\",ğ‘ ğ‘™,ğ‘–ğ‘)ğ‘€#,#(ğ‘˜#$,ğ‘ ğ‘™,ğ‘–ğ‘)ğ‘€#,&(ğ‘˜\",ğ‘ ğ‘™,ğ‘–ğ‘)ğ‘€#,'(ğ‘˜!%$,ğ‘ ğ‘™,ğ‘–ğ‘)ğ‘€#,((ğ‘˜!&',ğ‘ ğ‘™,ğ‘–ğ‘)ğ‘€#,\"(ğ‘˜%(,ğ‘ ğ‘™,ğ‘–ğ‘)ğ‘€#,!(ğ‘˜!'',ğ‘ ğ‘™,ğ‘–ğ‘)ğ‘€%,%(ğ‘˜#$,ğ‘ ğ‘™,ğ‘–ğ‘)ğ‘€%,#(ğ‘˜!%$,ğ‘ ğ‘™,ğ‘–ğ‘)ğ‘€%,&(ğ‘˜\",ğ‘ ğ‘™,ğ‘–ğ‘)ğ‘€%,\"(ğ‘˜!'',ğ‘ ğ‘™,ğ‘–ğ‘)ğ‘€&,&(ğ‘˜\",ğ‘ ğ‘™,ğ‘–ğ‘)\nğ‘˜ğ‘£\"â€¦ğ‘˜ğ‘£!\"â€¦â€¦ğ‘˜ğ‘£#$â€¦ğ‘˜ğ‘£%(ğ‘˜ğ‘£ğŸ”ğŸ‘ğ‘˜ğ‘£%+ğ‘˜ğ‘£%$ğ‘˜ğ‘£%%â€¦ğ‘˜ğ‘£!\"#â€¦ğ‘˜ğ‘£!$%â€¦ğ‘˜ğ‘£!%%â€¦145623Linear Key SearchModel Prediction135246Figure 2: An Example of the PGM-index.\nprovide item-level granularity rather than block-level granularity.\nThis allows each data point to be obfuscated at the finest granularity,\nthus reducing the noise (i.e., the number of fake queries) needed for\nindistinguishability. Traditional structures like B+trees [ 21], which\norganize data into pages or large leaf nodes, map querying keys to\npage IDs. Even if key-value pairs are evenly distributed, noise must\nbe introduced at the page level to satisfy privacy requirements,\nforcing the obfuscated range to include entire pages and increasing\nthe volume of accessed data. Second, the size of the index must\nremain small to reduce the overhead of the client when downloading\nthe index during initialization and after database updates. Large\nstructures (e.g., hints in the offline phase of many PIR schemes [ 25,\n31,45,60,95]) can become bottlenecks, especially in scenarios\nwhere multiple clients simultaneously access the server, leading to\nbandwidth constraints.\nWe find that learned indexes can effectively fulfill these two\nrequirements. First, learned indexes directly map a querying key to\na predicted position in the entire sorted array, providing item-level\nprediction granularity. We will thoroughly discuss the theoreti-\ncal differences between adding noise to these two indexes in Sec-\ntion 7. Second, they consume significantly less memory compared\nto B+trees, achieving compression rates for non-leaf nodes up to\n2,000Ã—smaller than the internal nodes of a B+tree [58, 84, 92].\n6.2 PGM-Indexes\nWe integrate a state-of-the-art space-efficient learned index, the\nPGM-index [ 40], into Femur to facilitate key-to-position conversion\nwith item-level granularity flexibility. As in Figure 2, the PGM-index\nconsists of multiple layers of simple linear regression models, where\neach model node is defined by only two parameters: slope and\nintercept (i.e., Ë†ğ‘¦=slopeÃ—ğ‘˜+intercept ), as well as the minimum\nkey (partitioning key) of the sub-dataset it manages. The index\n6\n\nFemur: A Flexible Framework for Fast and Secure Querying from Public Key-Value Store 2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany\nhas two hyperparameters: ğœ€model andğœ€data, which determine the\nmaximum allowable prediction errors for all non-leaf nodes and all\nleaf nodes, respectively. For a predicted position Ë†ğ‘¦, the desired key-\nvalue pair is guaranteed to reside in the range [Ë†ğ‘¦âˆ’ğœ€data,Ë†ğ‘¦+ğœ€data],\notherwise this pair is not in the key-value store.\nWe provide an example of the PGM-index with ğœ€model =1and\nğœ€data=2in Figure 2. To look up a given key ğ‘˜63, modelğ‘€0,0uses\nits slope and intercept to predict the next layerâ€™s position: Ë†ğ‘¦=\nğ‘ ğ‘™Â·ğ‘˜63+ğ‘–ğ‘=2. The next-layer models within the range [Ë†ğ‘¦âˆ’\nğœ€model,Ë†ğ‘¦+ğœ€model]=[ğ‘€1,1,ğ‘€1,3]are searched, locating ğ‘€1,1(since\nğ‘˜35â‰¤ğ‘˜63â‰¤ğ‘˜165). Then,ğ‘€1,1predicts[ğ‘€2,1,ğ‘€2,3]for layer 2 and\nğ‘€2,3is identified similarly. Recursively, ğ‘€2,3predicts position 64,\nnarrowing the last-mile search range to [ğ‘˜ğ‘£62,ğ‘˜ğ‘£66]withÂ±ğœ€data.\nFinally,ğ‘˜ğ‘£63is successfully located using binary search.\nFor each fixed dataset, the PGM-index is constructed using a\nbottom-up hierarchical approach. The bottom layer scans the or-\ndered key-value pairs with a greedy algorithm of time complexity\nğ‘‚(ğ‘›). As described in [ 40], constructing the linear models reduces\nto constructing the convex hull of a set of points. Starting at index\nğ‘–=0, the algorithm checks whether the current ğ‘–-th key-value\npair can be added to the current latest ğ‘—-th model without exceed-\ningğœ€data. If true, it moves to the next key-value pair. Otherwise,\na linear model (i.e., slope and intercept) is determined by the line\nthat splits the rectangle into two equal-sized halves. Then, a new\nmodelğ‘—+1is initialized starting from index ğ‘–. This ensures that\neach model manages key-value pairs constrained by a rectangle\nof height 2ğœ€data. This process continues until all key-value pairs\nare scanned. Upper layers follow a similar approach but operate\non sub-datasets, where prediction errors are constrained by ğœ€model .\nFor example, when constructing layer 0, the algorithm processes\nthe pairs{{ğ‘˜0,0},{ğ‘˜35,1},{ğ‘˜165,2},{ğ‘˜199,3}}. Construction contin-\nues until a single model remains at the top layer. More details are\nprovided in [ 40]. To maintain simplicity within Femur, we use the\ndefault values of the PGM-index ( ğœ€data=64,ğœ€model =4) across all\ndatasets, avoiding parameter tuning complexity.\nThe PGM-index is compact, reducing communication overhead\nduring initialization. During the online phase, it can quickly convert\na queried key to a predicted range containing the desired keyâ€™s\nlocation. The size of this range is 2Ã—ğœ€data+1, where all positions\nexcept the correct one act as fake queries. However, the predicted\nrange does not yet satisfy distance-based indistinguishability, which\nwill be addressed in the next section.\n7 Obfuscated Range Generation\nIn this section, we describe how to generate obfuscated ranges that\nsatisfy distance-based indistinguishability. Femur allows users to\nflexibly specify a relaxed security level for each query. It then em-\nploys a noise-generation mechanism, which expands the predicted\nrange[Ë†ğ‘¦âˆ’ğœ€data,Ë†ğ‘¦+ğœ€data], derived from the key-to-position conver-\nsion step, to a wider obfuscated range [ğ‘™,ğ‘Ÿ]. To achieve both high\nperformance and sufficient security, the length of the obfuscated\nrange is set to the minimum value that still ensures distance-based\nindistinguishability depending on the user-specified security level.\nSpecifically, any two queries whose keys are within a specified\ndistanceğ‘¡are indistinguishable to the adversary. Larger ğ‘¡requires\na wider obfuscated range. The obfuscated range [ğ‘™,ğ‘Ÿ]is then sentto the server, and only data points within this range need to be\ninvolved in the computation and communication.\nWe first employ the exponential mechanism, a widely used ap-\nproach in differential privacy, to generate noise. The exponential\nmechanism assigns probabilities to points in a given set D, typically\nbased on the distance between the point ğ‘–âˆˆDand the real value ğ‘¥:\nğ‘ğ‘¥,ğ‘–=Pr[ğ‘œ=ğ‘–]=ğ‘’âˆ’|ğ‘¥âˆ’ğ‘–|Â·ğœ–dp/4ğ‘¡\nÃ\nğ‘—âˆˆDğ‘’âˆ’|ğ‘¥âˆ’ğ‘—|Â·ğœ–dp/4ğ‘¡(4)\nPoints closer to the real value would have higher probabilities of\nbeing chosen, thereby maintaining indistinguishability while reduc-\ning the impact on performance. A point is then randomly sampled\nas the new boundary based on these probabilities. This process is\ncarried out independently for the left and right boundaries, with\n[0,Ë†ğ‘¦âˆ’ğœ€data]and[Ë†ğ‘¦+ğœ€data,ğ‘›)as the given D, respectively, and\nproduces the obfuscated range [ğ‘™,ğ‘Ÿ]. We then have the following\ntheorem for the privacy guarantee.\nTheorem 2. The exponential mechanism described above provides\nğœ–dp-dist indistinguishability privacy guarantee for any pair of values\nğ‘¥,ğ‘¥â€²âˆˆD, where|ğ‘¥âˆ’ğ‘¥â€²|â‰¤ğ‘¡, and,ğ‘¡,ğœ–dp>0.\nProof. In our scenario, the observations ğ‘‚visible to the adver-\nsary consist of the boundaries (i.e., the outputs ğ‘™andğ‘Ÿ). We show\nthat our algorithm provides ağœ–dp\n2-dist indistinguishability privacy\nguarantee for each boundary. Let ğ‘œbe one of the two boundaries ğ‘™\norğ‘Ÿ, andDbe the set of potential new values that it is obfuscated\nto (i.e.,[0,Ë†ğ‘¦âˆ’ğœ€data]or[Ë†ğ‘¦+ğœ€data,ğ‘›)).\nPr[ğ‘‚=ğ‘œ|ğ‘¥]\nPr[ğ‘‚=ğ‘œ|ğ‘¥â€²]=ğ‘’ğœ–dp\n4ğ‘¡(|ğ‘¥â€²âˆ’ğ‘œ|âˆ’|ğ‘¥âˆ’ğ‘œ|)Â·Ã\nğ‘—âˆˆDğ‘’âˆ’|ğ‘¥â€²âˆ’ğ‘—|Â·ğœ–dp/4ğ‘¡\nÃ\nğ‘—âˆˆDğ‘’âˆ’|ğ‘¥âˆ’ğ‘—|Â·ğœ–dp/4ğ‘¡(5)\nBy applying the triangle inequality |ğ‘¥â€²âˆ’ğ‘œ|=|ğ‘¥â€²âˆ’ğ‘¥+ğ‘¥âˆ’ğ‘œ|â‰¤\n|ğ‘¥â€²âˆ’ğ‘¥|+|ğ‘¥âˆ’ğ‘œ|, we can get:\nğ‘’ğœ–dp\n4ğ‘¡(|ğ‘¥â€²âˆ’ğ‘œ|âˆ’|ğ‘¥âˆ’ğ‘œ|)â‰¤ğ‘’ğœ–dp\n4ğ‘¡|ğ‘¥â€²âˆ’ğ‘¥|â‰¤ğ‘’ğœ–dpÂ·ğ‘¡\n4ğ‘¡ (6)\nSimilarly,âˆ’|ğ‘¥â€²âˆ’ğ‘—|â‰¤|ğ‘¥â€²âˆ’ğ‘¥|âˆ’|ğ‘¥âˆ’ğ‘—|, and we get:\nâˆ‘ï¸\nğ‘—âˆˆDğ‘’âˆ’|ğ‘¥â€²âˆ’ğ‘—|Â·ğœ–dp/4ğ‘¡â‰¤âˆ‘ï¸\nğ‘—âˆˆD(ğ‘’|ğ‘¥â€²âˆ’ğ‘¥|Â·ğœ–dp/4ğ‘¡Â·ğ‘’âˆ’|ğ‘¥âˆ’ğ‘—|Â·ğœ–dp/4ğ‘¡)\nâ‰¤ğ‘’|ğ‘¥â€²âˆ’ğ‘¥|Â·ğœ–dp/4ğ‘¡Â·âˆ‘ï¸\nğ‘—âˆˆDğ‘’âˆ’|ğ‘¥âˆ’ğ‘—|Â·ğœ–dp/4ğ‘¡\nâ‰¤ğ‘’ğœ–dpÂ·ğ‘¡\n4ğ‘¡Â·âˆ‘ï¸\nğ‘—âˆˆDğ‘’âˆ’|ğ‘¥âˆ’ğ‘—|Â·ğœ–dp/4ğ‘¡(7)\nCombining both terms, we have the overall bound:\nPr[ğ‘‚=ğ‘œ|ğ‘¥]\nPr[ğ‘‚=ğ‘œ|ğ‘¥â€²]â‰¤ğ‘’ğœ–dpÂ·ğ‘¡\n4ğ‘¡Â·ğ‘’ğœ–dpÂ·ğ‘¡\n4ğ‘¡â‰¤ğ‘’ğœ–dp\n2 (8)\nSince the exponential mechanism is used for both boundaries, the\noverall algorithm satisfies the ğœ–dp-dist indistinguishability. â–¡\nThe ratio of the distance ğ‘¡and the privacy parameter ğœ–dpcontrols\nthe size of the obfuscated range. For smallerğ‘¡\nğœ–dp, the obfuscated\nrange is probabilistically reduced, which provides more relaxed\nprivacy but saves the computational and communication costs.\nIt is worth noting that the exponential mechanism involves cal-\nculating probabilities for all points in Dand then sampling from\n7\n\n2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany Jiaoyi Zhang et al.\nAlgorithm 1 LapZ-based Obfuscated Range Generation\nInput: Ë†ğ‘¦,ğœ€data, dataset size ğ‘›, privacy parameter ğœ–dp>0,ğ‘¡>0\nOutput: obfuscated range[ğ‘™,ğ‘Ÿ]\n1:function ModularLap Z(D,ğœ–dp,ğ‘¡)\n2:ğ‘¥â†ğ¿ğ‘ğ‘Z(2ğ‘¡\nğœ–dp)\n3:ğ‘¥â†ğ‘¥%|D|\n4: return D[ğ‘¥]\n5:end function\n6:Dğ‘™â†[ Ë†ğ‘¦âˆ’ğœ€data,Â·Â·Â·,1,0,ğ‘›âˆ’1,ğ‘›âˆ’2,Â·Â·Â·,Ë†ğ‘¦+ğœ€data]\n7:Dğ‘Ÿâ†[ Ë†ğ‘¦+ğœ€data,Â·Â·Â·,ğ‘›âˆ’2,ğ‘›âˆ’1,0,1,Â·Â·Â·,Ë†ğ‘¦âˆ’ğœ€data]\n8:ğ‘™â†ModularLapZ(Dğ‘™,ğœ–dp,ğ‘¡)\n9:ğ‘Ÿâ†ModularLapZ(Dğ‘Ÿ,ğœ–dp,ğ‘¡)\n10:ifğ‘™â‰¤Ë†ğ‘¦âˆ’ğœ€dataâ‰¤Ë†ğ‘¦+ğœ€dataâ‰¤ğ‘Ÿthen\n11: return[ğ‘™,ğ‘Ÿ]\n12:else ifğ‘Ÿ<ğ‘™â‰¤Ë†ğ‘¦âˆ’ğœ€dataorË†ğ‘¦+ğœ€dataâ‰¤ğ‘Ÿ<ğ‘™then\n13: return[ğ‘™,ğ‘›âˆ’1]âˆª[ 0,ğ‘Ÿ]\n14:else\n15: return[0,ğ‘›âˆ’1]\n16:end if\nthem, which is costly. To address this issue, we simulate the expo-\nnential mechanism by employing the widely used discrete Laplace\nmechanism [ 54], as defined in Definition 3, with ğœ†=2ğ‘¡/ğœ–dp. The\nprocess for obfuscated range generation using the discrete Laplace\nmechanism is outlined in Algorithm 1.\nDefinition 3 (Discrete Laplace Distribution). The discrete\nLaplace distribution with a scale parameter ğœ†is denoted as LapZ(ğœ†),\nwhere Zrepresent the set of integers. If a random variable ğ‘‹follows\nLapZ(ğœ†), its probability distribution is defined as:\nâˆ€ğ‘¥âˆˆZ,Pr[ğ‘‹=ğ‘¥]=ğ‘’1/ğœ†âˆ’1\nğ‘’1/ğœ†+1Â·ğ‘’âˆ’|ğ‘¥|/ğœ†(9)\nWe then prove that adding noise according to a discrete Laplace\ndistribution satisfies distance-based indistinguishability.\nTheorem 3. LapZ-based Obfuscated Range Generation pro-\nvidesğœ–dp-dist indistinguishability privacy guarantee for any pair of\nvaluesğ‘¥1,ğ‘¥2, where|ğ‘¥1âˆ’ğ‘¥2|â‰¤ğ‘¡, andğ‘¡,ğœ–dp>0.\nProof. This algorithm provides ağœ–dp\n2-dist indistinguishability\nprivacy guarantee for each boundary (i.e., Ë†ğ‘¦âˆ’ğœ€data,Ë†ğ‘¦+ğœ€data). Let\nğ‘™1andğ‘™2be the left boundaries of ğ‘¥1andğ‘¥2. The probability ratio\nofğ‘™1andğ‘™2being randomized to the same output value ğ‘œis:\nPr[ğ‘™1+ğ‘1]\nPr[ğ‘™2+ğ‘2]=Pr[ğ‘1=ğ‘œâˆ’ğ‘™1]\nPr[ğ‘2=ğ‘œâˆ’ğ‘™2]=ğ‘’âˆ’|ğ‘œâˆ’ğ‘™1|/ğœ†\nğ‘’âˆ’|ğ‘œâˆ’ğ‘™2|/ğœ†â‰¤ğ‘’ğœ–dp\n2 (10)\nwhereğ‘1andğ‘2follow LapZ(ğœ†). Since this mechanism is used\nfor both boundaries, the overall algorithm satisfies the ğœ–dp-dist\nindistinguishability: ğœ–overall =ğœ–ğ‘™+ğœ–ğ‘Ÿ=ğœ–dp/2+ğœ–dp/2=ğœ–dp.1â–¡\nTheorem 3 guarantees that for any two queries, ğ‘ğ‘–andğ‘ğ‘—, with\ndistance less than ğ‘¡, the probability of distinguishing between them\nis bounded by ğ‘’ğœ–dp. This covers two cases: when ğ‘ğ‘–â‰ ğ‘ğ‘—and when\n1Note that our proof now demonstrates that distance-based indistinguishability holds\nfor two boundaries derived from the predicted positions ( Ë†ğ‘¦). For practical use, the user\nshould set ğ‘¡â€²=ğ‘¡âˆ’2ğœ€dataas the final distance. Since\f\fË†ğ‘¦ğ‘–âˆ’Ë†ğ‘¦ğ‘—\f\fâ‰¤|ğ‘–âˆ’ğ‘—|+2ğœ€dataâ‰¤\nğ‘¡+2ğœ€data, this guarantees that the proposed mechanism preserves distance-based\nindistinguishability when applied to queries.the same query is submitted repeatedly (i.e., ğ‘ğ‘–=ğ‘ğ‘—). In both cases,\nthe adversary will be unable to distinguish the queries.\nSince the negative numbers sampled from LapZ(ğœ†)are mod-\nulo positive, the expected amount of noise added to one bound-\nary is E[ğ‘‹|ğ‘‹>0]=1\n1âˆ’ğ‘’âˆ’1/ğœ†â‰ˆ2ğ‘¡/ğœ–dp. Accounting for both\nboundaries, the expected length of the obfuscated range becomes\n4ğ‘¡/ğœ–dp+2ğœ€data+1, where the last two terms specify the output range\nfrom the PGM-index. This length is capped at the total number of\nkey-value pairs, i.e., ğ‘›. The total number of fake queries equals this\nlength minus one.\nDiscussion. Below, we analyze why B+tree requires more noise\ncompared to PGM-indexes. The B+tree index only needs to transfer\nnon-leaf nodes to the client, who uses it to obtain the ID of the leaf\nnode (i.e., page ID) containing the querying key, as well as the IDs\nof the key-value pairs at the left and right boundaries of this page\n(ğ‘™B+tree andğ‘ŸB+tree ). Note that noise must be added at the page-level\ngranularity. Otherwise, the adversary may infer that the querying\nkey is not located in any incomplete page within the range (e.g.,\nthe first or last page), leaking information.\nAssumeğ‘šis the number of key-value pairs per page, and key-\nvalue pairs are evenly distributed within each page. Thus page ID =\nitem ID\nğ‘š. The distance in the B+tree can be defined as ğ‘¡â€²=âŒˆğ‘¡\nğ‘šâŒ‰. The\nboundaries ğ‘™B+tree andğ‘ŸB+tree are then extended using the same\nnoise mechanism ( LapZ(ğœ†â€²)), whereğœ†â€²=2ğ‘¡â€²/ğœ–dp. Consequently,\nthe expected length of the obfuscated range becomes4ğ‘š\nğœ–dpÂ·âŒˆğ‘¡\nğ‘šâŒ‰+ğ‘š.\nCompared to the PGM-index, the B+tree generally requires more\nnoise. For example, the leaf nodes of a B+tree typically occupy 4 KB,\ncontaining 256 key-value pairs of 16 bytes each. When using default\nparameters ( ğœ€data=64,ğœ–dp=2âˆ’6) and a user-selected ğ‘¡=100, the\nexpected obfuscation range length for a B+tree is 65,792, while for\na PGM-index, it is 25,729. When ğ‘¡=10,000, the expected lengths\nincrease to 2,621,696 for a B+tree and 2,560,129 for a PGM-index,\nrespectively, indicating that the PGM-index requires less noise\noverall, especially for fine-grained security levels. More empirical\nresults are provided in Section 10.3.4.\n8 Key-Value Retrieval\nIn this section, we describe our server-side adaptive key-value\nretrieval module, including two schemes: plaintext download and\nvariable-range PIR. Additionally, we present a lightweight cost\nmodel to help make fast and efficient decisions between these two\nschemes based on query characteristics and system configurations.\n8.1 Plaintext Download\nPlaintext download is a straightforward method for retrieving key-\nvalue pairs, where the server directly sends the key-value pairs\nwithin the obfuscated range to the client, which performs the\nsearches locally. The client only needs to provide the boundaries\nğ‘™andğ‘Ÿ. This approach satisfies the security requirements, as the\nserver only sees the boundaries that have been obfuscated to ensure\ndistance-based indistinguishability, and remains unaware of the\nexact key the client intends to retrieve.\n8\n\nFemur: A Flexible Framework for Fast and Secure Querying from Public Key-Value Store 2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany\nğ¸ğ‘ :ğ‘™ğ‘ğ‘¡=5\n2=2\nğ‘Ÿğ‘ğ‘¡=11\n2=5\n000ğŸ\n23 54ğ‘˜ğ‘£8ğ‘˜ğ‘£9ğ‘˜ğ‘£10ğ‘˜ğ‘£11\nğ‘˜ğ‘£10ğ‘˜ğ‘£11ğ‘˜ğ‘£12ğ‘˜ğ‘£13\nğ‘˜ğ‘£12ğ‘˜ğ‘£13//ğ‘˜ğ‘£0ğ‘˜ğ‘£1ğ‘˜ğ‘£2ğ‘˜ğ‘£3\nğ‘˜ğ‘£2ğ‘˜ğ‘£3ğ‘˜ğ‘£4ğ‘˜ğ‘£5\nğ‘˜ğ‘£4ğ‘˜ğ‘£5ğ‘˜ğ‘£6ğ‘˜ğ‘£7\nğ‘˜ğ‘£6ğ‘˜ğ‘£7ğ‘˜ğ‘£8ğ‘˜ğ‘£9Plaintexts\ninthe server\n4\n5\n60\n1\n2\n3ğ‘¬(ğ’”)â‹…\nğ‘¬[ğ’Œğ’—ğŸ–,ğ’Œğ’—ğŸğŸ]ğ‘™,ğ‘Ÿ=5,11\nPGMâˆ¶ğŸ–,10\nFigure 3: An Example of Data Encoding and Query Processing\nin Variable-Range PIR.\nThe main advantage of plaintext download is server-side effi-\nciency, as the server can immediately transmit the specified key-\nvalue pairs over the network without additional computation. How-\never, this approach is bandwidth-intensive, which can lead to perfor-\nmance bottlenecks in low-bandwidth or high-traffic environments.\nBesides, plaintext download can further reduce the data to be trans-\nferred through compression techniques [ 5,55,70,88]. Although we\ndo not apply compression in our experiments, it can be integrated\nas an optional optimization.\n8.2 Variable-range PIR\nTo handle low-bandwidth scenarios, we propose a novel variable-\nrange PIR scheme. This enhanced scheme allows performing â€œtiny\nPIRâ€ on a specific range of each query without re-preprocessing. Our\ndesign significantly improves server-side computational efficiency\nwhen querying large datasets with relaxed privacy levels.\n8.2.1 Underlying Cryptography. We leverage the SEAL FHE library,\nwhich is based on the BFV FHE cryptosystem, to perform â€œtiny PIRâ€.\nThis method encodes several data points into a single plaintext,\nenabling vectorized homomorphic operations. Furthermore, each\nretrieval returns the key-value pairs packed within the same plain-\ntext, facilitating simultaneous retrieval of multiple key-value pairs.\nThe number of key-value pairs (denoted as ğ‘€) that a single plaintext\ncan hold is determined by: ğ‘€=ğ‘\nâŒˆğ‘˜ğ‘£bits/log2ğ‘âŒ‰, where the polynomial\ndegreeğ‘and the plaintext modulus ğ‘are both internal parame-\nters of the FHE scheme. The modulus ğ‘, which governs the noise\ncapacity and the overall security, can be derived from ğ‘andğ‘. We\nuse the recommended default values of ğ‘=4096 andlog2ğ‘=20.\nMore details can be found in the original paper [13, 27, 38].\n8.2.2 PGM-Oriented Misaligned Encoding. One specific challenge\nin our framework is that we must return the key-value pairs in the\nrange[Ë†ğ‘¦âˆ’ğœ€data,Ë†ğ‘¦+ğœ€data]as predicted by the PGM-index, rather\nthan a single record as in classical PIR schemes. Without a careful\ndesign, the key-value pairs in this range may cross two or multiple\nplaintexts, all of which need to be transmitted to the client. For\nexample, ifğ‘€=4and we need to fetch [ğ‘˜ğ‘£6,ğ‘˜ğ‘£9], two plaintexts\ncorresponding to[ğ‘˜ğ‘£4,ğ‘˜ğ‘£7]and[ğ‘˜ğ‘£8,ğ‘˜ğ‘£11]must be returned.\nWe introduce a PGM-oriented misaligned encoding scheme. As\nillustrated in Figure 3, only ğ‘€/2key-value pairs are encoded into\neach plaintext, with the second half containing a duplicate of the\nfirstğ‘€/2pairs from the next plaintext. This ensures that, as long as\nthe PGM-index satisfies 2ğœ€data+1<ğ‘€\n2+2, all required key-value\npairs can be retrieved in a single plaintext. This condition is easily\nsatisfied with typical configurations, e.g., usually ğœ€data=64andğ‘€=4096\nâŒˆ128/20âŒ‰=585. Furthermore, this misaligned encoding can\nbe generalized to support longer predicted ranges by increasing\nthe overlap between adjacent plaintexts. With ğ‘škey-value pairs\noverlapped, the condition would become 2ğœ€data+1<ğ‘š+2.\n8.2.3 Query Processing. Recall that[Ë†ğ‘¦âˆ’ğœ€data,Ë†ğ‘¦+ğœ€data]is enlarged\nto[ğ‘™,ğ‘Ÿ]to ensure distance-based indistinguishability. While only\nthe key-value pairs in the first (smaller) range are returned to\nthe user, all the pairs in the second (larger) range must be uni-\nformly accessed and processed to obscure sensitive access patterns.\nThe size of this larger range can vary significantly with differ-\nent user-specified security requirements. This requires that the\nunderlying PIR scheme should encode plaintexts independently\n(e.g., SealPIR [ 13] and OnionPIR [ 64]) without pre-computation\ninvolving the client. In this paper, we use SealPIR. But Femur can\nincorporate more advanced PIR interfaces in the future.\nFigure 3 illustrates the steps in processing a lookup query with\nour variable-range PIR based on the misaligned encoding. Both the\npredicted and obfuscated ranges are first converted to the plaintext\nIDs at the client side using the encoding information (e.g., ğ‘€) ob-\ntained during initialization. Here with ğ‘€=4,ğ‘™=5, andğ‘Ÿ=11, the\nplaintext IDs are ğ‘™pt=2andğ‘Ÿpt=5, involving four plaintexts in\nthe computation. The predicted range is encoded into a one-hot\nvectorğ‘ of length(ğ‘Ÿptâˆ’ğ‘™pt+1), where 1 indicates the target plain-\ntext and 0 represents the others. In this case, the third element of\nğ‘ is set to 1, corresponding to the 4th plaintext. The client sends\nğ‘™pt,ğ‘Ÿpt, and the homomorphic encryption of ğ‘ ,ğ¸(ğ‘ ), to the server.\nNote that the server performs homomorphic operations only on\nthe obfuscated range. Specifically, a homomorphic inner product is\nperformed between ğ¸(ğ‘ )and the plaintexts in [ğ‘™pt,ğ‘Ÿpt], producing\nan encrypted output containing the retrieved key-value pairs (i.e.,\n[ğ‘˜ğ‘£8,ğ‘˜ğ‘£11]), which is then returned to the client.\nOur variable-range PIR enables relaxed lookup queries with\nflexible security requirements without requiring re-encoding, im-\nproving utility and scalability. Additionally, misaligned encoding\nensures efficient retrieval of key-value pairs in a single PIR call,\nreducing communication overheads. However, compared to plain-\ntext downloads, it increases server-side computation due to the\nhomomorphic encryption operations required for PIR requests.\n8.3 Scheme Selection\nWe employ a cost model to efficiently choose between the two\nschemes. The model calculates the latency for each scheme using\nthe following formula, as latency is the primary concern for clients:\nğ¶=Comm\nbandwidth+ğ¶compute (11)\nwhere Comm represents the total communication amount of the\nscheme, and ğ¶compute denotes the server-side computation time.\nThis cost model is broadly applicable to many retrieval schemes.\nFor plaintext downloads, the communication cost is ğ‘¤Ã—ğ‘˜ğ‘£bits,\nwhereğ‘¤is the length of the obfuscated range, and the compu-\ntation time is negligible. In contrast, for variable-range PIR, the\ncommunication cost includes the encrypted one-hot vector and the\nciphertext returned by the server. Its computation time is ğ‘¤Ã—ğ¶FHE,\nwhereğ¶FHErepresents the time needed to perform a homomorphic\n9\n\n2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany Jiaoyi Zhang et al.\ncomputation operation on a single plaintext, which increases with\nthe number of plaintexts involved.\nBoth bandwidth and ğ¶FHEcan be pre-determined, facilitating\nquick decisions during the online phase. By leveraging this cost\nmodel, we can efficiently combine different retrieval schemes, en-\nabling faster privacy-preserving retrieval for users.\n9 Supporting Updates\nAs discussed in Section 3, in our scenarios, database updates are\nperformed by the server, not by the clients. This setting aligns with\nexisting PIR-based designs [ 25,31,45,66], in which any modifica-\ntion necessitates re-initializing the entire PIR scheme, including\nre-running the offline phase. In Femur, we support two strategies\nto handle updates, i.e., real-time updates for values and periodic\nbatch updates for keys. We also leverage multi-version control to\nsynchronize server updates with clients.\nFor value updates, the plaintext of the updated key-value pair\nis retrieved from the key-value store, modified in real-time, and\nthen stored back. Since the PGM-index is constructed based on\nkeys only, it remains unchanged during value updates. Throughout\nthis process, client lookup queries continue to operate as usual. If\nthe obfuscated range of a lookup query overlaps with the updated\nplaintext, read-write locks are employed to ensure consistency.\nFor key updates, we employ periodic batch updates via a copy-\non-write model. In this approach, the server initiates a new cloud\ninstance or background thread to merge the existing key-value store\nwith new key-value pairs, performing necessary inserts, deletes, and\nre-encoding operations. Only key-value pairs that need to be moved\nto maintain order are re-encoded. For example, if an insertion occurs\nat position 7 in a dataset of 10 key-value pairs, the plaintexts of\nthe first 6 pairs remain unchanged and do not require re-encoding.\nOnce the merge is complete, the server constructs a new PGM-\nindex for the updated dataset. This process is done asynchronously\n(or offline) and does not disturb services on older versions. After\nthe update, the server broadcasts the new PGM-index and version\ninformation to all connected clients, or clients can request it on\ndemand. If a client queries using the old version, the server returns\nresults from that version while notifying the client of the version\ninconsistency and providing the latest PGM-index. The client can\nthen either use the old versionâ€™s results or re-execute the query\nusing the new index. In our experiments, clients re-execute queries\nwith the latest version. Once all clients have confirmed that they\nhave switched to the new version, the old key-value store is deleted.\n10 Evaluation\nIn this section, we conduct a comprehensive evaluation of Femur\nusing experiments on multiple datasets. Section 10.1 outlines the\nexperimental setup, while Section 10.2 provides an in-depth analysis\nof end-to-end performance. Section 10.3 presents the explorations\nof the impact of various factors. Finally, Section 10.4 evaluates a\nrealistic scenario involving Redis and update operations.\n10.1 Experimental Setup\nWe conduct experiments on a machine with two IntelÂ®XeonÂ®\nPlatinum 8474C CPUs (2.10 GHz, 48 cores per socket) and 512 GB\nof RAM. All end-to-end evaluations in Section 10.2 are performedusing 8 threads, and the remaining experiments use a single thread.\nWe select the commonly used WAN setting (50 Mbps bandwidth\nwith 30 ms roundtrip latency) as the default configuration [ 48,49,\n63]. We provide two additional bandwidth setups in Section 10.3.2,\n100 Mbps and 10 Mbps, all with a roundtrip latency of 30 ms.\nDatasets and Workloads. We use the real-world Open Street Map\nCoordinates (OSMC) dataset from the SOSD benchmark [ 58]. It\ncontains 200 million key-value pairs representing real geographic\npositions. In contrast, existing PIRs [ 7,25,66] often use randomly\ngenerated datasets with at most a few million data points and\nthus fail to fully capture the complexity of large-scale, real-world\napplications. Both keys and values are 8-byte unsigned integers.\nThis uniform length, consistent with PIR schemes, prevents the\nserver from inferring query keys based on lengths. We use the\nentire 200M key-value pairs in Section 10.2. We randomly select 100\nkeys (similar to [ 25]) from the dataset for client lookups during the\nonline phase. We use a subset of the datasets in other experiments.\nMetrics. Our evaluation includes four main metrics: offline/online\ncommunication volume and offline/online execution time. Com-\nmunication volume refers to the total amount of data transferred\nbetween the server and the client at each phase, measured in\nmegabytes (MB). The execution time includes both the client/server\ncomputation time and the network data transmission time, provid-\ning an end-to-end performance measure.\nFemur and Baselines. We implement Femur and two keyword-\nPIR baselines, Chalamet [ 25] and Pantheon [ 7], in Java. Since the\noriginal Rust implementation of Chalamet does not include network\ncommunication, it cannot be evaluated directly under our client-\nserver experiment setting. To enable a fair end-to-end evaluation,\nwe reimplemented Chalamet in Java2based on its open-source\nimplementation [ 2]. Both Chalamet and Pantheon are fully secure\nschemes, while Femur can support different security granularities.\nAs discussed in Section 4.1.2, we keep ğœ–dp=2âˆ’6, and specify three\nrepresentative security levels as high ( ğ‘¡=1,000,000), medium\n(ğ‘¡=10,000), and low (ğ‘¡=100). We build the PGM-indexes using\nthe complete datasets of the respective size (e.g., 200 million key-\nvalue pairs in the end-to-end evaluation) with parameters set to\ndefault values ( ğœ€model =4,ğœ€data=64). To support variable-range\nPIR in Femur, we employ Java Native Interface (JNI) technology to\ncall the Microsoft SEAL library (v4.1) [ 73] and use default settings\nfor the BFV scheme. Our source code is publicly available [3].\n10.2 End-to-End Evaluation\nWe perform an end-to-end evaluation using the 200M-record OSMC\ndataset. In this experiment, the client continuously issues 100 queries\nin a pipeline manner to the server. We compare the total execution\ntime (from the generation of the first query to the client receiving\nall responses) of Femur against the baselines. Femur is evaluated\nat full security and eight different security levels with varying ğ‘¡\nvalues of 1M (high), 0.5M, 0.1M, 50K, 10K (medium), 5K, 1K, and 100\n(low), which correspond to the average number of data points in\n2In our tests with a 220Ã—256byte dataset, we observe that network communication,\nalong with serialization and deserialization, account for more than 72% of the total\nexecution time. Since the computational functionality of the Rust code is not the\nbottleneck, rewriting it in Java has minimal impact on the overall performance.\n10\n\nFemur: A Flexible Framework for Fast and Secure Querying from Public Key-Value Store 2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany\n10.7K\nFull High Medium Low00.3K0.6K0.9K1.2K1.5K\nSecurity LevelT otal Time (sec)Pantheon\nChalamet\nFemur\nFigure 4: Total Online Execution Time for 100 Queries â€“ Femur\nuses 8 relaxed security levels besides full security. Pantheon and\nChalamet encountered out-of-memory issues on 8 threads, so their\nresults are ideally scaled from single-thread time. Pantheon failed\nto complete on this large dataset after running 24 hours using a\nsingle thread, so we mark its (lower-bound) time as 24/8 = 3 hours.\nTable 1: Total Offline Time for 100 Queries (in seconds) â€“\nFemur only needs to be initialized once to support all security-level\nqueries, so different ğ‘¡values produce similar offline latencies.\nPantheon ChalametFemur\nWith Relaxed Security Level (Various ğ‘¡)\nFull Security 1M 500K 100K 50K 10K 5K 1K 100\n55.5 16214.3 697.5 697.2 703.2 697.3 698.2 694.6 702.1 696.2\nFemurâ€™s computations of 256M3, 128M, 25.6M, 12.8M, 2.56M, 1.28M,\n256K, and 25.6K data points, respectively (plus an additional 129\ndata points generated by the PGM-index for each case).\nWe present the online execution time for Femur and the two\nbaselines in Figure 4, and their offline execution time in Table 1.\nThe results clearly show that relaxing the security significantly\nenhances the online runtime, with speedups of 1.11 Ã—, 1.65Ã—, 5.71Ã—,\n13.4Ã—, 44.6Ã—, 66.8Ã—, 131.1Ã—, and 163.9Ã—over Chalamet, which pro-\nvides full security. Even at the same full security level, Femur is\nslightly faster than Chalamet (1.05 Ã—) and significantly outperforms\nPantheon (over 7.71 Ã—). Femur reduces the average execution time\nper query from 14 seconds under full security to 89.6 ms at a re-\nlaxed security level that guarantees indistinguishability among 100\nneighboring queries. This demonstrates an effective trade-off be-\ntween security and performance, enabling significant speedups\nwhen users are willing to relax their privacy requirements.\nPantheon is extremely slow on large datasets, primarily due to its\nreliance on a slow homomorphic equality check during the online\nphase to locate the querying key. In contrast, Femur employs the\nPGM-index for rapid key location, at the slight cost of sending a\nsmall amount of data during initialization. Even with the default\nvalue ofğœ€data=64, which is relatively small, the size of the PGM-\nindex is only 5MB on the 200 million records. While Chalamet\nperforms close to Femur with full security level, it must transfer\n858.5 MB of ciphertext results, which can significantly delay query\nresponses in bandwidth-constrained scenarios. Unlike Pantheon\nand Chalamet, whose computation or transmission times grow with\n3Note that this is a theoretical expectation. Since the OSMC dataset contains only\n200M keys, any obfuscated range exceeding 200M will be capped at 200M.\n220222224226\nDataset Size (#Key-Value Pairs)102103104105106Online Time (ms, log-scale)\n1X\n1X\n1X\n1X1.1X\n1.4X\n1.5X\n1.3X0.4X\n0.3X\n0.3X\n0.3X1.1X\n1.9X\n7.2X\n26.2X0.4X\n0.5X\n1.9X\n7.5X4.5X\n16.6X\n64.2X\n233.3X5.8X\n21.7X\n99.9X\n362.5XPantheon\nChalametFemurVarPIR (High)\nFemurPlainDL (High)FemurVarPIR (Medium)\nFemurPlainDL (Medium)FemurVarPIR (Low)\nFemurPlainDL (Low)Figure 5: Online Execution Time for Each Query on Different\nDataset Sizes â€“ The number above each bar represents the speedup\nover Chalamet. Pantheon timed out on datasets of size 224and226.\nThe shadowed area represents the server-side computation time,\nincluding the time required to serialize the data to be sent.\ndataset size, Femur maintains a constant online transfer time, lim-\nited to two ciphertexts (for query and response), with computation\ntime dependent solely on the user-specified security level.\nChalamet suffers from a significantly slower offline phase, requir-\ning 4.5 hours to pre-process 200 million key-value pairs as shown\nin Table 1. This makes Chalamet impractical in scenarios where\nupdates or inserts are needed, as even batch updates require re-\nprocessing all data points, leading to substantial delays. In contrast,\nFemur completes the offline phase in 11.5 minutes, significantly\nfaster than Chalamet. Besides, our update strategies in Section 9\nfurther reduce the re-initialization time by minimizing the number\nof key-value pairs that need to be re-encoded. Further evaluation\nof update support is presented in Section 10.4. Note that to support\nthe flexibility of different privacy levels in Femur, we do notneed to\nre-execute the initialization phase. Pantheonâ€™s offline initialization\ntime is short because it only requires the user to upload the two\nparameters for the underlying homomorphic encryption scheme.\nHowever, its online query processing time is significantly longer.\n10.3 Impact of Various Factors\nStarting from this section, we focus on the performance break-\ndown of individual queries and the impact of various factors on\nperformance. Therefore, each query is run individually with a sin-\ngle thread, and the online execution time reflects the performance\nof a single query. Unless otherwise stated, other parameters remain\nthe same as previously described.\n10.3.1 Impact of Dataset Sizes. In this section, we evaluate the per-\nformance of each scheme across various dataset sizes. Specifically,\nwe conduct experiments on a subset of the OSMC dataset of sizes\n220,222,224, and 226. We also test smaller datasets, which are not\nincluded here due to space limitations, and observed conclusions\nconsistent with the results presented. We select three security lev-\nels for Femur, corresponding to the expected length of obfuscated\nranges of 256 million, 2.56 million, and 25600, to evaluate both\nFemur PlainDL and Femur VarPIR schemes. If the expected length\nexceeds the total number of data points in the dataset, the cur-\nrent scheme is the same as full security (i.e., high level for all, and\nmedium level for 220).\n11\n\n2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany Jiaoyi Zhang et al.\nTable 2: Online Communication per Query (in MB) â€“ including\nthe query keys/parameters uploaded by the client and the query\nresults downloaded from the server.\nDataset\nSizeBaselines on\nFull SecurityFemur on\nHigh SecurityFemur on\nMedium SecurityFemur on\nLow Security\nPantheon Chalamet VarPIR PlainDL VarPIR PlainDL VarPIR PlainDL\n2203.5 4.5 0.43 16 0.43 16 0.43 0.39\n2223.5 18 0.43 64 0.43 39 0.43 0.39\n2243.5 72 0.43 256 0.43 39 0.43 0.39\n2263.5 288 0.43 1024 0.43 39 0.43 0.39\n220222224226\nDataset Size (#Key-Value Pairs)103104105106107Offline Time (ms, log-scale)\n15.9X\n21.4X\n109.3X\n443.9X1X\n1X\n1X\n1X107.8X\n45.5X\n57.1X\n60.1X1039.2X\n299.0X\n422.3X\n392.6X107.8X\n45.5X\n57.1X\n59.5X1039.2X\n299.0X\n422.3X\n394.0X107.8X\n45.8X\n58.4X\n58.8X1039.2X\n307.8X\n375.0X\n390.2XPantheon\nChalametFemurVarPIR (High)\nFemurPlainDL (High)FemurVarPIR (Medium)\nFemurPlainDL (Medium)FemurVarPIR (Low)\nFemurPlainDL (Low)\nFigure 6: Offline Time for Each Query on Different Dataset\nSizes â€“ The number above each bar is the speedup ratio of each\nscheme compared to Chalamet.\nFigure 5 illustrates the online time for each method across various\ndataset sizes, which mainly consists of the server-side computa-\ntion time and the communication time to transmit data between\nthe two parties. The online latency of Chalamet increases linearly\nwith dataset size, rising from 1.02 seconds for 220key-value pairs\nto 53.7 seconds for 226key-value pairs. This linear growth is not\nonly due to the increased computation but also due to the linear\nincrease in online communication, as shown in Table 2. Pantheon\nshows a significant computation time despite constant communi-\ncation volumes (3.5 MB), with one query on 222entries taking an\nimpractical 2,261 seconds. In contrast, Femurâ€™s online response time\nremains independent of dataset size at fixed security granularity.\nThis is because the security requirements for the client typically do\nnot escalate with the dataset size. Compared to Chalamet, Femur\nachieves a maximum speedup of 362.5 Ã—by relaxing security to en-\nsure distance-based indistinguishability with ğ‘¡=100andğœ–dp=2âˆ’6.\nFurthermore, the online communication cost of Femur VarPIR is\nfixed at 0.43 MB (i.e., the size of a ciphertext), regardless of dataset\nsize or security granularity. Similarly, the online communication\ncost of Femur PlainDL does not increase with dataset size for the\nsame security levels, remaining at 0.39 MB for all low-security\nexperiments. Note that for higher security levels in Table 2, the\nexpected length exceeds the size of certain datasets, causing the\nonline communication to degrade to the entire dataset size.\nAmong our two schemes, Femur PlainDL scheme is more sensitive\nto bandwidth. It does not involve plaintext/ciphertext computations,\nso its query time is determined by the bandwidth and the byte\nsize of the data. In contrast, Femur VarPIR is compute-intensive.\n100 Mbps 50 Mbps 10 Mbps\nBandwidth101\n100101102103Online Time (sec, log-scale)\n30.3\n53.7\n250.542.6\n42.7\n43.1107.8\n190.1\n8842.0\n2.0\n2.34.1\n7.2\n33.80.2\n0.23\n0.520.12\n0.15\n0.41FemurVarPIR (High)\nFemurPlainDL (High)FemurVarPIR (Medium)\nFemurPlainDL (Medium)FemurVarPIR (Low)\nFemurPlainDL (Low)ChalametFigure 7: Online Execution Time per Query at Various Band-\nwidths â€“ The number above each bar is the latency in seconds.\nOwing to our encoding design, the network transmission involves\nonly uploading a query and downloading a result, whose time is\nminimized and remains constant at 63 ms. Consequently, its overall\nruntime is almost dominated by computation. In Femur, the cost\nmodel automatically selects the faster scheme between the two.\nParticularly, Chalamet and Femur VarPIR (both High and Medium)\non the dataset size with 220provide comparable online end-to-\nend latency, with the same level of full security. However, in the\noffline phase, our Femur VarPIR offers a 107.8Ã—speedup compared\nto Chalamet, as shown in Figure 6, by only encoding the records\ninto FHE plaintexts and efficiently building and transmitting the\nPGM-index. Since the shorter offline phase of Femur PlainDL only\naccomplishes tasks that are a subset of Femur VarPIR (i.e., transmit\nPGM-index), Femurâ€™s overall offline time is determined by Femur\nVarPIR . Notably, our offline time remains constant across different\nsecurity levels, as it depends solely on the size of the public key-\nvalue store. Clients download the PGM-index once and can then use\nFemur for queries with different security requirements, whereas\nChalamet and Pantheon rigidly support only fully secure queries.\n10.3.2 Impact of Bandwidth. Figure 7 illustrates the online latency\nacross different bandwidths for the dataset of 226key-value pairs.\nWe evaluate three security levels of Femur: high, medium, and low.\nThe high level aligns with the full security level of the baselines, as\nthe expected length of the obfuscated range exceeds 226. Bandwidth\nhas less impact on Femur VarPIR compared to both Femur PlainDL\nand Chalamet. Femur PlainDL is bandwidth-intensive and becomes\nfaster with higher bandwidth. Chalamet, which transfers 288 MB of\ndata, is similarly limited by bandwidth. At 10 Mbps, it takes 250.5\nseconds to respond to a query. In contrast, Femur VarPIR is able to\ntransfer only one ciphertext due to its misaligned encoding, and it\nis bound by the FHE computations rather than data transfers.\nIn summary, Femur, leveraging our cost model, adapts to vari-\nous network environments and automatically selects the optimal\nsolution between Femur VarPIR and Femur PlainDL . Femur achieves\nresponse times ranging from 0.12 to 42.6 seconds, depending on\nthe available bandwidth and the specified security level.\n10.3.3 Impact of Value Size. Figure 8 illustrates the changes in\nboth online and offline execution times for each scheme as the byte\nlength of each value varies. The dataset consists of 220key-value\npairs, with fixed 8-byte keys and the low security level for Femur.\n12\n\nFemur: A Flexible Framework for Fast and Secure Querying from Public Key-Value Store 2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany\n8B 128B 256B 512B 1024B100101102103104T otal Time\n(s, log-scale)Online Phase\nPantheon Chalamet Femur\n8B 128B 256B 512B 1024BOffline Phase\nPantheon Chalamet Femur\nFigure 8: Online/Offline Execution Time (in seconds) at Vari-\nous Value Size (in bytes) â€“ Both graphs share the same y-axis.\nTable 3: Average Length of Obfuscated Ranges with Various\nSecurity Levels\nDistance (ğ‘¡) 10 100 1000 10000\nB+tree 65541.46 65552.8 262088.2 2621408.6\nPGM-index 2715.12 25740.2 256135.1 2559313.1\nRatio 24.1394Ã— 2.5461Ã— 1.0233Ã— 1.0243Ã—\nThe online execution time of Femur increases as the value length\ngrows, but it continues to show advantages. This increase is due to\nthe larger total byte size, which leads to more encoded plaintexts\nand also slows down the plaintext encoding process during the\noffline phase. When the value length is 8 bytes, Femur uses the\nPlainDL scheme. As the values become larger, PlainDLâ€™s perfor-\nmance degrades rapidly with more transmitted data. Thus Femur\nswitches to the VarPIR scheme at 128 byte values.\nChalametâ€™s online time increases slightly with the value length,\nbut its offline time grows significantly, from 201.7 seconds to 6.02\nhours. This is due to the rapid growth in computational cost caused\nby the larger key-value pair length, with most of the computation\nshifted to the offline phase. In contrast, Pantheonâ€™s bottleneck lies in\nthe equality check between the querying key and all keys. Since the\nkey length remains constant, its online processing time increases\nonly slightly, from 609 seconds to 729 seconds.\n10.3.4 Comparison of Client-Side Indexes. To demonstrate the ben-\nefits of using PGM-indexes, we compare PGM-indexes and B+trees\nbased on the length of the obfuscated ranges generated and the\nindex size. The obfuscated range length directly impacts the data\nvolume downloaded or processed on the server. The index size de-\ntermines the amount of data required for clients to download from\nthe server during the offline phase, which is also crucial especially\nin scenarios with update operations.\nWe first implement the noise generation algorithm described\nin Section 7 on the B+tree and evaluate both indexes under various\nsecurity levels. For each index, we process 10 million queries, con-\nverting querying keys into obfuscated ranges and measuring the\naverage length of the resulting ranges. As shown in Table 3, when\nthe security requirements are low, the obfuscated ranges generated\nby the B+tree are 24.14 Ã—longer than those generated by the PGM-\nindex. Even as the security requirements increase, the PGM-index\nconsistently reduces approximately 60,000 injected noise. These\nresults demonstrate that the PGM-index, which operates at item-\nlevel granularity, is effective in minimizing injected noise while\nsatisfying the same security requirements.Table 4: Index sizes of B+trees and PGM-indexes (in MiB)\nâ€“ The bolded numbers are the index sizes used in our previous\nexperiments, indicating the network required to transmit the index.\nSize Dataset B+treePGM-index (With Various ğœ€data)\n512 256 128 64 32\n200 millionWiki 11.93 0.11 0.17 0.29 0.58 1.31\nOSMC 11.93 0.65 1.28 2.55 5.13 10.3\nNormal 11.93 0.01 0.01 0.01 0.01 0.02\n220OSMC 0.13 0.01 0.01 0.02 0.03 0.07\n222OSMC 0.50 0.01 0.03 0.06 0.11 0.22\n224OSMC 2.00 0.06 0.12 0.24 0.47 0.93\n226OSMC 8.01 0.25 0.50 0.98 1.95 3.91\nLow-Level Security Medium-Level Security High-Level Security102103T otal Time\n(s, log-scale)0%0%1%\n0%1%3%w/o updates\nw/ update values\nw/ update keys\nFigure 9: Online Execution Time for 100 Queries on Redis\nand with Updates â€“ Each number above the bar is the ratio of the\nadditional time caused by updates to the time without updates.\nTo evaluate the effects of data distribution and dataset size on\nindex sizes, we construct both indexes using three datasets from\nthe SOSD benchmark [ 58], each containing 200 million key-value\npairs (two real-world datasets and one synthetic dataset following a\nnormal distribution). Besides, we test index sizes on OSMC datasets\nof varying sizes. For the B+tree, only internal nodes are counted,\nand for the PGM-index, we measure sizes across different values of\nğœ€data. As shown in Table 4, the PGM-index is significantly smaller\nthan the B+tree, even with small ğœ€dataerror requirements and on\nthe OSMC dataset that is less friendly to learned indexes. Based on\nthese results, we set the default value of ğœ€datato 64 to balance the\nindex size and the length of the predicted range. Meanwhile, ğœ€model\nhas a smaller impact on the index size, so we adopt the default value\nof 4 from the original paper [40].\n10.4 Evaluation on Redis\nTo evaluate the performance and usability of Femur in real-world\nscenarios, we implemented Femur on Redis, a widely used key-value\nstore, using Jedis (the Redis Java client) [ 4]. The server also con-\ntinuously updates its key-value pairs while serving private queries\nfrom clients. During lookup and update operations, we use the\nJedis interface to retrieve data within the specified range and write\nupdated plaintext back to Redis. To ensure uninterrupted client\nqueries during updates, we employ Multi-Version Concurrency\nControl (MVCC) to manage multiple Redis instances, as detailed\nin Section 9. We conduct experiments by executing 100 lookup\nqueries on this Redis-based version of Femur under three scenarios:\n(1) no updates, (2) real-time updates for values with a 1-second\ninterval between updates, and (3) periodic batch updates for keys\nwith a 1-second delay between completing one update and initiat-\ning the next. The dataset size is 224, and queries are performed at\nthree security levels: low, medium, and high.\n13\n\n2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany Jiaoyi Zhang et al.\nAs shown in Figure 9, updates cause at most a 3% increase in total\nquery time. This minor delay arises because some queries require\nfetching the updated PGM-index after a version switch, ensuring\nthat all lookup results remain up-to-date. We also track the number\nof update operations performed during the execution of 100 queries.\nIn the high-security evaluation, the server completes 1,120 real-time\nvalue updates and 24 periodic batch updates for keys/databases.\nThe real-time updates take only 70 ms each, including reading\nplaintext from Redis, updating it, and writing it back to Redis. A\nperiodic batch update takes approximately 60 seconds, however,\nwe use MVCC to further reduce the impact of update operations\nby performing most tasks asynchronously in background threads.\nCompared to Chalamet, which requires 1.5 hours to reinitialize\na database of the same size, Femur significantly reduces update\ncycles, making it more practical for real-world scenarios.\n11 Related Work\nRelaxed Security in Query Processing. Several works [ 19,34,\n39,41,56,71,72,80,82,93,94] have applied differential privacy\n(DP) to data management to provide relaxed security models with\ntheoretical guarantees for secure query processing, thus enhancing\nperformance. Specifically, Shrinkwrap [ 19] introduces DP-based\nnoise to intermediate results, concealing the true size of the inter-\nmediate data and improving overall performance by eliminating\nthe need for worst-case padding after each operatorâ€™s execution.\nAdore [ 71] and Doquet [ 72] address access pattern leakage during\nrelational operations and join queries using differentially oblivious\noperators and private data structures. Longshot [ 94] tackles the\nchallenges of indexing a growing database by combining DP with\nsecure multiparty computation (MPC). While prior work primarily\ntargets scenarios involving online analytical processing (OLAP)\nor encrypted data, Femur enables private queries on public key-\nvalue stores, offering relaxed security with theoretical guarantees,\nensuring that each query is indistinguishable from its neighbors.\nPrivacy Enhancements in DBMS. In recent years, significant\nefforts have focused on enabling clients to outsource private data\nwhile ensuring secure query processing [ 16,17,37,68,69,74,79].\nThese approaches typically involve encrypting data, storing it on\na cloud server, and using techniques such as order-preserving en-\ncryption [ 6], homomorphic encryption [ 67,79,83], searchable en-\ncryption [ 24] and Trusted Execution Environments (TEE) [ 18,20,\n30,75,76,81,96] to achieve this goal. In contrast, Femur is designed\nfor public datasets, which focuses on query privacy. Many works\nalign with our goal [ 8,10,13,59,60,62,66,95], mainly based on\nhomomorphic encryption. For example, Pantheon [ 7] and Constant-\nweight PIR [ 57] implement equality-checking operators and invoke\ntraditional PIR schemes for homomorphic operations. While our\nframework supports similar homomorphic operations to return\ntarget key-value pairs, it also offers the flexibility to utilize other\nschemes, such as direct downloads when bandwidth is sufficient.\nMoreover, existing PIR schemes typically require all data to partici-\npate in computation or communication, resulting in poor scalability\nand limited support for large datasets. However, our scheme allows\nfor flexibility in adjusting the range of data participation in com-\nputations without requiring re-encoding. This works seamlesslywith our definition of distance-based indistinguishability. By offer-\ning users the ability to relax security and select different levels of\nsecurity guarantees based on their needs, Femur significantly ac-\ncelerates query response, making Femur a more practical solution.\n12 Conclusion\nWe present Femur, a framework that enables users to perform se-\ncure queries on public key-value stores, while empowering users to\ntailor privacy protections to their specific needs. By employing the\nnovel concept of distance-based indistinguishability and an adap-\ntive retrieval mechanism supporting both direct downloads and\nan enhanced PIR scheme, Femur achieves a fine balance between\nprivacy and performance. Our evaluations confirm that Femur ef-\nficiently supports a wide range of security configurations while\nmaintaining practical query response times, even on large datasets.\nAcknowledgments\nThis work was partially supported by the Shanghai Qi Zhi Institute\nInnovation Program (SQZ202406 & SQZ202314) and the National\nSocial Science Foundation of China (Grant No. 22 & ZD147).\n14\n\nFemur: A Flexible Framework for Fast and Secure Querying from Public Key-Value Store 2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany\nReferences\n[1] 2009. Redis. https://redis.io/\n[2] 2024. Chalamet. https://github.com/claucece/chalamet.\n[3] 2024. Femur. https://github.com/alibaba-edu/mpc4j.\n[4] 2024. Jedis. https://github.com/redis/jedis.\n[5]Daniel J. Abadi, Samuel Madden, and Miguel Ferreira. 2006. Integrating compres-\nsion and execution in column-oriented database systems. In Proceedings of the\nACM SIGMOD International Conference on Management of Data, Chicago, Illinois,\nUSA, June 27-29, 2006 , Surajit Chaudhuri, Vagelis Hristidis, and Neoklis Polyzotis\n(Eds.). ACM, 671â€“682. https://doi.org/10.1145/1142473.1142548\n[6]Rakesh Agrawal, Jerry Kiernan, Ramakrishnan Srikant, and Yirong Xu. 2004.\nOrder preserving encryption for numeric data. In Proceedings of the 2004 ACM\nSIGMOD International Conference on Management of Data (Paris, France) (SIGMOD\nâ€™04). Association for Computing Machinery, New York, NY, USA, 563â€“574. https:\n//doi.org/10.1145/1007568.1007632\n[7]Ishtiyaque Ahmad, Divyakant Agrawal, Amr El Abbadi, and Trinabh Gupta. 2022.\nPantheon: Private Retrieval from Public Key-Value Store. Proc. VLDB Endow. 16,\n4 (dec 2022), 643â€“656. https://doi.org/10.14778/3574245.3574251\n[8]Ishtiyaque Ahmad, Yuntian Yang, Divyakant Agrawal, Amr El Abbadi, and Trin-\nabh Gupta. 2021. Addra: Metadata-private voice communication over fully\nuntrusted infrastructure. In 15th{USENIX}Symposium on Operating Systems\nDesign and Implementation ( {OSDI}21).\n[9]Ahmet Aktay, Shailesh Bavadekar, Gwen Cossoul, John Davis, Damien Des-\nfontaines, Alex Fabrikant, Evgeniy Gabrilovich, Krishna Gadepalli, Bryant Gip-\nson, Miguel Guevara, et al .2020. Google COVID-19 community mobility reports:\nanonymization process description (version 1.1). arXiv preprint arXiv:2004.04145\n(2020).\n[10] Asra Ali, TancrÃ¨de Lepoint, Sarvar Patel, Mariana Raykova, Phillipp Schoppmann,\nKarn Seth, and Kevin Yeo. 2021. {Communicationâ€“Computation }trade-offs in\n{PIR}. In30th USENIX security symposium (USENIX Security 21) . 1811â€“1828.\n[11] MÃ¡rio Alvim, Konstantinos Chatzikokolakis, Catuscia Palamidessi, and Anna\nPazii. 2018. Invited Paper: Local Differential Privacy on Metric Spaces: Optimiz-\ning the Trade-Off with Utility. In 2018 IEEE 31st Computer Security Foundations\nSymposium (CSF) . 262â€“267. https://doi.org/10.1109/CSF.2018.00026\n[12] Kareem Amin, Jennifer Gillenwater, Matthew Joseph, Alex Kulesza, and Sergei\nVassilvitskii. 2022. Plume: differential privacy at scale. arXiv preprint\narXiv:2201.11603 (2022).\n[13] Sebastian Angel, Hao Chen, Kim Laine, and Srinath Setty. 2018. PIR with com-\npressed queries and amortized query processing. In 2018 IEEE symposium on\nsecurity and privacy (SP) . IEEE, 962â€“979.\n[14] Sebastian Angel and Srinath Setty. 2016. Unobservable communication over fully\nuntrusted infrastructure. In 12th USENIX Symposium on Operating Systems Design\nand Implementation (OSDI 16) . 551â€“569.\n[15] Christoph Anneser, Andreas Kipf, Huanchen Zhang, Thomas Neumann, and\nAlfons Kemper. 2022. Adaptive Hybrid Indexes. In SIGMOD â€™22: International\nConference on Management of Data, Philadelphia, PA, USA, June 12 - 17, 2022 ,\nZachary G. Ives, Angela Bonifati, and Amr El Abbadi (Eds.). ACM, 1626â€“1639.\nhttps://doi.org/10.1145/3514221.3526121\n[16] Panagiotis Antonopoulos, Arvind Arasu, Kunal D. Singh, Ken Eguro, Nitish\nGupta, Rajat Jain, Raghav Kaushik, Hanuma Kodavalla, Donald Kossmann, Niko-\nlas Ogg, Ravi Ramamurthy, Jakub Szymaszek, Jeffrey Trimmer, Kapil Vaswani,\nRamarathnam Venkatesan, and Mike Zwilling. 2020. Azure SQL Database Always\nEncrypted. In Proceedings of the 2020 ACM SIGMOD International Conference on\nManagement of Data (Portland, OR, USA) (SIGMOD â€™20) . Association for Comput-\ning Machinery, New York, NY, USA, 1511â€“1525. https://doi.org/10.1145/3318464.\n3386141\n[17] Arvind Arasu, Spyros Blanas, Ken Eguro, Raghav Kaushik, Donald Kossmann,\nRavishankar Ramamurthy, and Ramarathnam Venkatesan. 2013. Orthogonal\nSecurity with Cipherbase.. In CIDR .\n[18] Maurice Bailleu, JÃ¶rg Thalheim, Pramod Bhatotia, Christof Fetzer, Michio Honda,\nand Kapil Vaswani. 2019. Speicher: securing LSM-based key-value stores using\nshielded execution. In Proceedings of the 17th USENIX Conference on File and\nStorage Technologies (Boston, MA, USA) (FASTâ€™19) . USENIX Association, USA,\n173â€“190.\n[19] Johes Bater, Xi He, William Ehrich, Ashwin Machanavajjhala, and Jennie Rogers.\n2018. Shrinkwrap: efficient SQL query processing in differentially private data\nfederations. Proc. VLDB Endow. 12, 3 (Nov. 2018), 307â€“320. https://doi.org/10.\n14778/3291264.3291274\n[20] Ilaria Battiston, Lotte Felius, Sam Ansmink, Laurens Kuiper, and Peter Boncz. 2024.\nDuckDB-SGX2: The Good, The Bad and The Ugly within Confidential Analytical\nQuery Processing. In Proceedings of the 20th International Workshop on Data\nManagement on New Hardware (Santiago, AA, Chile) (DaMoN â€™24) . Association\nfor Computing Machinery, New York, NY, USA, Article 14, 5 pages. https:\n//doi.org/10.1145/3662010.3663447\n[21] Rudolf Bayer. 1972. Symmetric Binary B-Trees: Data Structure and Maintenance\nAlgorithms. Acta informatica 1, 4 (dec 1972), 290â€“306. https://doi.org/10.1007/\nBF00289509[22] Nikita Borisov, George Danezis, and Ian Goldberg. 2015. DP5: A private presence\nservice. Proceedings on Privacy Enhancing Technologies (2015).\n[23] Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan. 2014. (Leveled)\nfully homomorphic encryption without bootstrapping. ACM Transactions on\nComputation Theory (TOCT) 6, 3 (2014), 1â€“36.\n[24] David Cash, Joseph Jaeger, Stanislaw Jarecki, Charanjit Jutla, Hugo Krawczyk,\nMarcel-CÄƒtÄƒlin RoÅŸu, and Michael Steiner. 2014. Dynamic searchable encryption\nin very-large databases: Data structures and implementation. Cryptology ePrint\nArchive (2014).\n[25] SofÃ­a Celi and Alex Davidson. 2024. Call Me By My Name: Simple, Practical\nPrivate Information Retrieval for Keyword Queries. Cryptology ePrint Archive\n(2024).\n[26] Konstantinos Chatzikokolakis, Miguel E. AndrÃ©s, NicolÃ¡s Emilio Bordenabe, and\nCatuscia Palamidessi. 2013. Broadening the Scope of Differential Privacy Using\nMetrics. In Privacy Enhancing Technologies , Emiliano De Cristofaro and Matthew\nWright (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 82â€“102.\n[27] Hao Chen, Kim Laine, and Rachel Player. 2017. Simple encrypted arithmetic\nlibrary-SEAL v2. 1. In Financial Cryptography and Data Security: FC 2017 Interna-\ntional Workshops, WAHC, BITCOIN, VOTING, WTSC, and TA, Sliema, Malta, April\n7, 2017, Revised Selected Papers 21 . Springer, 3â€“18.\n[28] Benny Chor, Niv Gilboa, and Moni Naor. 1997. Private information retrieval by\nkeywords. (1997).\n[29] Henry Corrigan-Gibbs and Dmitry Kogan. 2020. Private information retrieval\nwith sublinear online time. In Advances in Cryptologyâ€“EUROCRYPT 2020: 39th\nAnnual International Conference on the Theory and Applications of Cryptographic\nTechniques, Zagreb, Croatia, May 10â€“14, 2020, Proceedings, Part I 39 . Springer,\n44â€“75.\n[30] Victor Costan. 2016. Intel SGX explained. IACR Cryptol, EPrint Arch (2016).\n[31] Alex Davidson, GonÃ§alo Pestana, and SofÃ­a Celi. 2023. Frodopir: Simple, scalable,\nsingle-server private information retrieval. Proceedings on Privacy Enhancing\nTechnologies (2023).\n[32] Daniel Demmler, Peter Rindal, Mike Rosulek, and Ni Trieu. 2018. PIR-PSI: scaling\nprivate contact discovery. Proceedings on Privacy Enhancing Technologies (2018).\n[33] Jialin Ding, Umar Farooq Minhas, Jia Yu, Chi Wang, Jaeyoung Do, Yinan Li,\nHantian Zhang, Badrish Chandramouli, Johannes Gehrke, Donald Kossmann,\nDavid Lomet, and Tim Kraska. 2020. ALEX: An Updatable Adaptive Learned Index.\nInProceedings of the 2020 ACM SIGMOD International Conference on Management\nof Data (Portland, OR, USA) (SIGMOD â€™20) . Association for Computing Machinery,\nNew York, NY, USA, 969â€“984. https://doi.org/10.1145/3318464.3389711\n[34] Wei Dong, Dajun Sun, and Ke Yi. 2023. Better than Composition: How to Answer\nMultiple Relational Queries under Differential Privacy. Proc. ACM Manag. Data\n1, 2, Article 123 (June 2023), 26 pages. https://doi.org/10.1145/3589268\n[35] Cynthia Dwork, Aaron Roth, et al .2014. The algorithmic foundations of differ-\nential privacy. Foundations and Trends Â®in Theoretical Computer Science 9, 3â€“4\n(2014), 211â€“407.\n[36] Ãšlfar Erlingsson, Vasyl Pihur, and Aleksandra Korolova. 2014. RAPPOR: Ran-\ndomized Aggregatable Privacy-Preserving Ordinal Response. In Proceedings of\nthe 2014 ACM SIGSAC Conference on Computer and Communications Security\n(Scottsdale, Arizona, USA) (CCS â€™14) . Association for Computing Machinery, New\nYork, NY, USA, 1054â€“1067. https://doi.org/10.1145/2660267.2660348\n[37] Saba Eskandarian and Matei Zaharia. 2019. ObliDB: oblivious query processing\nfor secure databases. Proc. VLDB Endow. 13, 2 (Oct. 2019), 169â€“183. https:\n//doi.org/10.14778/3364324.3364331\n[38] Junfeng Fan and Frederik Vercauteren. 2012. Somewhat practical fully homomor-\nphic encryption. Cryptology ePrint Archive (2012).\n[39] Juanru Fang and Ke Yi. 2024. Privacy Amplification by Sampling under User-\nlevel Differential Privacy. Proc. ACM Manag. Data 2, 1, Article 34 (March 2024),\n26 pages. https://doi.org/10.1145/3639289\n[40] Paolo Ferragina and Giorgio Vinciguerra. 2020. The PGM-Index: A Fully-Dynamic\nCompressed Learned Index with Provable Worst-Case Bounds. Proceedings of the\nVLDB Endowment 13, 8 (apr 2020), 1162â€“1175. https://doi.org/10.14778/3389133.\n3389135\n[41] Congcong Fu, Hui Li, Jian Lou, Huizhen Li, and Jiangtao Cui. 2023. DP-starJ: A\nDifferential Private Scheme towards Analytical Star-Join Queries. Proc. ACM\nManag. Data 1, 4, Article 238 (Dec. 2023), 24 pages. https://doi.org/10.1145/\n3626725\n[42] Craig Gentry. 2009. Fully homomorphic encryption using ideal lattices. In Proceed-\nings of the forty-first annual ACM symposium on Theory of computing . 169â€“178.\n[43] Alexander Heinrich, Matthias Hollick, Thomas Schneider, Milan Stute, and Chris-\ntian Weinert. 2021. PrivateDrop: Practical Privacy-Preserving Authentication for\nApple AirDrop. In 30th USENIX Security Symposium (USENIX Security 21) . USENIX\nAssociation, 3577â€“3594. https://www.usenix.org/conference/usenixsecurity21/\npresentation/heinrich\n[44] Alexandra Henzinger, Emma Dauterman, Henry Corrigan-Gibbs, and Nicko-\nlai Zeldovich. 2023. Private Web Search with Tiptoe. In Proceedings of the\n29th Symposium on Operating Systems Principles (Koblenz, Germany) (SOSP\nâ€™23). Association for Computing Machinery, New York, NY, USA, 396â€“416.\nhttps://doi.org/10.1145/3600006.3613134\n15\n\n2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany Jiaoyi Zhang et al.\n[45] Alexandra Henzinger, Matthew M. Hong, Henry Corrigan-Gibbs, Sarah Meikle-\njohn, and Vinod Vaikuntanathan. 2023. One Server for the Price of Two: Simple\nand Fast Single-Server Private Information Retrieval. In 32nd USENIX Security\nSymposium (USENIX Security 23) . USENIX Association, Anaheim, CA, 3889â€“3905.\nhttps://www.usenix.org/conference/usenixsecurity23/presentation/henzinger\n[46] Noah Johnson, Joseph P. Near, Joseph M. Hellerstein, and Dawn Song. 2020.\nChorus: a Programming Framework for Building Scalable Differential Privacy\nMechanisms. In 2020 IEEE European Symposium on Security and Privacy (EuroS&P) .\n535â€“551. https://doi.org/10.1109/EuroSP48549.2020.00041\n[47] Noah Johnson, Joseph P. Near, and Dawn Song. 2018. Towards practical dif-\nferential privacy for SQL queries. Proc. VLDB Endow. 11, 5 (jan 2018), 526â€“539.\nhttps://doi.org/10.1145/3187009.3177733\n[48] Marcel Keller, Emmanuela Orsini, and Peter Scholl. 2016. MASCOT: Faster\nMalicious Arithmetic Secure Computation with Oblivious Transfer. In Proceedings\nof the 2016 ACM SIGSAC Conference on Computer and Communications Security\n(Vienna, Austria) (CCS â€™16) . Association for Computing Machinery, New York,\nNY, USA, 830â€“842. https://doi.org/10.1145/2976749.2978357\n[49] Marcel Keller, Valerio Pastro, and Dragos Rotaru. 2018. Overdrive: Making SPDZ\ngreat again. In Annual International Conference on the Theory and Applications of\nCryptographic Techniques . Springer, 158â€“189.\n[50] Dmitry Kogan and Henry Corrigan-Gibbs. 2021. Private blocklist lookups with\nchecklist. In 30th USENIX security symposium (USENIX Security 21) . 875â€“892.\n[51] Tim Kraska, Alex Beutel, Ed H. Chi, Jeffrey Dean, and Neoklis Polyzotis. 2018.\nThe Case for Learned Index Structures. In Proceedings of the 2018 International\nConference on Management of Data (Houston, TX, USA) (SIGMOD â€™18) . Association\nfor Computing Machinery, New York, NY, USA, 489â€“504. https://doi.org/10.\n1145/3183713.3196909\n[52] Albert Hyukjae Kwon, David Lazar, Srinivas Devadas, and Bryan Ford. 2015.\nRiffle: An efficient communication system with strong anonymity. (2015).\n[53] Hai Lan, Zhifeng Bao, J. Shane Culpepper, and Renata Borovica-Gajic. 2023.\nUpdatable Learned Indexes Meet Disk-Resident DBMS - From Evaluations to\nDesign Choices. Proceedings of the ACM on Management of Data 1, 2, Article 139\n(jun 2023), 22 pages. https://doi.org/10.1145/3589284\n[54] Xiaochen Li, Yuke Hu, Weiran Liu, Hanwen Feng, Li Peng, Yuan Hong, Kui Ren,\nand Zhan Qin. 2022. OpBoost: a vertical federated tree boosting framework based\non order-preserving desensitization. Proc. VLDB Endow. 16, 2 (Oct. 2022), 202â€“215.\nhttps://doi.org/10.14778/3565816.3565823\n[55] Yihao Liu, Xinyu Zeng, and Huanchen Zhang. 2024. LeCo: Lightweight Com-\npression via Learning Serial Correlations. Proc. ACM Manag. Data 2, 1 (2024),\n65:1â€“65:28. https://doi.org/10.1145/3639320\n[56] Qiyao Luo, Yilei Wang, Ke Yi, Sheng Wang, and Feifei Li. 2023. Secure Sampling\nfor Approximate Multi-party Query Processing. Proceedings of the ACM on\nManagement of Data 1, 3 (2023), 219:1â€“219:27.\n[57] Rasoul Akhavan Mahdavi and Florian Kerschbaum. 2022. Constant-weight\nPIR: Single-round Keyword PIR via Constant-weight Equality Operators. In\n31st USENIX Security Symposium (USENIX Security 22) . USENIX Association,\nBoston, MA, 1723â€“1740. https://www.usenix.org/conference/usenixsecurity22/\npresentation/mahdavi\n[58] Ryan Marcus, Andreas Kipf, Alexander van Renen, Mihail Stoian, Sanchit Misra,\nAlfons Kemper, Thomas Neumann, and Tim Kraska. 2020. Benchmarking Learned\nIndexes. Proceedings of the VLDB Endowment 14, 1 (sep 2020), 1â€“13. https:\n//doi.org/10.14778/3421424.3421425\n[59] Carlos Aguilar Melchor, Joris Barrier, Laurent Fousse, and Marc-Olivier Killijian.\n2016. XPIR: Private information retrieval for everyone. Proceedings on Privacy\nEnhancing Technologies (2016), 155â€“174.\n[60] Samir Jordan Menon and David J Wu. 2022. Spiral: Fast, high-rate single-server\nPIR via FHE composition. In 2022 IEEE Symposium on Security and Privacy (SP) .\nIEEE, 930â€“947.\n[61] Solomon Messing, Christina DeGregorio, Bennett Hillenbrand, Gary King, Saurav\nMahanti, Zagreb Mukerjee, Chaya Nayak, Nate Persily, Bogdan State, and Arjun\nWilkins. 2020. Facebook Privacy-Protected Full URLs Data Set. Version DRAFT\nVERSION (2020).\n[62] Prateek Mittal, Femi Olumofin, Carmela Troncoso, Nikita Borisov, and Ian Gold-\nberg. 2011.{PIR-Tor}: Scalable anonymous communication using private infor-\nmation retrieval. In 20th USENIX security symposium (USENIX security 11) .\n[63] Payman Mohassel and Peter Rindal. 2018. ABY3: A Mixed Protocol Framework\nfor Machine Learning. In Proceedings of the 2018 ACM SIGSAC Conference on\nComputer and Communications Security (Toronto, Canada) (CCS â€™18) . Association\nfor Computing Machinery, New York, NY, USA, 35â€“52. https://doi.org/10.1145/\n3243734.3243760\n[64] Muhammad Haris Mughees, Hao Chen, and Ling Ren. 2021. OnionPIR: Response\nefficient single-server PIR. In Proceedings of the 2021 ACM SIGSAC conference on\ncomputer and communications security . 2292â€“2306.\n[65] Muhammad Haris Mughees and Ling Ren. 2023. Vectorized batch private in-\nformation retrieval. In 2023 IEEE Symposium on Security and Privacy (SP) . IEEE,\n437â€“452.\n[66] Sarvar Patel, Joon Young Seo, and Kevin Yeo. 2023. Donâ€™t be dense: efficient\nkeyword PIR for sparse databases. In Proceedings of the 32nd USENIX Conferenceon Security Symposium (Anaheim, CA, USA) (SEC â€™23) . USENIX Association, USA,\nArticle 216, 18 pages.\n[67] Rishabh Poddar, Tobias Boelter, and Raluca Ada Popa. 2019. Arx: an encrypted\ndatabase using semantically secure encryption. Proc. VLDB Endow. 12, 11 (July\n2019), 1664â€“1678. https://doi.org/10.14778/3342263.3342641\n[68] Raluca Ada Popa, Catherine M. S. Redfield, Nickolai Zeldovich, and Hari Balakrish-\nnan. 2011. CryptDB: protecting confidentiality with encrypted query processing.\nInProceedings of the Twenty-Third ACM Symposium on Operating Systems Princi-\nples(Cascais, Portugal) (SOSP â€™11) . Association for Computing Machinery, New\nYork, NY, USA, 85â€“100. https://doi.org/10.1145/2043556.2043566\n[69] Christian Priebe, Kapil Vaswani, and Manuel Costa. 2018. EnclaveDB: A Secure\nDatabase Using SGX. In 2018 IEEE Symposium on Security and Privacy (SP) . 264â€“\n278. https://doi.org/10.1109/SP.2018.00025\n[70] Yiming Qiao, Yihan Gao, and Huanchen Zhang. 2024. Blitzcrank: Fast Semantic\nCompression for In-memory Online Transaction Processing. Proc. VLDB Endow.\n17, 10 (2024), 2528â€“2540. https://doi.org/10.14778/3675034.3675044\n[71] Lianke Qin, Rajesh Jayaram, Elaine Shi, Zhao Song, Danyang Zhuo, and Shumo\nChu. 2022. Adore: Differentially Oblivious Relational Database Operators. Proc.\nVLDB Endow. 16, 4 (Dec. 2022), 842â€“855. https://doi.org/10.14778/3574245.\n3574267\n[72] Lina Qiu, Georgios Kellaris, Nikos Mamoulis, Kobbi Nissim, and George Kollios.\n2023. Doquet: Differentially Oblivious Range and Join Queries with Private\nData Structures. Proc. VLDB Endow. 16, 13 (Sept. 2023), 4160â€“4173. https:\n//doi.org/10.14778/3625054.3625055\n[73] SEAL 2022. Microsoft SEAL (release 4.1). https://github.com/Microsoft/SEAL.\nMicrosoft Research, Redmond, WA..\n[74] Mo Sha, Yifan Cai, Sheng Wang, Linh Thi Xuan Phan, Feifei Li, and Kian-Lee\nTan. 2024. Object-oriented Unified Encrypted Memory Management for Hetero-\ngeneous Memory Architectures. Proceedings of the ACM on Management of Data\n2, 3 (2024), 155.\n[75] Mo Sha, Jialin Li, Sheng Wang, Feifei Li, and Kian-Lee Tan. 2023. TEE-based\nGeneral-purpose Computational Backend for Secure Delegated Data Processing.\nProceedings of the ACM on Management of Data 1, 4 (2023), 263:1â€“263:28.\n[76] Yuanyuan Sun, Sheng Wang, Huorong Li, and Feifei Li. 2021. Building enclave-\nnative storage engines for practical encrypted databases. Proc. VLDB Endow. 14,\n6 (Feb. 2021), 1019â€“1032. https://doi.org/10.14778/3447689.3447705\n[77] Jun Tang, Aleksandra Korolova, Xiaolong Bai, Xueqiang Wang, and Xiaofeng\nWang. 2017. Privacy loss in appleâ€™s implementation of differential privacy on\nmacos 10.12. arXiv preprint arXiv:1709.02753 (2017).\n[78] Kurt Thomas, Jennifer Pullman, Kevin Yeo, Ananth Raghunathan, Patrick Gage\nKelley, Luca Invernizzi, Borbala Benko, Tadek Pietraszek, Sarvar Patel, Dan Boneh,\net al.2019. Protecting accounts from credential stuffing with password breach\nalerting. In 28th USENIX Security Symposium (USENIX Security 19) . 1556â€“1571.\n[79] Stephen Tu, M. Frans Kaashoek, Samuel Madden, and Nickolai Zeldovich. 2013.\nProcessing analytical queries over encrypted data. Proc. VLDB Endow. 6, 5 (March\n2013), 289â€“300. https://doi.org/10.14778/2535573.2488336\n[80] Leixia Wang, Qingqing Ye, Haibo Hu, and Xiaofeng Meng. 2024. PriPL-Tree:\nAccurate Range Query for Arbitrary Distribution under Local Differential Privacy.\nProc. VLDB Endow. 17, 11 (Aug. 2024), 3031â€“3044. https://doi.org/10.14778/\n3681954.3681981\n[81] Sheng Wang, Yiran Li, Huorong Li, Feifei Li, Chengjin Tian, Le Su, Yanshan\nZhang, Yubing Ma, Lie Yan, Yuanyuan Sun, Xuntao Cheng, Xiaolong Xie, and\nYu Zou. 2022. Operon: an encrypted database for ownership-preserving data\nmanagement. Proc. VLDB Endow. 15, 12 (Aug. 2022), 3332â€“3345. https://doi.org/\n10.14778/3554821.3554826\n[82] Yilei Wang, Xiangdong Zeng, Sheng Wang, and Feifei Li. 2025. Jodes: Efficient\nOblivious Join in the Distributed Setting. In Proceedings of the 51st International\nConference on Very Large Data Bases (VLDB 2025) . London, United Kingdom.\n[83] Wai Kit Wong, Ben Kao, David Wai Lok Cheung, Rongbin Li, and Siu Ming Yiu.\n2014. Secure query processing with data interoperability in a cloud database\nenvironment. In Proceedings of the 2014 ACM SIGMOD International Conference\non Management of Data (Snowbird, Utah, USA) (SIGMOD â€™14) . Association for\nComputing Machinery, New York, NY, USA, 1395â€“1406. https://doi.org/10.1145/\n2588555.2588572\n[84] Chaichon Wongkham, Baotong Lu, Chris Liu, Zhicong Zhong, Eric Lo, and\nTianzheng Wang. 2022. Are Updatable Learned Indexes Ready? Proceedings of the\nVLDB Endowment 15, 11 (jul 2022), 3004â€“3017. https://doi.org/10.14778/3551793.\n3551848\n[85] David J Wu, Joe Zimmerman, JÃ©rÃ©my Planul, and John C Mitchell. 2016. Privacy-\npreserving shortest path computation. arXiv preprint arXiv:1601.02281 (2016).\n[86] Jiacheng Wu, Yong Zhang, Shimin Chen, Jin Wang, Yu Chen, and Chunxiao\nXing. 2021. Updatable Learned Index with Precise Positions. Proceedings of the\nVLDB Endowment 14, 8 (apr 2021), 1276â€“1288. https://doi.org/10.14778/3457390.\n3457393\n[87] Kevin Yeo. 2023. Lower bounds for (batch) PIR with private preprocessing. In\nAnnual International Conference on the Theory and Applications of Cryptographic\nTechniques . Springer, 518â€“550.\n16\n\nFemur: A Flexible Framework for Fast and Secure Querying from Public Key-Value Store 2025 ACM SIGMOD/PODS Conferences, June 22-27, Berlin, Germany\n[88] Xinyu Zeng, Yulong Hui, Jiahong Shen, Andrew Pavlo, Wes McKinney, and\nHuanchen Zhang. 2023. An Empirical Evaluation of Columnar Storage For-\nmats. Proc. VLDB Endow. 17, 2 (2023), 148â€“161. https://doi.org/10.14778/3626292.\n3626298\n[89] Huanchen Zhang, David G. Andersen, Andrew Pavlo, Michael Kaminsky, Lin\nMa, and Rui Shen. 2016. Reducing the Storage Overhead of Main-Memory OLTP\nDatabases with Hybrid Indexes. In Proceedings of the 2016 International Conference\non Management of Data, SIGMOD Conference 2016, San Francisco, CA, USA, June\n26 - July 01, 2016 , Fatma Ã–zcan, Georgia Koutrika, and Sam Madden (Eds.). ACM,\n1567â€“1581. https://doi.org/10.1145/2882903.2915222\n[90] Huanchen Zhang, Xiaoxuan Liu, David G. Andersen, Michael Kaminsky, Kimberly\nKeeton, and Andrew Pavlo. 2020. Order-Preserving Key Compression for In-\nMemory Search Trees. In Proceedings of the 2020 International Conference on\nManagement of Data, SIGMOD Conference 2020, online conference [Portland, OR,\nUSA], June 14-19, 2020 , David Maier, Rachel Pottinger, AnHai Doan, Wang-Chiew\nTan, Abdussalam Alawini, and Hung Q. Ngo (Eds.). ACM, 1601â€“1615. https:\n//doi.org/10.1145/3318464.3380583\n[91] Jiaoyi Zhang and Yihan Gao. 2022. CARMI: A Cache-Aware Learned Index with\na Cost-Based Construction Algorithm. Proceedings of the VLDB Endowment 15,11 (jul 2022), 2679â€“2691. https://doi.org/10.14778/3551793.3551823\n[92] Jiaoyi Zhang, Kai Su, and Huanchen Zhang. 2024. Making In-Memory Learned\nIndexes Efficient on Disk. Proc. ACM Manag. Data 2, 3, Article 151 (may 2024),\n26 pages. https://doi.org/10.1145/3654954\n[93] Shufan Zhang and Xi He. 2023. DProvDB: Differentially Private Query Processing\nwith Multi-Analyst Provenance. Proc. ACM Manag. Data 1, 4, Article 267 (Dec.\n2023), 27 pages. https://doi.org/10.1145/3626761\n[94] Yanping Zhang, Johes Bater, Kartik Nayak, and Ashwin Machanavajjhala. 2023.\nLongshot: Indexing Growing Databases Using MPC and Differential Privacy. Proc.\nVLDB Endow. 16, 8 (April 2023), 2005â€“2018. https://doi.org/10.14778/3594512.\n3594529\n[95] Mingxun Zhou, Andrew Park, Wenting Zheng, and Elaine Shi. 2024. Piano:\nextremely simple, single-server PIR with sublinear server computation. In 2024\nIEEE Symposium on Security and Privacy (SP) . IEEE, 4296â€“4314.\n[96] Yu Zou, Yiran Li, Sheng Wang, Le Su, Zhen Gu, Yanheng Lu, Yijin Guan, Dimin\nNiu, Mingyu Gao, Yuan Xie, and Feifei Li. 2024. Salus: A Practical Trusted Execu-\ntion Environment for CPU-FPGA Heterogeneous Cloud Platforms. In Proceedings\nof the 29th ACM International Conference on Architectural Support for Programming\nLanguages and Operating Systems (ASPLOS 2024) . San Diego, USA.\n17",
  "textLength": 109954
}