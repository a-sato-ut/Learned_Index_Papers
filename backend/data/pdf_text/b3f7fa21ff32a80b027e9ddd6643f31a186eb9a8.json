{
  "paperId": "b3f7fa21ff32a80b027e9ddd6643f31a186eb9a8",
  "title": "Bounded Evaluation: Querying Big Data with Bounded Resources",
  "pdfPath": "b3f7fa21ff32a80b027e9ddd6643f31a186eb9a8.pdf",
  "text": " \nBounded Evaluation: Querying Big Data\nwith Bounded Resources\nYang Cao  1          Wen-Fei Fan  1,2,3          Teng-Fei Yuan  1\n1 University of Edinburgh, Edinburg EH8 9AB, UK\n2 Shenzhen Institute of Computing Sciences, Shenzhen University, Shenzhen 518060, China\n3 Beijing Advanced Innovation Center for Big Data and Brain Computing, Beihang University, Beijing 100191, China\n \nQ\nD\nDQ\nD\nQ(D )\n=Q(D Q)\nDQ\nD\nDQ\nQ\nAbstract:    This  work  aims  to reduce  queries  on big data  to computations  on small  data,  and hence  make  querying  big data  possible  un-\nder bounded  resources.  A query    is boundedly evaluable  when  posed  on any big dataset  , there  exists  a fraction    of    such  that\n,  and the cost of identifying    is independent  of the size of  . It has been  shown  that  with  an auxiliary  structure\nknown  as access  schema,  many  queries  in relational  algebra  (RA)  are boundedly  evaluable  under  the set semantics  of RA. This  paper  ex-\ntends  the theory  of bounded  evaluation  to RAaggr,  i.e., RA extended  with  aggregation,  under  the bag semantics.  (1) We extend  access\nschema  to bag access  schema,  to help  us identify    for RAaggr  queries  . (2) While  it is undecidable  to determine  whether  an RAaggr\nquery  is boundedly  evaluable  under  a bag access  schema,  we identify  special  cases  that  are decidable  and practical.  (3) In addition,  we\ndevelop  an effective  syntax  for bounded  RAaggr  queries,  i.e., a core  subclass  of boundedly  evaluable  RAaggr  queries  without  sacrificing\ntheir  expressive  power.  (4) Based  on the effective  syntax,  we provide  efficient  algorithms  to check  the bounded  evaluability  of RAaggr\nqueries  and to generate  query  plans  for bounded  RAaggr  queries.  (5) As proof  of concept,  we extend  PostgreSQL  to support  bounded  eval-\nuation. We experimentally verify that the extended system improves performance by orders of magnitude.\nKeywords:   Bounded evaluation, resource-bounded query processing, effective syntax, access schema, boundedness.\n \n1   Introduction\nQ(D )\nD\nQuerying big data can be prohibitively costly. As an\nindicator, it is NP-hard1 to decide whether a tuple is in\nthe  answer  in  a  dataset  to  an  SPC  (select,\nproject, Cartesian product) query Q, and it is PSPACE-\nhard1 when Q is a query in relational algebra (denoted by\nRA)[2].  It  takes  days  to  join  two  tables  with  10  million\ntuples each[3]. One might be tempted to think that paral-\nlel  computation  could  do  the  job.  However,  there  exist\ncomputational  problems  for  which  parallel  scalability  is\nbeyond  reach, i.e., no  matter  how  many  machines  are\nused, the  parallel  runtime  of  algorithms  for  such  prob-\nlems may not be reduced[4]. Worse still, small businesses\ntypically have constrained resources and may not afford\nlarge-scale parallel computation.\nIs querying big data beyond the reach of small com-\npanies, or is it just a privilege of big companies? Is it pos-\nsible to extend DBMS with an immediate capacity to an-\nswer common  queries  over  big  datasets  under  con-\nstrained resources?\nD\nDQ\nD\nQ(D )\nD\nA\nA\nD\nA\nDQ\u0012\nD\nDQ\nA\nQ(D Q)\n=Q(D )\nDQ\nA\nA\nAOne  approach  to  tackling  the  challenge  has  recently\nbeen  studied,  based  on  bounded  evaluation[5, 6]. To  an-\nswer a query Q on a dataset ,  the idea is to look at only\na “bounded” fraction  of  that suffices to compute\n,  instead of at the entire . This is doable by using\nan access schema , which  is a combination of cardinal-\nity  constraints  and  associated  indices.  Under ,  Q is\nboundedly evaluable if for all datasets  that conform to\n,  one can identify  by reasoning about the car-\ndinality constraints, and fetch  by using the indices of\n,  such that (a)  and (b)  is determ-\nined by  and Q only. In other words, if Q is boundedly\nevaluable  under ,  query Q can  then  be  exactly\nanswered via bounded evaluation, by accessing only DQ\nof size bounded by the cardinalities in .\nThe theory has been tested in industry and is found to\n“improve the performance by orders of magnitude”[7].\nD1\nExample 1. Consider query Q1 from Facebook Graph\nSearch[8]: Find all my friends who have check-ins in UK2.\nThe  query  is  posed  on  dataset  with  two  relations:\n(a) friend (uid, fid), stating that person fid is a friend of\nuid, and (b) checkin (uid, loc, cty, date), stating that per-\nson uid checked in at location loc in country cty on date.\nWritten  as  an  RA  query, Q1 is  as  follows  (u0 denotes\n“me”): \nResearch Article\nManuscript  received  February  21, 2020;  accepted  April  20, 2020;\npublished online July 4, 2020\nRecommended by Editor-in-Chief Guo-Ping Liu\n \n© The Author(s) 2020\n \n1See  [1]  for  more  about  complexity  classes,  e.g.,  NP  and\nPSPACE. 2Facebook users can check-in to locations via “check-ins”.International  Journal of Automation  and Computing 17(4),  August 2020,  502-526\nDOI:  10.1007/s11633-020-1236-1\n \n\n\nQ1(x)\n= friend(u 0;x)1checkin(x; loc; “UK”; date):\nD1\nQ1(D1)Here  dataset  is  big,  with  trillions  of  friend  links\nand check-ins[9]. It is costly to compute  directly.\nA1\nNow  consider  a  set  of real-life  cardinality  con-\nstraints:\n◦ϕ1\nfriend(pid! fid;5\n000)\n:  ;\n◦ϕ2\ncheckin(uid! country; 193)\n:  .\nϕ1\nϕ2\nD1\nϕ1\nϕ2\nHere  constraint  specifies  a  Facebook  policy[10]:  a\nlimit  of  5 000  friends  per  user;  and  states  that  each\nuser can check-in at most 193 countries. Indices can be\nbuilt on  based on  such that given a person, it re-\nturns the ids of all her friends by accessing at most 5 000\nfriend tuples; similarly for . Taken  together, these con-\nstraints and their associated indices are called access con-\nstraints[5].\nA1\nQ1(D1)\nD1\nϕ1\nϕ2\nQ1(D1)\nD1\nA1\nUsing ,  we  can  compute  by  accessing  at\nmost 970 000 tuples from ,  instead of trillions. (1) We\nfetch T1 of at most 5000 fid′s of friend tuples with uid =\nu0, by using .  (2) For each fid f in T1, we fetch T2 of at\nmost 193 country values with .  (3) We return the set of\nfid′s in T1 with country = UK in T2. The plan fetches at\nmost 5 000 + 193 × 5 000 tuples to compute ,  no\nmatter how big  is. Hence, Q1 is boundedly evaluable\nunder .\nDQ\nAs shown in Example 1, bounded evaluation answers\na query Q over a big dataset by accessing a set  of\ndata values with bounded size. It does this by retrieving\nvalues (i.e., partial tuples) using indices associated with\ncardinality  constraints  that  correlate  attributes.  One\nmight think that this can also be carried out by conven-\ntional  index-only  plans  for  query  optimization[11].\nHowever, the two are different problems as indicated by\ntheir complexity bounds: deciding whether an SPC query\ncan be  answered  with  a  “bounded”  query  plan  is  EX-\nPSPACE-hard[5], while it is in PTIME to decide whether\nit has an index-only plan[11].\nWhile  bounded  evaluation  is  promising,  more  work\nhas to be done, from theory to systems. Bounded evalu-\nation has only been studied for RA queries under the set\nsemantics[5, 6]. In  the  real  world,  queries  are  often  ex-\npressed in RAaggr, i.e., RA extended with aggregation un-\nder the bag semantics. RAaggr can express all SQL (struc-\ntured query language) queries that do not carry arithmet-\nic expressions. This makes bounded evaluation more in-\ntriguing.\nA1\nExample 2. Recall query Q1 and access schema \nfrom Example 1. Consider query Q2 to find the number of\nUK check-ins from each of my friends. Written in RAaggr,\nQ2 is:\nQ2 = gpBy(Q3, uid, count(cty)), where\nQ3=\u0019uid;cty (friend(u 0;\nx)1checkin(x; loc; ”UK”; date):\nA1\nHere gpBy(Q3, uid, count(cty)) groups the results of\nQ3 by  attribute  uid  and  calculates  count(cty)  for  each\ngroup (see Section 2.1 for more details about gpBy oper-\nator). In contrast to Q1,  does not help us answer Q2.Using φ2, we can fetch a set of distinct countries for each\nfriend x.  However, x may  have  multiple  UK  check-ins.\nAccess schema no longer suffices for RAaggr under the bag\nsemantics.\nFor practical use to emerge from the study, it is neces-\nsary  to  extend  bounded  evaluation  from  RA  to  RAaggr\n(SQL). This gives rise to several questions. How should\nwe extend the access schema of [5, 6] to support the bag\nsemantics?  We  will  see  that  the  problem  for  checking\nwhether an SQL query is boundedly evaluable is undecid-\nable.  Given  the  negative  result,  is  bounded  evaluation\nbeyond reach in practice? More specifically, is there any\npractical and decidable special case? Is it possible to de-\nvelop  a  systematic  method  that  allows  us  to  efficiently\ncheck the bounded evaluability of SQL queries? In addi-\ntion, after determining that an SQL query is boundedly\nevaluable,  how  can  we  generate  and  optimize  a  query\nplan to carry out its bounded evaluation?\nContributions.  This  paper  answers  these  questions\nby extending the study to RAaggr, from theory to prac-\ntice.\n(1) Bounded evaluation for SQL .  We  extend  bounded\nevaluation from RA to RAaggr, i.e., SQL (without arith-\nmetic)  to  support  arbitrarily  nested  aggregate  sub-quer-\nies and group-by clauses. We introduce bag access schem-\nas, an extension of the access schema of [5, 6] to support\nthe  bag  semantics.  We  also  formulate  bounded  query\nplans for RAaggr.\n(2) Complexity of bounded evaluation . Not surprising -\nly, bounded evaluability is undecidable for SQL since it is\nalready undecidable for RA[5]. We identify practical con-\nditions that cover a number of real-life queries, for which\nthe  bounded  evaluability  can  be  efficiently  determined.\nThese conditions tell us what makes queries bounded.\nLB\nB\nQ′2\nLB\nLB\nLB\n(3) Effective syntax . To accommodate the undecidab-\nility,  we  develop  an  effective  syntax  for  boundedly\nevaluable RAaggr queries. We show that under a bag ac-\ncess schema ,  (a) an RAaggr query Q is boundedly evalu-\nable if and only if it is equivalent to a query ;  and\n(b) it is in PTIME (polynomial time) to check whether Q\nis in .  That is,  is a core subclass of bounded evalu-\nable  RAaggr queries  that  are  syntactically  checkable\nwithout sacrificing the expressive power. This is along the\nsame lines as how commercial database systems (DBMS)\ndeal with safe relational calculus queries, which are unde-\ncidable to decide[12–14].\nB\nB\nQ(D )\nDQ\nD\nB\n(4) Extending DBMS with bounded evaluation . We pr -\nesent a framework, referred to as BEAS (bounded evalu-\nable SQL) to provide commercial DBMS with the capab-\nility  of  bounded  evaluation  of  RAaggr queries.  Given  an\nRAaggr query Q and a bag access schema ,  BEAS first\nchecks whether Q is boundedly evaluable under .  If so,\nit generates a query plan for Q to compute  by ac-\ncessing a bounded small fraction  of  using . Other-\nwise, it leverages access schema and generates a partially\nbounded plan, to bound sub-queries of Q. We develop al-Y. Cao et al. / Bounded Evaluation: Querying Big Data with Bounded Resources 503 \n \n\n\ngorithms underlying BEAS.\n(5) Experimental study . As  proof  of  concept,  we  ex-\ntend  PostgreSQL  with  bounded  evaluation,  denoted  by\nBEAS@PG.  Using  TPCH  benchmark[15] and  real-life\ndatasets,  we  evaluate  the  performance  of  BEAS@PG\ncompared to  PostgreSQL.  We  find  that  BEAS@PG  im-\nproves  PostgreSQL  by  up  to  4  orders  of  magnitude  for\nboundedly evaluable queries.\nD\nQuerying  big  data  under  bounded  resources.\nThis  work  is  a  component  of  a  framework  for  querying\nbig data. As outlined in [16], the framework works as fol-\nlows: given an SQL query Q posed on a big dataset ,\n(1) it first checks whether Q is boundedly evaluable;\nQ(D )\nD\n(2) if so, it computes the exact answer  by ac-\ncessing a bounded fraction DQ of  via bounded evalu-\nation;\nD\n(3) otherwise, it computes approximate answers to Q\nin  also by accessing a bounded amount of data, and\nprovides deterministic accuracy ratios[17].\nIn the entire process, it only accesses a bounded frac-\ntion of  data  and  can  be  conducted  under  bounded  re-\nsources.  Hence  it  is  feasible  to  provide  small  businesses\nwith a capacity of querying big data despite constrained\nresources.\nTo simplify the discussion, we focus on row-oriented\nDBMS (a.k.a. row stores) in this paper. Nonetheless, as\nwill be  seen  in  Section  2,  the  model  of  bounded  evalu-\nation subsumes column stores. Moreover, bounded evalu-\nation can be readily extended to parallel and distributed\nsystems[18].\nLB\nOrganization. The remainder of the paper is organ-\nized  as  follows.  Section  2  defines  bag  access  constraints\nand formulates boundedly evaluable RAaggr queries. Sec-\ntion 3 studies the complexity of bounded evaluation for\nRAaggr queries. Section 4 proposes effective syntax  for\nboundedly evaluable RAaggr queries. Section 5 introduces\nBEAS and develops its underlying algorithms. The exper-\nimental study  is  presented  in  Section  6.  We  discuss  re-\nlated  work  in  Section  7,  and  identifies  topics  for  future\nwork in Section 8.\n2   Bounded evaluation of SQL queries\nWe  first  define  bag  access  schema  (Section  2.1)  and\nthen formulate bounded evaluation of RAaggr queries, ag-\ngregate or not, under the bag semantics (Section 2.2).\n2.1   RAaggr and bag access schema\nWe start with a review of RAaggr, an extension of RA\nwith a group-by construct and nested aggregate sub-quer-\nies.\n\u001bC\n\u0019Y\n\u0002\n1C\n\u001aA!B\n[\nRAaggr queries.  An  RAaggr query  is  an  expression\ndefined in terms of RA operators (i.e., select ,  project\n,  Cartesian-product  or join , renaming , uni-\non  and  set  difference  -),  and  additionally  a  group-byaggregate operator\ngpBy(Q;\nX; agg1(V1);\u0001\u0001\u0001;aggm(Vm))\nX[∪m\ni=1faggi(Vi)g\ngpBy(Q;\nX; agg(V ))\nwhere  (a) Q is  an  RAaggr query,  (b) X is  a  set  of\nattributes  for  group-by,  (c)  aggi is  one  of  aggregate\nfunctions max, min, count, sum, avg, and (d) V1, ··· , Vm\nare  attributes  such  that  forms  the\noutput relation of Q. We refer to aggi(Vi) as an aggregate\nfield  on  attribute Vi.  We  write  the  operator  as\n when  it  is  clear  from  the  context.\nSince Q may  include  aggregate  operators  itself,\naggregations  in  an  RAaggr query  may  be  arbitrarily\nnested.\nIn SQL syntax, the operator can be written as\nselectX\n;agg1(V1);\u0001\u0001\u0001;aggm(Vm)\nfrom Q\ngroup by X\nX=∅\ngpBy(Q;\nX; agg(V ))\nAs  a  special  case,  when ,  \ndoes not have a group-by construct. We write it simply\nas agg(Q).\nExample  3. Query Q2 in  Example  2  is  an  RAaggr\nquery.\nAs another example, an RAaggr query with nested ag-\ngregation  is Q4 over  relations R(A, B, C)  and S(E, F,\nW):\nQ4= avg(\u0019 z(Q5(y)1S(y\n;1;z)))\n, where\nQ5(y)\n= sum(\u0019 y(R(w;1;u)1R(w;x;y )))\n     .\nR\nB\nBag access schema. To support the bag semantics,\nwe  extend  the  access  schema  of  [5, 19]  to bag  access\nschema. Over a database schema ,  a bag access schema\n is a set of bag access constraints of the form:\nφ=R(jX!Y\n;Nj)\nR\nwhere R is a relation schema in ,  X and Y are sets of\nattributes of R, and N is a positive integer.\nD\nR\nR\nDY(X=\n\u0016a) =ft[Y ]jt2D;\nt[X]\n= \u0016ag\nDY(X=\n\u0016a)\nY\n\u0016a\nab\nm(D\n;ab)\nf\njt2Djt[XY ] =abj\ng\nab\nm(D\n;ab)\nab\nTo define the semantics of bag access constraints, we\nuse the following notations. (1) Denote by  a database\nof ,  and by D an instance of relation schema R in .\n(2) For an instance D of R, \n,  i.e.,  denotes  the  set  of  values\ncorresponding to X-value .  (3) For any XY-value  in\nD,  denotes the cardinality of the bag (multiset)\n,  i.e., the number of occurrences of\n as XY attributes  in D;  we  refer  to  as  the\nmultiplicity of  in D.\n \nDj=φ\nWe say that D conforms to , denoted by  , if\nX\n\u0016a\nD\njDY(X=\n\u0016a)j\u0014N\nN\nY\nD\n(1)  for  any -value   in , , i.e.,\nthere exist at most  distinct associated -values in ;\nand\nφ\n\u0016a\n\u0016b\n\u0016b\nm(D\n;ab)\n(2) there exists an index for  on D such that given\nany X-value ,  by  accessing  at  most N tuples, it  re-\ntrieves (a) all associated distinct Y-values  in D, and (b)\nfor each such , the multiplicity  .\nDj=φ\nIntuitively,  if  for  any X-value,  there  exist  at 504 International Journal of Automation and Computing 17(4), August 2020\n \n\n\nmost N distinct corresponding Y values in D. Moreover,\nthese Y-values (partial tuples) and their multiplicities in\nD are indexed by ψ and can be efficiently retrieved via\nthe index.\nA1\nB1\nExample 4. Extending  of Example 1, a bag ac-\ncess schema  consists of the following bag access con-\nstraints:\n◦\nφ1= friend(jpid! fid;5000j)\n;\n◦\nφ2= checkin(juid! country; 193j)\n.\nHere φ2 says  that  (a) for  any  uid u1,  there  exist  at\nmost 193 distinct country values, and (b) there exists an\nindex built on the friend relation that given any uid u1,\nfetches  all  associated  distinct  countrys c and  for  each\ncountry c,  the  multiplicity  of  (u1, c) in  the  friend  rela-\ntion for country c; similarly for φ2.\nB2\nAs another example, consider a bag access schema \nfor Q4 of Example  3,  which  consists  of  bag  access  con-\nstraints:\n◦φ3=R(jA!B\n;1j)\n,\n◦φ4=R(jB!C\n;10j)\n, and\n◦φ5=S(jE\nF!W;10j)\n.\nB2\nWe will see that Q4 can be efficiently answered with\n.\nD\nR\nB\nD\nj=B\nDj=φ\nφ2\nB\nφ=R(jX!Y\n;Nj)\nD\nA database instance  of  conforms to a bag access\nschema ,  denoted by , if  for every ,\nwhere ,  and D is the instance of R in .\n\u0016a\njDY(X=\n\u0016a)j\u0014N\n\u0016b\nab\nIntuitively, a bag access constraint φ extends an ac-\ncess constraint ψ of [5, 19] by incorporating multiplicity.\nSimilar to ψ, given any X-value  in D, φ enforces the\ncardinality constraint  and returns dis-\ntinct  corresponding Y-values.  In  contrast  to ψ,  for  each\ncorresponding Y-value ,  φ also returns the multiplicity of\n in D. In other words, access constraints under the set\nsemantics[5, 6] are a special case of bag access constraints\nwhen we only bound the cardinality and retrieve distinct\nvalues.\nRemark 1. When it is clear from the context, we also\nsimply refer to bag access schema as access schema.\n2.2   Bounded evaluation of RAaggr queries\nWe next define bounded evaluation for RAaggr queries.\nR(jX!Y\n;Nj)\n(t[X\n;Y];m(t[X;Y ]))\nMultiplicity relations. From an instance D of a re-\nlation  schema R,  we  can  use  the  index  of  a  bag  access\nconstraint  to retrieve a relation consisting\nof tuples ,  where t is a tuple in D. It\nis a set that besides partial tuples t[X, Y] in D, carries\nmultiplicity m(D, t[X, Y]), and is referred to as a multi-\nplicity relation.\n1C\nI11CI2\nI11CI2\nM=m(I1;\nt1)\u0002\nThe RAaggr operators can be readily extended to mul-\ntiplicity relations. Take join operator  as an example.\nGiven two multiplicity relations I1 and I2, the result of\n,  denoted by Is, is a multiplicity relation as fol-\nlows: (a) tuples in Is have the form (t, M), where t is a\nresult  tuple  of  using the  conventional  join  se-\nmantics  (ignoring  multiplicity),  and  (b) \nm(I2;\nt2)\nt12I1\nt22I2\nIi(i2\nf1;2g),  where t is joined from  and , and\nm(Ii, ti) denotes the multiplicity of tuple ti in multipli-\ncity relation .  Similarly, other RAaggr operat-\nors are defined on multiplicity relations.\n\u0018\nB\nφ=R(jX!Y\n;Nj)\nB\nS=∪\n\u0016a2TDX\nY(X= \u0016a)\nBounded RAaggr plans. A  bounded  RAaggr plan \nunder a bag access schema  is an algebra tree that ex-\ntends conventional RAaggr query plans with a new operator\nfetch(T,φ), where  is a bag access con-\nstraint in ,  and T is an intermediate multiplicity rela-\ntion on attributes R[X] (see Appendix for a formal defini-\ntion).  Over  an  instance D of R that  conforms  to φ,\nfetch（T, φ）retrieves  an  intermediate  relation\n by  using  the  index  of φ on D,\nwhere  each  tuple t in S is  annotated  with  multiplicity\nm(D, t) (also retrieved by φ).\n∅\nD\nB\nIntuitively, a bounded RAaggr plan starts with a set of\nconstants  (possibly ),  retrieves  data  from  via  the\nfetch  operator,  and  applies  RAaggr operators  to  the\nfetched data, except that it accesses data by employing\nthe indices of the bag constraints in  only, and allows\ngroup-by aggregate and operates on multiplicity relations.\n\u0018(D)\nD\nWe denote by  the result of applying plan ξ to .\nB1\n\u0018Q2\nB1\nExample 5. Recall RAaggr query Q2 from Example 2\nand bag access schema  from Example 4. A bounded\nplan  for Q2 under , written in algebra expressions,\nis as follows:\nT1(uid; fid)\n=fetch(fu0g;φ 1)\n,\nT2(uid; cty)\n=fetch(\u0019 fidT1;φ2)\n,\nT3(uid; cty)\n=\u001bctyT2\n,\nT4= gpBy(T 3;uid; count(cty))\n.\nB2\nD\nj=B2\nQ4\u0011B2Q6\nD\nj=B2\nAs  a  more  intriguing  example,  recall  query Q4 from\nExample  3  and  bag  access  schema  from  Example  4.\nBy the cardinality constraint in φ3, for each A-value in\nany database instance  for w of Q4, there exists at\nmost  1  distinct B-value  associated  with w.  Therefore,\n,  i.e., Q4 is  equivalent  to Q6 on every  data-\nbase , where  Q6 is\nQ6= avg(\u0019 z(Q7(y)1S(y\n;1;z)))\n, where\nQ7(y)sum(\u0019 yR(w\n;1;y))\n.\nB2\n\u0018Q4\nUnder ,  Q6 (hence Q4) has a bounded query plan\n:\nT1(B\n;C) = fetch(f1g;φ 4)\n,\nT2= sum(\u0019 CT1)\n,\nT3(E\n;F;W ) = fetch(T 2\u0002f1g;φ 5)\n,\nT4= avg(\u0019 WT3)\n.\n\u0018Q4\n\u0018Q4\n\u0018Q4\nD\nj=B2\nObserve that  does not explicitly use φ3. However,\nthe  correctness  of  relies  on  the  cardinality  of φ3.\nMoreover,  propagates  constants  of Q4 via  join  and\nfetch,  such  that  all  values  and  their  combinations  that\nare needed for answering Q4 are fetched from .  In\nparticular, in the presence of nested aggregation, answers\nto aggregate sub-queries can also be used by fetch, e.g.,\nT3.\nB\nBoundedly  evaluable  queries. Under  access\nschema ,  an RAaggr Q is boundedly evaluable if it has aY. Cao et al. / Bounded Evaluation: Querying Big Data with Bounded Resources 505 \n \n\n\nplan ξ such that:\n◦\u0018\nB\n is a bounded RAaggr plan under ;\n◦\n constants {c} in ξ are from selection conditions of Q;\n◦\nD\nj=B\n\u0018(D)\n=Q(D )\n moreover, for any database , .\nQ\u0011B\u0018\nWe write  if Q has such a bounded query plan\nξ.\n(t;\nm)2D1\nHere  for  any  multiplicity  relation D1 and a  conven-\ntional bag (multiset) D2, we write D1 = D2 if D2 can be\nobtained  from D1 by  including m copies  of  each  tuple\n.\nB1\n\u0018Q2\nB2\nFor  example,  query Q2 of  Example  2  is  boundedly\nevaluable under  of Example 4, since it has a bounded\nplan  given in Example 5. Similarly, Q4 of Example 3\nis also boundedly evaluable under  of Example 4.\nObserve the following about bounded RAaggr plans ξ.\nB\nD\nD\nB\n(1) Scale independence . Each fetch operation in ξ re-\ntrieves data with a cost that can be quantified by the bag\nconstraint employed. Hence the cost of executing ξ is de-\ntermined by bag access schema  and query plan ξ only,\nnot by the size of dataset  as long as  conforms to .\nThat is, under the bag semantics, bounded RAaggr plans\npreserve the scale independence of bounded evaluation for\nRA queries[5, 6].\n(2) Late bag semantics enforcement .  Plan ξ fetches\nand operates on sets since fetch(T, ψ) returns a set. It\ndefers the process of the bag semantics to a stage as late\nas possible. This reduces performance degradation caused\nby  duplicated  values  in,  e.g., joins,  in  which  duplicates\nget inflated rapidly.\nR(j∅\n!A;Nj)\n(3) Subsuming column-stores . Bounded plan ξ can also\nexpress query evaluation over column-stores[20] or column-\nstore indices[21]. Indeed, in a column store (or a column-\nstore index), each column (or column index) on attribute\nA of a relation schema R is essentially a special case of\nbag  access  constraint  of  the  form .  Hence,\ncolumn store and columnstore index are a special case of\nbag access schema and hence their evaluation plan can be\nexpressed by a bounded plan ξ under such a bag access\nschema.\nR(jX!Y\n;Nj)\nNote that the efficiency of column stores mainly comes\nfrom  its  implementation-level  optimization,  e.g., column\ncompression  and  vectorization[20]. While  these  optimiza-\ntion strategies can also be used to implement the indices\nof bag access schema, these are not the focus of this pa-\nper. We study query evaluation at the logical level, un-\nder generic constraints  when X is not ne-\ncessarily  empty.  Hence,  this  paper  focuses  on  row-ori-\nented databases  as  the  underlying  platform  for  imple-\nmenting bag access schema.\n3   Complexity of bounded evaluation\nIn this section, we study the complexity of bounded\nevaluability and identify practical decidable cases.\nBounded evaluability. The problem is stated as fol-\nlows.\n◦\nR\nB\nR\nR Input: A database schema , a bag access schema \nover , and an RA aggr query Q over .\n◦\nB\n Question: Is Q boundedly evaluable under ?\nThis bounded evaluability problem is to decide wheth-\ner  a  query  can  be  answered  by  accessing  a  bounded\namount  of  data,  and  is  underlying  the  first  step  of  our\nframework for  querying  big  data  under  bounded  re-\nsources (Section 1).\nNo matter how important, the problem is hard. To see\nwhy it is intriguing, let us consider Example 6.\nB3\nExample 6. Consider bag access schema  and SPC\nquery Q8 defined on relations T(A, B) and U(E, F):\n◦B3\n consists of the following two access constraints:\nφ6=T(jA!B\n;Nj)\n,\nφ7=U(jE!F\n;2j)\n;\n◦\nQ8=Q9\u0000Q10\n query , where\nQ9=\u0019y(T(x;\ny)1U(w;1)1U(w;x )1U(w;y ))\n, and\nQ10=\u0019z(T(z\n;z)1U(u;1)1U(u;z ))\n.\nB3\nU(w\n;1)1U(w;x )1U(w;y )\nB3\nB3\nQ1\n9[Q2\n9\nQ1\n9=\u0019y(T(1;\ny)1\nU(w\n;1)1U(w;;y )\nQ2\n9=\u0019y(T(y\n;y)1U(w;1)1\nU(w\n;y)\nQ8=\n(Q1\n9[Q2\n9)\u0000Q10=Q1\n9\nQ2\n9\u0011Q10\nQ1\n9\nB3\nAt a first glance, none of Q9 and Q10 seems boundedly\nevaluable, and hence neither is Q8. Indeed, we cannot re-\ntrieve  values  for  any  of x, y or z using  indices  in .\nHowever,  putting  together \nand φ7 of ,  one can deduce that x must be equal to\neither 1 or y in all tuples retrieved from instance of T by\nany query plan for Q9. In other words, under ,  Q9 re-\nduces  to  SPCU ,  where \n and \n.  Hence,  since\n.  It is easy to see that  is boundedly evalu-\nable under  and as a result, so is Q8.\n[\nQ1\n4[Q2\n4\nQ1\n4\nAs shown above, it is often necessary to check query\nequivalence  to  decide  whether  a  query  is  bounded.  The\nuse of union ( ) allows  us to convert SPC to SPCU un-\nder a bag access schema (e.g., Q4 to ),  which may\nfurther interact with set difference (–) (e.g., Q3 and ).\nIt is  beyond  reach  in  practice  to  check  the  equival-\nence of RA or RAaggr queries. Thus, the bounded evaluab-\nility problem is already undecidable for RA, a special case\nof RAaggr.\nTheorem 1.[5] The  bounded  evaluability  problem  is\nundecidable for RA queries.\nTheorem 1 was verified under access schema. As re-\nmarked  in  Section  2,  access  schema  is  a  special  case  of\nbag access schema. Hence, the bounded evaluability prob-\nlem  remains  undecidable  for  RA  under  a  bag  access\nschema. As an immediate corollary, the bounded evaluab-\nility problem is undecidable for RAaggr, which subsumes\nRA.\nDecidable  cases. We  next  identify  special  cases\nwhen the bounded evaluability is decidable. The reason is\ntwofold.  (1)  The  special  cases  cover  a  large  number  of\nRAaggr queries used in practice, e.g., all SPC sub-queries\nof built-in benchmark queries in TPCH[15] and TPCDS[22].\n(2) These cases reveal insight about why queries become\nboundedly evaluable. In Section 4, we will deal with gen- 506 International Journal of Automation and Computing 17(4), August 2020\n \n\n\neric  RAaggr queries,  by  devising  an  effective  syntax  for\nboundedly evaluable RAaggr queries.sub> queries.\nCP\n(I) PTIME cases. The first special case, denoted by\n, consists  of combinations of SPC queries and bag ac-\ncess  schema  for  which  the  bounded  evaluability  can  be\nchecked  in  PTIME,  covering  all  SPC  sub-queries  of\nTPCH and TPCDS.\nCP\nB\nR\n(B;\nQ)2CP\nClass .  For  any  bag  access  schema  and  SPC\nquery Q over the same database schema ,   if\nφ=R(jX!Y\n;Nj)\nN\n>jjQjj\nj\njQjj\n(a)  for  each  bag  constraint ,\n,  where  is the number of relation atoms in Q;\nand\n(b) Q has no self-join.\nB\nTheorem 2. For any bag access schema  and SPC\nQ,\n(B;\nQ)\nCP\n(1) it is in PTIME to decide whether  is in ;\nand\nB\n(B;\nQ)\nCP\n(2) it is in PTIME to decide whether Q is boundedly\nevaluable under  if  is in .\nB\nProof. Statement  (1)  apparently  holds.  Below  we\nprove  (2)  by  giving  a  PTIME  sufficient  and  necessary\ncondition for checking the bounded evaluability of Q un-\nder .\ncov(Q;B)\nB\nXQ\nC\n\u001bA=c\ncov(Q;B)\nThe condition needs a notion of covered SPC queries\nfrom [6]. It is characterized by a set , which  con-\nsists of attributes whose values can be retrieved via fetch\noperations along with ,  without directly accessing raw\ndata in a database. More specifically, let  be the set of\nattributes A in  the  constant  selection  predicates  of Q,\ni.e.,  for a constant c. Then  is inductively\ndefined as:\nXQ\nC\u0012 cov(Q;B)\n(a) ;\nA2cov(Q;B)\n\u0006Q⊢A=B\nA=B\n\u0006Q\nB2cov(Q;B)\n(b)  if  and  (denoting  that\n can be deduced from selection predicates  via\nthe transitivity of equality), then ;\nX\u0012 cov(Q;B)\nR(jX!Y\n;Nj)2B\nY\u0012 cov(Q;B)\n(c)  if  and ,  then\n; and\ncov(Q;B)\n(d)  contains nothing else.\nXQ\nR\nDenote by  the set of attributes that are either in\nthe selection or join predicates of Q, or are the top-level\nprojection attributes. Then we show the following.\n(B;\nQ)2CP\nB\nφ=R(jX!Y\n;Nj)2B\nXQ\nR\u0012X\nY\u0012\ncov(Q;B)\nLemma 3. For any ,  Q is boundedly eval-\nuable  under  if  and  only  if  for  each  relation R in Q,\nthere  is  such  that \n.\nB\nFrom Lemma 3, Theorem 2(2) follows since one can\nsimply check the condition of Lemma 3 in PTIME in the\nsizes of Q and . Below we prove Lemma 3.\n)\nB\nB\n\u0018\u0011Q\u0018\u0011BQ\nQ\u0011BQ′\nQ(D )\n=Q′(D)\nD\nj=B\n( )  Assume that Q is boundedly evaluable under .\nThen there exists a bounded plan ξ for Q under . Be-\nlow we first inductively construct a query Qξ from ξ such\nthat  (a) ,  where  means  that\n for any database , and (b) Qξ satis-\nfies the condition on Q in Lemma 3. We then show that\nQ also  satisfies  the  condition  when Qξ satisfies  it,  andthus Lemma 3 holds.\nConstruction of Qξ. We construct query Qξ by induc-\ntion on the structure of ξ as follows:\n◦\n If ξ = {c}, then Qξ = {c}.\n◦\n\u0018=\u001bC(\u0018′)\n\u0019Y(\u0018′)\nQ\u0018=\u001bC(Q\u0018′)\n\u0019Y(Q\u0018′)\n If  (resp. ),  then \n(resp. ), where  Qξ' is the query constructed for ξ'.\n◦\n\u0018= fetch(\u0018′;\nR(jX!Y;Nj))\nQ\u0018=\u0019Z(Q\u0018′1X\nR(X\n;Y;Z ))\n If , then \n.\n◦\n\u0018=\u00181\u0002\u00182\nQ\u0018=Q\u00181\u0002Q\u00182\n If , then .\nQ\u0018\nφ=R(jX!Y\n;Nj)2B\nXQ\u0018\nR\u0012\nX\nY\u0012 cov(Q \u0018;B)\nBy  induction  on  the  structure  of ξ,  one  can  readily\nverify that for each relation R in ,  there exists a bag\nconstraint  such  that \n,  i.e., Qξ satisfies  the  condition  of\nLemma 3.\nφ=R(jX!Y\n;Nj)2B\nN\n>jjQjj\nQ\u0018\u0011BQ\nQ\u0018\u0011Q\nXQ\nR\u0012\u001a(XQ\u0018\nR′)\nXQ\nR\u0012\u001a(XQ\u0018\nR′)\u0012X\nY\n\u0012\u001a(cov(Q \u0018;B))\u0012 cov(Q;B)\nQuery Q satisfies the condition. We next show that Q\nsatisfies the condition in Lemma 3 when Qξ does. Since\nfor each bag constraint ,  ,\nfrom ,  one can verify that . Thus there\nexists  a  homomorphism ρ from Qξ to Q[2].  Moreover,\nsince Q is self-join free, each relation schema R (i.e., rela-\ntion atom) has at most one occurrence in Q. Then no re-\nlation  atom  in Q can  be  removed  without  changing Q.\nThus, Q is minimal (an SPC query is minimal if it has no\nredundant relation atoms[2]). Hence for each relation R in\nQ, there must exist a relation R' in Qξ such that ρ(R') =\nR,  and  moreover, .  Hence \n.  That is, Q also satisfies the\ncondition of Lemma 3.\n(\nB\n( )  Assume that Q satisfies the condition of Lemma\n3. We construct a 3-step bounded query plan ξ under \nfor Q:\n(a) it has a bounded sub-plan ξR for each relation R\nin Q that fetches all attribute values needed for answer-\ning Q;\n\u0018c\nR\n(b) it combines the attribute values for each relation\nR in Q via a bounded sub-plan  such that each (par-\ntial) tuple fetched and kept for R is guaranteed to draw\nvalues from the same tuple in D; and\n\u0018c\nR\n(c) it finally carries out operations in Q over  for\neach relation R in Q.\nTo show such a plan ξ exists for Q under the condi-\ntion of Lemma 3, we only need to prove the following two\nproperties:\n(1) all necessary attribute values for answering Q from\neach relation R in Q can be retrieved by ξR in step (a),\nand\n\u0018c\nR\n(2) their combinations can be restored by  in step\n(b).\nA2XQ\nR\nXQ\nR\nA2cov(Q;B)\nB\nXQ\nR\nA2cov(Q;B)\nProof  of  (1).  We  prove  (1)  by  constructing  such  a\nbounded plan ξR[A] for each attribute .  Note that\nonly attributes in  are needed for answering Q. The\nplan ξR[A] is  constructed  by  translating  the  proof  that\nwitnesses . More  specifically, since the con-\ndition of Lemma 3 holds for Q and ,  for any attribute A\nof  such  that , there  must  exist  a  se-Y. Cao et al. / Bounded Evaluation: Querying Big Data with Bounded Resources 507 \n \n\n\ncov(Q;B)quence  of  applications  of  rules  (a)–(c)  that  defines\n such that\nℓ:cov 0r17\u0000\n!cov 1r27\u0000!\u0001\u0001\u0001rn7\u0000!cov n\ncov 0=∅\nA2covn\ncov(Q;B)\nℓ\nwhere ,  ,  step i expands  covi-1 by\napplying rule ri from one of the rules (a)–(c) for defining\n given  earlier.  We  translate  into  a  bounded\nplan:\n\u0018:\u00180;\u0001\n\u0001\u0001;\u0018n\ncovi\u00001ri7\u0000\n!cov i\nwhere ξ0 is empty; ξi is derived from ξ0, ···, ξi-1 based on\nstep  as follows:\nXQ\nC\n(i) if ri is rule (a) for a constant c in ,  then ξi is\n{c};\nA2covi\u00001\nB̸2covi\u00001\nB2covi\n(ii) if ri is rule (b) with A = B such that ,\n and , then ξi = ξi-1;\n\u0018i= fetch(\u0018 j11\u0001\n\u0001\u0001\u0018jjXj;\nφ=R(jX!Y\n;Nj))\n\u0018j1\n\u0018jjXj\nj1;\u0001\n\u0001\u0001;jjXj<i\n(iii)  if ri is  rule  (c),  then \n,  where , ···,  are the bounded\nplans that fetch attributes in X ( ).\nBy the construction, ξi is a bounded plan that fetches\nall A attribute values for Q. Note that each sub-plan ξi is\nbounded since it does not involve relation scans.\n\u0018c\nR\n\u0018A\nA2XQ\nR\nT1=\u0018A11\u0001\n\u0001\u00011\u0018AjXj\nAi\n(i2[1;jXj])\nXAi\nAi\nXQ\nR\u0012X\nY\nφ=R(jX!Y\n;Nj)2B\n\u0018c\nR=fetch(T 1;\nφ)\n\u0018A\nA2XQ\nR\n\u0018c\nR\nB\nProof of (2). Plan  is constructed with  for each\n by  (i) ,  where ′s\n range over all attributes in X, and  is the\nplan  generated  above  for  fetching  values;  and  (ii)  if\n for , then .\nSince  is  a  bounded  plan  for  each ,  is\nbounded under .\nB\nB\nHence,  when  the  condition  of  Lemma  3  holds  for Q\nand ,  ξ constructed above is a bounded plan for Q un-\nder . □\nCP\n(II) NP cases. One might want to lift the restriction\nof condition (b) on the queries in .  This covers all SPC\nqueries,  including  those  with  self-joins.  However,  the\nbounded evaluability analysis becomes harder unless P =\nNP.\nCNP\nCNP\nB\nφ=R(jX!Y\n;Nj)\nN\n>jjQjj\nClass . Denote by  the set of pairs of bag ac-\ncess  schemas  and  SPC  queries Q such  that  for  each\nbag constraint ,  . We have the\nfollowing.\nB\nTheorem 4. For any bag access schema  and SPC\nQ,\n(B;\nQ)\nCNP\n(a) it is in PTIME to decide whether  is in ;\nand\nB\n(B;\nQ)\nCNP\n(b)  it  is  NP-complete  to  decide  whether Q is\nboundedly evaluable under  if  is in .\nB\n(B;\nQ)2CNP\nCNP\nProof. Statement (a)  is  immediate.  To  prove  state-\nment (b), we first give a sufficient and necessary condi-\ntion for query Q to be boundedly evaluable under  for\nany .  Based on the characterization, we then\nshow that checking bounded evaluability for  is NP-\ncomplete.\nLet Qm be the minimal equivalent query of Q, i.e., the\nCNPminimized version of Q, which can be obtained by remov-\ning  all  redundant  relations  (see  [2]  for  details).  For  an\nSPC query Q, there exists a unique minimal equivalent\nquery up to isomorphism[2]. Along the same lines as the\nproof of Lemma 3, one can verify the following for cases\nin .\n(B;\nQ)2CNP\nB\nφ=R(jX!Y\n;Nj)2B\nXQm\nR\u0012X\nY\u0012 cov(Q m;B)\nLemma  5. For  any ,  Q is  boundedly\nevaluable under  if and only if for each relation atom R\nin Qm,  there  exists  such  that\n.\nB\n(B;\nQ)\nCNP\nBased  on  this,  we  prove  that  deciding  whether Q is\nboundedly evaluable under  is NP-complete for  in\n.\nUpper bound. We give an NP algorithm as follows:\n(a) convert Q into its tableau representation (TQ, u)[2];\nT′\u0012TQ\n(b)  guess  a  sub-query Q' =  (T', u)  of Q such  that\n, and a mapping  ρ from TQ to T';\nφ=R(jX!Y\n;Nj)2B\nXQ′\nR\u0012X\nY\u0012 cov(Q;B)\n(c) check (i) whether ρ is a homomorphism from (TQ,\nu) to (T', u) and (ii) whether for each relation atom R in\nQ',  there  exists  such  that\n; return “Yes” if so.\n(TQm;\nu)\nTQm\u0012T′\nQ\u0012TQ\nB\njB\nj\njQ′j\n\u0014jQj\njB\nj\nB\nThe algorithm is correct since if conditions (i) and (ii)\nof step (c) hold on Q', they must also hold on the minim-\nal equivalent query Qm of Q. Indeed, ρ also determines a\nhomomorphism  from  (TQ, u)  to  since Qm is  a\nminimal  equivalent  query  of Q,  i.e., ;\ntherefore,  if  condition  (ii)  holds  on Q', by  the  homo-\nmorphism ρ it must also hold on Qm, i.e., the condition of\nLemma 5 applies to Q and .  Thus, by Lemma 5, Q is\nboundedly evaluable. The algorithm is in NP since step\n(a) is in PTIME, and step (c) is in PTIME in |Q'|, |Q|, |ρ|,\nand  while  and ρ = O(|Q|). Here |Q| is the\nsize  of Q,  i.e., the  number  of  attributes  and  aggregate\nfields in Q;  is the total length of bag constraints in .\nLower bound. To show that the problem is NP-hard,\nwe consider the following problem, denoted by MINCQ.\n◦\n Input: A relation schema R and an SPC query Q\nover R.\n◦\n Question: Is Q minimized, i.e., is Q a minimal equi-\nvalent query of Q?\nIt is easy to verify that MINCQ is coNP-complete by\nreduction from 3-COLORABILITY, which is NP-complete[23].\nLemma 6. Problem MINCQ is NP-complete.\nCNP\nWe  show  that  the  bounded  evaluability  problem  for\n is  NP-hard  by  reduction  from  the  complement  of\nMINCQ.\nR(A1;\u0001\n\u0001\u0001;Am)\nSPC\nR′\nR′\nB\nB\nGiven an instance of MINCQ, i.e., a relation schema\n and  an  query Q over R, we  con-\nstruct a database schema ,  an SPC query Q' over \nand a bag access schema .  We show that Q is not min-\nimal if and only if Q' is boundedly evaluable under .\nR′\nR′(A1;\u0001\n\u0001\u0001;Am;B1;\u0001\u0001\u0001;Bn(n\u00001)\n2)\n(1)  Database  schema  consists  of  a  single  relation\nschema ,  where n is the\nnumber of relation atoms that appear in query Q.\nIntuitively, R' extends R with  additional  attributes 508 International Journal of Automation and Computing 17(4), August 2020\n \n\n\nB1\nBn(n\u00001)\n2, ··· , . As will be shown later, together with Q',\nsuch  new  attributes  will  be  used  as  join  attributes  to\npairwisely connect the n relation atoms of Q in Q'.\n(2) Query Q' is derived from Q as follows:\n◦\nR2\nR\nR′2\nR′\n query Q' retains the same number of joins and rela-\ntion atoms as Q, such that each relation atom Ri (i.e., re-\nnaming  of  relation  schema )  is  replaced  with Ri'\n(i.e., renaming of relation schema ); and\n◦\nQ′\ni\n<j\nR′\ni[Bp]\n=R′\nj[Bp]\np=n(i\u00001)\u0000i(i\u00001)\n2+\n(j\u0000i)\n the  selection  (join)  condition C of  query  con-\ntains  all  selection  predicates  of Q,  and  in  addition,  the\nfollowing predicates: for each pair of relations Ri and Rj\nin Q ( ),  add equality  to C, where\n.\nBi(i2[1;n(n\u00001)\nn])\nIntuitively, C preserves  all  selection  conditions  of Q\nand additionally joins each pair of the n relation atoms\non a dedicated attribute :  (a) for each\nBk,  there  exist  exactly  two  relation  atoms Ri' and Rj'\nsuch that Ri'[Bk] = R'j[Bk]; and (b) for each Ri' and Rj',\nthere exists exactly one attribute Bk such that Ri'[Bk] =\nR'j[Bk].\nB\nn(n\u00001)\n2\u00001\nB\n(3) The bag access schema  consists of \nconstraints. Let W be the set of all attributes of A1, ··· ,\nAm such that  they  appear  in  the  selection/join  condi-\ntions or the top-level projection attributes in Q. Then \nconsists of\n◦\nφ1=R′(j∅\n!WB 2B3\u0001\u0001\u0001Bn(n\u00001)\n2;\nNj)\n ,\n◦\nφ2=R′(j∅\n!WB 1B3\u0001\u0001\u0001Bn(n\u00001)\n2;\nNj)\n ,\n...\n◦\nφn(n\u00001)\n2=R′(j∅\n!WB 1B2\u0001\u0001\u0001Bn(n\u00001)\n2\u00001;\nNj)\n .\nB\nWe next show that query Q is not minimal if and only\nif Q is boundedly evaluable under .\n())\nn\nn(n\u00001)\n2\nB1\nBn(n\u00001)\n2\nφ=R′(X!Y\n;N;m )\nB\njWj+n(n\u00001)\n2\nφi2\nB\njWj+n(n\u00001)\n2\u00001\n Assume that Q is not minimal. Then none of the\n relation atoms in Q' can be removed by minimizing Q'.\nHence  all  attributes , ···, ,  together\nwith W,  have  to  be  contained  in XY for  some\n in  by  Lemma  5.  This  yields\n attributes. This is impossible since for any\n,  φi contains  attributes only by\nits definition above.\n(()\nB\nφi2\nB\njWj+n(n\u00001)\n2\u00001\nXQ′\nm\nR′\ni\njWj+n(n\u00001)\n2\u00001\nXQ′\nR′\ni\njWj+n(n\u00001)\n2\n Assume that Q' is boundedly evaluable under .\nSince each  contains  attributes,\nby  Lemma  5,  must  contain  at  most\n attributes for each relation atom R'i\nin Q', where Q'm is the minimal equivalent query of Q'.\nSince  contains  attributes, query Q' is\nnot minimal. □\nCNP\nRemark  2. Despite  its  intractability,  checking  the\nbounded  evaluability  for  is  feasible  in  practice  by\nLemma 5. Indeed, there have been effective algorithms for\nminimizing SPC queries, i.e., computing Qm for Q[2], and\nQm\nB\njB\njthe size of Q is typically small. Taking one of these al-\ngorithms as an oracle for computing Qm, one can still effi-\nciently  check  the  bounded  evaluability  of  generic  SPC\nqueries:  first  minimize Q,  yielding ,  and  then  check\nwhether Qm and  satisfy the condition of Lemma 5 in\nPTIME in |Qm| and .\n4   Effective syntax\nIn  this  section,  we  propose  an  effective  method  to\ncheck the bounded evaluability of generic RAaggr queries.\nWe show that while the problem is undecidable (Theor-\nem 1), there exists an effective syntax for boundedly eval-\nuable RAaggr queries, which reduces the problem to syn-\ntactic checking (Section 4.1). In addition, we identify two\npractical subclasses of RAaggr queries and provide their ef-\nfective  syntax.  In  particular,  we  give  one  for  RA  and\nshow that it covers more bounded queries than the one\ngiven in [6] (Section 4.2).\n4.1   An effective syntax for RAaggr\nB\nL\nL\nLL\nB\nL\nL\nUnder  an  access  schema ,  an  effective  syntax  for\nboundedly evaluable queries of  (  refers to, e.g., RA or\nRAaggr) is a subclass  of  such that for any Q in ,\nQ′\nLL\nB\nQ\u0011BQ′\n(a)  if Q is  boundedly  evaluable,  then  there  exists  a\nquery  in  such that ;\nLL\nB\n(b) every query Q in  is boundedly evaluable; and\njQj\njB\nj\nB\nQ2\nLL\nB\n(c) it is in PTIME in the size  of query Q and the\nlength  of constraints in  to check whether .\nQ\u0011BQ′\nQ(D )\n=Q′(D)\nD\nj=B\nHere  if  for  all  databases\n.\nL\nLL\nB\nL\nLL\nB\nB\nLL\nB\nLL\nB\nL\nIntuitively, the effective syntax reduces the problem of\ndeciding the bounded evaluability of  queries to syntact-\nic  checking  of .  Indeed,  every  boundedly  evaluable \nquery can find an equivalent query in  under . Hence,\nwe can safely settle with queries in ,  since  can ex-\npress, up to equivalence, all boundedly evaluable  quer-\nies.\nLL\nB\nRemark 3. To some extent, the development of ef-\nfective syntax  is analogous to the study of range-safe\nqueries  for  relational  calculus.  Indeed,  the  problem  for\nchecking the “safety” of relational calculus queries is also\nundecidable[2]. Despite this, range-safe queries are suppor-\nted by commercial DBMS, by making use of an effective\nsyntax of  range-safe  relational  calculus  queries.  We  fol-\nlow the same approach to dealing with the bounded eval-\nuability of RAaggr queries.\nLB\nB\nBelow we develop such an effective syntax, denoted by\n,  for RAaggr queries that are boundedly evaluable un-\nder .\nLB\nLB\nBA(Q;B)\nBR(Q;B)\nBQ(Q;B)\nB\nThe class .  In  a  nutshell,  we  characterize  with\nthree sets: ,   and . Informally,\nunder a bag access schema , for an RA aggr query Q,\n◦BA(Q;B)\nA\nsum(A)\n contains  attributes  (e.g., ) and  aggreg-\nates (e.g., )  of Q whose values can be fetched viaY. Cao et al. / Bounded Evaluation: Querying Big Data with Bounded Resources 509 \n \n\n\nB;\n◦BR(Q;B)\nBA(Q;B)\n consists  of  relations  in Q whose  partial\ntuples that are needed to answer Q can be reconstructed\nfrom the fetched values for attributes in ; and\n◦BQ(Q;B )\n contains boundedly evaluable sub-queries of\nQ.\nLB\nQ2BQ(Q;B)\nAn RAaggr query Q is included in  if .\nB\nIntuitively,  these  sets  characterize  RAaggr queries Q\nfor which  the  values  of  all  attributes  necessary  for  an-\nswering Q can  be  “deduced”  from  constants  in Q,  via\njoins  and  fetch  under  access  schema .  Such  attributes\nparticipate in RAaggr operations of Q, and are referred as\nthe  nontrivial  attributes  of  query Q.  The  class  of  such\nqueries makes  an  effective  syntax  for  boundedly  evalu-\nable RAaggr queries.\nMore specifically, sets BA, BR and BQ are defined in\nXc\nQ\nBA(Q;B)\nBR(Q;B)a mutual recursive way using rules given in Fig. 1, with\nnotations explained in Table 1. Intuitively, (1) rule γ1 of\nFig. 1 includes  constant  attributes  (see Table  1)  in\n;  (2) γ2 propagates value from attributes and ag-\ngregate  fields  to  join  attributes;  (3) γ3 specifies  value\npropagation via fetch; (4) γ4 says that if a sub-query is\nboundedly evaluable, then its output attributes and ag-\ngregate fields can also be fetched; (5) γ5 adds a relation\natom R to  only when the partial tuples of R\ncan  be  reconstructed  from  combinations  of  the  fetched\nvalues;  and  (6) γ6 says  that  a  sub-query  is  boundedly\nevaluable if all its relations can be correctly fetched.\n\u0006Q\n\u0006Q⊢A=B\nA=B\n\u0006Q\nAs shown in Table 1,  denotes the set of equality\npredicates embedded in the selection or join conditions of\nQ, and  denotes that equality  can be\ndeduced from  by the transitivity of the equality rela-\ntion.\nB1\nQ22\nLB1\nExample  7. Recall  query Q2 from  Example  2  and\nbag  access  schema  from  Example  4.  We  show  that\n.\nBA(Q 2;B1)\n(1) Initially, by rule γ1,  includes f.uid and\nc.cty,  where  f  (resp.  c)  are  shorthands  for  friend  (resp.\ncheckin).\nBA(Q 2;B1)\n(2)  By  rule γ3 and φ1,  further  includes\nf.fid.\n\u0006Q⊢f:fid= c:uid\nf:fid2BA(Q 2;B1)\nBA(Q 2;B1)\n(3) Since ,  by , we\nhave that  includes c.uid by rule γ2.\nf2BR(Q 2;B1)\nBA(Q 2;B1)\nc2BR(Q 2;B1)\nBA(Q 2;B1)\n(4) By γ5,  because both f.uid and f.fid\nare  in  and  are  attributes  of φ1.  Similarly,\n because  of φ2.  Note  that  only  c.uid  and\nc.cty are nontrivial attributes of Q in relation c and they\nare both in .\nBQ(Q;B)\n(5)  By γ6,  sub-query Q3 and  query Q2 itself  are  in\n.\nB2\nQ62\nLB2\nAs another example, recall query Q6 from Example 5\nand  from Example 4. We next show that .\nBA(Q 6;B2)\nBR(Q 6;B2)\n\r5\n(1) One can readily deduce that  includes\nB and C by  using γ1 and γ3,  and  that  in-\ncludes R with .\nBQ(Q 6;B2)\n(2) By γ6,  includes sub-query Q7 of Q6.\nZQ72BA(Q 6;B2)\nZQ7\n(3)  Hence,  further  by γ4 we  have  that\n,  where  is the output of Q7, i.e., an\naggregate field.\nBA(Q 6;B2)\nF\n\u001bQ6⊢ZQ7=F\nF\n(4) By γ2, we know that  includes  since\n and  is not an aggregate field.\nS2BR(Q 6;B2)\nQ62BQ(Q 6;B2)\n(5)  Thus,  by γ5 and γ6,  and\n.\nQ4̸2\nLB2\nQ4\u0011B2Q6\nQ62\nLB2\nB2\nQ1\n9\nB3\nQ8̸2\nLB3\nQ1\n92\nLB3\nQ1\n9\nB3\nNote  that .  However, , \nand Q6 is  boundedly  evaluable  under .  Similarly,  for\nQ8,  and  of  Example  6,  one  can  verify  that\n but  and  is  boundedly  evaluable\nunder . \nTable 1    Notations and definitions\nNotation Definition\nA (or\nR[A])An attribute  or an aggregate  field  in  Q\nX,  Y Sets of attributes  in  Q\n|Q| Number  of attributes  and aggregate  fields  in  Q\n|| Q|| Number  of relation  atoms in  Q\nXQ\nSet of all attributes  and aggregate  fields  in  Q\nXc\nQ\n\u001bA=c\nSet of attributes   A of  Q in constant  selections \n\u0006Q\n3 Set of equality  predicates  in selections/joins  of  Q\n\u0006Q⊢A=B\nA=B\n\u0006Q\n can be deduced  from    via equality  transitivity\nZQ\nSet of attributes  and aggregate  fields of the output of  Q\nnontr.\nattr.Attributes  participated  in algebra  operations  of  Q\nA\nB\n/ Access schema/bag  access schema\njB\nj\nB\nTotal length of bag constraints  in \nj\njBjj\nB\nThe number  of bag constraints  in \nϕ\nφ\n/ Access constraint/bag  access constraint\nLB\nRA aggr\nB\nEffective  syntax  for    queries\nbounded.  eval. under \nLL\nB\nL\nB\nEffective  syntax  for  -queries  bounded . eval . under \n  \nquerynontrivial attributesi. e.,e.g.,\n \nLB\nRA aggr\nFig. 1     Effective syntax    for   queries\n \n_\n[\n3To  reduce  notations,  we  assume w.l.o.g. that  selection\nconditions  are  conjunctive,  i.e.,  in  selection  predicates  is\nreduced using . 510 International Journal of Automation and Computing 17(4), August 2020\n \n\n\nLB\nBWe next show that  is indeed an effective syntax\nfor boundedly evaluable RAaggr queries under .\nB\nLB\nTheorem 7. Under any bag access schema ,   is\nan effective syntax for boundedly evaluable RAaggr quer-\nies.\nLB\nProof. We show below that  has properties (a) and\n(b) of an effective syntax, by proving the following lem-\nmas. We will constructively prove property (c) in Section\n5.2.\nB\nQ\u0011B\u0018\nLB\n(I) For any bounded plan ξ under ,  there is \nin .\nQ2\nLB\n\u0018\u0011BQ\nB\n(II)  For  any ,  there  is  plan  bounded\nunder .\nB\nB\nQ′\u0011B\u0018Q\nLB\nQ\u0011BQ′2\nLB\n\u0018′\u0011BQ′\u0011BQ\nB\nLB\nThese suffice. Indeed, for any Q that is bounded un-\nder ,  by definition there must exist a plan ξQ bounded\nunder ;  hence by (I), there exists  in . On\nthe  other  hand,  if ,  by  (II), Q' has  a\nbounded  plan ,  i.e., Q is  also  boundedly\nevaluable under .  Hence,  has properties (a) and (b)\nof an effective syntax.\nWe next prove the two lemmas.\n\u0018\nProof of (I) . We  prove  it  by  induction  on  the  struc-\nture of .\n\u0018\nfcg\n∅\n\u0018\nLB\nBase case . When  is  or , by definition  itself is\nin .\n\u0018\nInduction . We consider the structure of .\n\u0018\ngpBy(\u0018′;\nX; agg(V ))\nQ′\u0011B\u0018′\nQ′2\nLB\nQ= gpBy(Q′;\nX; agg(V ))\nLB\nQ′\nBR(Q′;B)\u0012 BR(Q;B)\nQ′\nQ2BQ(Q;B)\n\r6\nQ2\nLB\nQ\u0011B\u0018\n(i)  is . By  the  induction  hypo-\nthesis, there exists a query  such that .\nConsider .  By  the  definition  of\n,  all relations in  are in  (since\nQ and  share  the  same  nontrivial  attributes).  Hence\n by  rule .  That  is, .  Obviously,\n.\n\u0018=\u0019Y(\u0018′)\n\u001bC(\u0018′)\n\u00181\u0002\u00182\n\u00181[\u00182\n\u00181\u0000\u00182\nThe  cases  for ,  , , ,\n are  similar  and  can  be  verified  along  the  same\nlines.\n\u0018\nfetch(\u0018′;\nφ)\nφ=R(jX!Y\n;Nj)\nQ′\u0011B\u0018′\nQ′2\nLB\nQ=\u0019R[X\nY](Q′1ZQ′=R[X]R)\nfetch\nQ\u0011B\u0018\nQ2\nLB\nQ′2\nLB\nQ′2BQ(Q′;B)\n\r4\nQ′[X]\u0012 BA(Q′;B)\u0012 BA(Q;B)\n\r2\nR[X]\u0012 BA(Q;B)\n\r3\nR[Y]\u0012 BA(Q;B)\n\r5\n\r6\nQ2BQ(Q;B)\n\u00182\nLB\n(ii)  is  with .  By  the\ninduction  hypothesis,  there  exists  query  such\nthat .  Consider . By\nthe  semantics  of ,  .  We  next  show  that\n.  Since , .  Hence  by  rule\n,  .  Further  by ,\n.  By , . Hence by \nand ,  . That is, .\nQ2\nLB\nLB\nℓQ\nQ2BQ(Q;B)\nProof of (II) .  Since ,  by  the  definition  of \nthere must exist a proof  consisting of applications of\nrules  in Fig. 1 that  deduces ,  i.e., a se-\nquence of the form\n(BA 0;BR0;BQ0)r17\u0000\n!\u0001\u0001\u0001rn7\u0000!(BA n;BRn;BQn)\nri(i2[1;\nn])\nBA0= BR0= BQ0=∅\ni\nBAi\nBRi\nBQi\nBAi+1\nBRi+1\nBQi+1\nrn\n\r6\nwhere  (a)  is  one  of  the  rules  in Fig. 1;  (b)\n;  (c)  for  each  step ,  only  one  of\n,   and  is  changed  in ,  and\n,  respectively;  and  (d)  is  rule  that  deduces\nQ2BQ(Q;B)\nℓQ\nn\nℓQ.  We define the length of  as the number\n of rules applied in .\nℓ\ni\nInduction hypothesis . We show that for a proof  of\nlength ,\n◦\nA2BAi+1\nA̸2BAi\nA\nB\n if  but , values for  that are ne-\ncessary for answering Q can be fetched via bounded plan\nunder ;\n◦\nR2BRi+1\nR̸2BRi\nB\n if  but , then values from R ne-\ncessary for Q can be fetched via bounded plans under ;\nand\n◦\nq2BRi+1\nq̸2BQi\nB\n if  but , then the exact answers to\nsub-query Q of Q can be answered via bounded plans un-\nder .\nQ2\nLB\nℓQ\nQ2BQ(Q;B)\nB\nNote  that  for  any ,  Q must  have  a  proof \nending by including . If  the induction hypo-\nthesis  holds, Q must  have  a  bounded  plan  under ,\nwhich proves lemma (II).\nl(ℓ)\nℓ\nWe next prove it by induction on the length  of .\nl(ℓ)\n= 1\nA2BA1\nφ=R(j∅\n!Y;Nj)2B\n\u0018R[Y]= fetch(∅;\nφ)\nBase  case.  When ,  then  rule r1 can  only  be\neither (i) γ1 of Fig. 1, i.e., to include  from selec-\ntion A = c of Q; or (ii) γ3 of Fig. 1, i.e., to include R[Y] in\nBA1 with .  For (i), simply let ξA =\n{c}. Then ξA is a bounded plan that fetches all necessary\nvalues for A. For (ii), let .  Then by the\nsemantics of fetch, all values for R[Y] that are necessary\nfor answering Q are fetched by ξR[Y] (here we rename Q\nbeforehand such that there exist no duplicated attribute\nnames).\nℓ\n(BAi;BRi;BQi)ri+17\u0000\n!\n(BA i+1;BRi+1;BQi+1)\nℓ\nInduction .  Assume  that  the  hypothesis  holds  for\nproofs  of  length  at  most k.  Consider  proof  of  length\nk+1.  We  discuss  the  last  step \n of .\n(i) If rk+1 is rule γ1 with attribute A = c, then A can\nbe fetched in exactly the same way as the base case.\n(ii) If rk+1 is rule γ2 that includes attribute B in BAi+1\nwith A = B, then attribute A must be included in BAi+1\nat some steps prior to k+1. By the induction hypothesis,\nthere must exist a bounded plan ξA that fetches all neces-\nsary values for answering Q except B. Hence ξB =ξA is\nalso a bounded plan that fetches B for Q by the condi-\ntion A = B.\nR[X]\u0012 BA(Q;B)\nφ=R(jX!Y\n;Nj)\ni1;\u0001\n\u0001\u0001;ip\nR[Xip]\nR[X1][\n\u0001\u0001\u0001[R[Xp] =\nR[X]\nR[Xj](j2[1;\np])\n\u0018R[Xj]\n\u0018R[X]\n1p\nj=1\u0018R[Xj]\n(iii) If rk+1 is rule γ3 that includes R[Y] in BAi+1 with\n and constraint , then\nthere  exist  steps  prior  to k+1  that  include\nR[X1], ··· ,  in BA such that \n.  Hence by the induction hypothesis, \nhas  bounded  plan .  Let  be ,  then\nξR[X] fetches all values for R[X] that are necessary for an-\nswering Q. Hence, further by the semantics of fetch, R[Y]\nhas  a  plan  fetch(ξR[X], φ)  that  retrieves  all R[Y]-values\nneeded for answering Q.\nZQs\nj\n<i+ 1\n\u0018Qs\nB\n(iv)  If rk+1 is γ4 that  includes  in  BAi+1 from  a\nsubquery Qs of Q that  is  included  in  BQj at  step\n,  then by the induction hypothesis, there exists a\nplan  for Qs under  that exactly answers Qs. HenceY. Cao et al. / Bounded Evaluation: Querying Big Data with Bounded Resources 511 \n \n\n\nZQs\n\u0018Qs\n\u0018Qs\nZQswe can get values for its output attributes  simply by\n.  Note that since  is an exact plan for Qs, the val-\nues for  are guaranteed correct even when Qs is an ag-\ngregate subquery.\nφ=R(jX!Y\n;Nj)2B\n\u0018R[X1]\n\u0018R[Xp]\nR[X1][\n\u0001\u0001\u0001[R[Xp] =R[X]\n\u0018R[X]=1p\nj=1\u0018R[Xj]\nR[X]\n\u0018R[X\nY]= fetch(\u0018 R[X];φ)\n(v) If rk+1 is γ5 that includes R in BRi+1 with R[X]\nand , then  by the induction hypo-\nthesis, there exist plans , ···,  to fetch all ne-\ncessary values for R[X1], ··· , R[Xp] for Q, respectively,\nsuch that .  Hence R[X] has a\nbounded  plan  that fetches  all  neces-\nsary -values  for Q. Since R[XY] covers all nontrivial\nattributes of R for Q, by ,  we can\nfetch  all  combinations  of R[XY]-values  that  are  needed\nfor answering Q.\n\u0018R1\n\u0018Rp\n\u0018Qs\nRi(i2[1;\np])\n\u0018Ri\n\u0018Qs\n\u0018Ri(i2[1;\np])\n(vi) If rk+1 is γ6 that includes Qs in BQi+1, then all re-\nlations R1, ··· , Rp of Qs have been included in {BR in\nprior steps. Hence by the induction hypothesis, there ex-\nist , ···,  that fetch all values from R1, ··· , Rp, re-\nspectively, which are necessary for Q. Now construct plan\n by  replacing  each  relation  in Qs with\n.  Then  must be a query plan for Qs of Q since all\nnecessary value combinations can be retrieved from D via\n,  and Qs then filters and combines values ex-\nactly the same as on D.\nHence the hypothesis holds for proofs of length k+1. □\n4.2   Special cases\nRA0\naggr\nRA0\naggr\nThese are two important sub-classes of RAaggr: (1) RA\nconsists  of  RAaggr queries  without  aggregation;  and  (2)\n is the class of RAaggr queries in which group-by\naggregation, if it exists, only appears at the top-level (fi-\nnal operation). It is common to find RA and  in\npractice.\nRA0\naggr\nLB[RA]\nLB[RA0\nagg]\nRA\nRA0\naggr\nLB\nRA0\naggr\nWe  provide  effective  syntax  for  boundedly  evaluable\nRA  and  queries.  Denote  by  and\n the class of  and the class of  quer-\nies that are in , respectively.  They yield effective syn-\ntax for RA and .\nB\nLB[RA]\nRA\nB\nLB[R\nA0\nagg]\nRA0\naggr\nB\nCorollary 8. For any access schema ,  (1)  is\nan  effective  syntax  for  queries  bounded  by ;  (2)\n is  an  effective  syntax  for  queries\nbounded by .\nLB\nLB\nB\nLB[RA]\nLB[RA0\naggr]\nRA0\naggr\nRA0\naggr\nQ2\nQ′\n12\nLB[RA]\nQ′\n22\nLB[RA0\naggr]\nQ1\u0011BQ′\n1\nQ2\u0011BQ′\n2\nRA0\naggr\nLB[RA]\nLB[RA0\naggr]\nProof. Since it is in PTIME to check whether a query\nis in  and every query in  has a bounded plan under\n,  to show that  and  are effective syn-\ntax for boundedly evaluable RA and  queries, re-\nspectively,  it  suffices  to  show  that  for  any  boundedly\nevaluable RA Q1 and  ,  there exist \nand  such that  and .\nThis  is  verified  along  the  same  lines  as  the  proof  of\nLemma (I) for Theorem 7 above, by showing that every\nbounded RA (resp. )  plan has an equivalent query\nin  (resp. ). □\nRA0\naggr\nThere are close connections between  and RA\nRA0\naggr\nL\nRA0\naggr\nQ= gpBy(Q′;\nX; agg(V ))\nL0\nL\nL[RA]\nLregarding their effective syntax: any effective syntax for\nboundedly evaluable  queries also gives us an ef-\nfective  syntax  for  boundedly  evaluable  RA  queries,  and\nvice  versa.  For  any  class  of  queries\n,  denote  by  (a)  the  class  of\nRA queries Q' that are sub-queries embedded in RAaggr\nqueries Q in ;  and (b)  the class of RA queries in\n. Then we have the following.\nB\nLemma 9. Under any bag access schema ,\nL\n(1) RA is an effective syntax for boundedly evaluable\nRA  if  is  an  effective  syntax  for  boundedly  evaluable\nRAaggr;\nL\nL0\n(2)  is  an  effective  syntax  for  boundedly  evaluable\nRAaggr if  is an  effective  syntax  for  boundedly  evalu-\nable RA.\nQ= gpBy(Q′;\nX; agg(V ))\nB\nProof. Lemma 9(1) can be verified by the definition\nof  effective  syntax.  We  focus  on  Lemma  9(2)  here  (the\nproof  for  Lemma  9(1)  is  simpler).  By  the  definition  of\nboundedly evaluable queries, it is easy to show the follow-\ning lemma: for any RAaggr , un-\nder ,  Q is boundedly evaluable iff Q' is boundedly eval-\nuable.\nL0\nB\nL\nL0\nL\nL0\nQ= gpBy(Q 1;\nX; agg(V ))\nQ1\nB\nQ′\n12\nL0\nQ1\u0011BQ′\n1\nQ′= gpBy(Q′\n1;\nX; agg(V ))\u0011BQ\nQ′2\nL\nQ′\n12\nL0\nL\nQ′\nL0\nWe next use the lemma to prove Lemma 9(2). When\n is  an  effective  syntax  for  boundedly  evaluable  RA\nqueries under ,  consider the associated class  of . (1)\nFirst  observe  that  all  queries  in  are  also  boundedly\nevaluable since RA queries in  are. (2) For any RAaggr\nquery  that is boundedly evalu-\nable,  by  the  lemma  above,  is also  boundedly  evalu-\nable  under .  Hence,  there  exists  such  that\n.  Hence  and\n (since ). (3) Moreover, it is in PTIME to\ncheck whether a query Q is in  by checking whether its\nembedded RA query  is in , in PTIME. From (1),\n(2) and (3) above, Lemma 9(2) follows. □\nBy Lemma 9, one can easily extend an effective syn-\ntax for boundedly evaluable RA queries, e.g., covered RA\nin[6], to an effective syntax for boundedly evaluable RAag-\ngr queries.\nOne might think that such an extension is also pos-\nsible for RAaggr. However, when group-by aggregation is\nnested with other RAaggr operators, a convenient exten-\nsion  is  beyond  reach.  It  is  much  harder  for  RAaggr to\ncharacterize  propagation  of  values  from  aggregate  sub-\nqueries to other relations, or to cover all boundedly evalu-\nable queries up to equivalence.\nLB[RA]\nNonetheless,  is more expressive than the class\nof covered RA of [6], which is also an effective syntax for\nRA.\nB\nB\nLB[RA]\nProposition 10. For any bag access schema ,  the\nset of RA queries covered by  is properly contained in\n.\nLB[RA]\nLB\nProof. One can verify that covered RA queries[6] can\nbe expressed in  without rule γ4. Hence it is a sub-\nclass  of .  To  see  it  is  a  proper  subclass,  consider  an 512 International Journal of Automation and Computing 17(4), August 2020\n \n\n\nLB[RA]\nQ=\u0019D((\u001bA=1R1\u0000\u001bB=1R2)1A=CS)\nR1\nR2\nB\nR(jA!B\n;N1j)\nR(jB!A;\nN2j)\nS(jC!D\n;N3j)\nB\nQ2\nLB[RA] query Q over  relations R(A, B)  and S(C, D):\n,  where  and \nrename R.  Consider  consisting  of ,\n and .  One  can  verify  that\nQ is not covered by  since subquery S is not covered\n(see [6]). However, . □\n5   BEAS for querying big data\nIn this section, we show how to extend DBMS with\nthe functionality of bounded evaluation. We first present\nsuch a  framework  (Section  5.1).  We  then  provide  al-\ngorithms  underlying  the  framework,  for  checking  the\nbounded  evaluability  (Section  5.2)  and  generating\nbounded plans (Section 5.3).\n5.1   A Framework of bounded evaluation\nR\nThe  framework,  referred  to  as  BEAS,  is  shown  in\nFig. 2. Given an application that involves queries over in-\nstances of a database schema , BEAS works as follows.\n \n \nBoundedly\nevaluable?\n(C2)Generate bounded\nquery plan (C3)\nGenerate partially\nbounded plan (C5)\nDBMS\n(C4)\ndiscover, build, maintain\naccess schema (C1)Yes\nNo\n(Online)\n(Offline)Q\nQ(D)ξ′ξ\n \nBEAS\nDBMS\nFig. 2      :  Bounded evaluation on \n \nB\nR\nB\nD\nR\nB\nD\nOffline preprocessing . As shown in C1 of Fig. 2, as off-\nline preprocessing, BEAS discovers a bag access schema\n from (sample) instances of , builds indices of  on\nthe database  of  in use, and maintains  in response\nto updates to .\nD\nB\nB\nDQ\nB\nOnline processing .  When  a  user  poses  an  RAaggr>\nquery Q on ,  BEAS  first  checks  whether Q is\nboundedly evaluable under  (>C2). If so, it generates a\nbounded query plan ξ for Q under  (C3), which is inter-\npreted as an SQL query Qξ and hence can be directly ex-\necuted  by  the  underlying  DBMS  on  a  bounded  dataset\n identified by plan ξ (C4). If Q is not boundedly eval-\nuable, it generates a query plan ξ' for Q that is partially\nbounded, to make maximal use of access constraints in \n(C5).  The  (partially)  bounded  plans  are  optimized  and\nexecuted by DBMS (C4).\nNote  that  the  BEAS  framework  does  not  need  tochange  the  underlying  DBMS.  Indeed,  it  interacts  with\nthe DBMS via SQL only. Hence, BEAS can be built on\ntop of  any  existing  DBMS,  providing  a  bounded  evalu-\nation capacity.\nBEAS can also compute approximate answers to un-\nbounded  queries  under  constrained  resources,  and  offers\ndeterministic accuracy guarantees under access schema[17].\nWe focus on computing exact answers in this paper.\nBelow we develop algorithms for components C2 and\nC3 of BEAS in Section 5.2 and Section 5.3, respectively.\n5.2   Checking bounded evaluability\nB\nWe next develop a practical algorithm for component\nC2  of  BEAS.  Under  a  bag  access  schema ,  given  an\nRAaggr query Q, it decides whether Q is boundedly evalu-\nable.\nB\nCP\nCNP\nLB\nTo do this, we first checks whether Q and  fall into\nthe  two  classes  of  special  cases,  i.e.,  or ,  in\nPTIME. If so, their bounded evaluability can be decided\nefficiently as shown in the proofs of Theorems 2 and 4.\nOtherwise, we check whether Q is in the effective syntax\n for  RAaggr (Section 4).  Below  we  give  a  PTIME  al-\ngorithm for this.\nBA(Q;B)\nBR(Q;B)\nBQ(Q;B)\n∅\nBA(Q;B)\nBR(Q;B)\nBQ(Q;B)\nAlgorithm  BEChk. The  algorithm,  denoted  by\nBEChk, is shown in Algorithm 1. It first sets ,\n and  to . It then iteratively updates\n,   and  using  the  rules  in\nFig. 1. In each iteration, it\nBA(Q;B)\n(a) first computes  using γ1, γ2 and γ3 (line\n3);\nBR(Q;B)\n(b) then updates  using γ4 (line 4); and\nBQ(Q;B)\n(c) it finally updates  using γ5 (line 5).\nBQ(Q;B)\nQ2BQ(Q;B)\nThe iteration continues until  can no longer\nbe updated (line 6). It returns “Yes” if  and\n“No”  otherwise  (lines  7–8).  In  each  iteration,  steps  (b)\nand (c) are straightforward. Below we discuss step (a) in\nmore details.\nAlgorithm 1. BEChk\nR\nB\nR\nInput: Relational  schema ,  RAaggr Q and bag  ac-\ncess schema  over .\nB\nOutput: “Yes”  (“No”)  if Q is  (is  not)  boundedly\nevaluable under .\nBA(Q;B) \n∅\nBR(Q;B) \n∅\nBQ(Q;B) \n∅\n1 ;  ; ; flag\n ← true;\n2 while flag = true do\nBA(Q;B)\n3　　compute  using γ1, γ2, γ3 // recall γi in\n Table 1\nBR(Q;B)\n4　　compute  using γ5;\nBQ(Q;B)\n5　　compute  using γ6;\nBQ(Q;B)\n6　　if  is not changed then flag ← false;\nQ2BQ(Q;B)\n7　　if  then return “Yes”;\n8 else return “No”;\nBA(Q;B)\nComputing  (line 3 of Algorithm 1). In eachY. Cao et al. / Bounded Evaluation: Querying Big Data with Bounded Resources 513 \n \n\n\nBA(Q;B)iteration,  is updated in two steps, as follows.\nBQ(Q;B)\n\u0006Q⊢R[A]\n=\nS[B]\nZQs\nQs2BQ(Q;B)\nB\n(1) Building universal relation. We first build a “uni-\nversal schema” UQ of Q w.r.t. , by  mapping at-\ntributes and aggregate fields of Q to attributes of UQ, via\na mapping function ρ. For any two attributes R[A] and\nS[B] of Q, ρ(R[A]) = ρ(S[B]) if and only if \n is in the selection condition of Q. For aggregate field\nagg(A) and attribute R[B], agg(A)) = ρ(R[B]) only when\nagg(A) is in  (recall Table 1) for some .\nAccordingly, bag constraints in  are also mapped on to\nUQ by ρ.\nBA(Q;B)\nB\nWB\n(2) Computing fetch closure. We then reduce the com-\nputation  of  to the  computation  of  fetch  clos-\nures over UQ with  w.r.t. ρ. For a set W of attributes of\nUQ, its fetch closure, denoted by , is  a set of attrib-\nutes of UQ such that\nW\u0012WB\n(i) ;\nX′\u0012WB\nφ=R(jX!Y\n;Nj)2B\n\u001a(R[X])\n=X′\n\u001a(R[Y])\n=Y′\nY′\u0012WB\n(ii) if  and  such that\n and , then ; and\nWB\n(iii)  contains nothing else.\nW=\u001a(Xc\nQ)[\u001a(BA(Q;B))[∪\nQs2BQ( Q;B)\u001a(ZQs)\nBA(Q;B)\n=fA2XQj\u001a(A)2WBg\nLet .\nWe  set  (see ZQ, XQ\nin Table 1).\nB1\nB1\n∅\nExample 8. Recall Q2 from Example 2 and bag ac-\ncess schema  from Example 4. Algorithm BEChk iter-\natively updates BA, BR and BQ for Q2 and ,  which are\nall  initially.\nBA(Q 2;B1)\nUQ2=ff:uid; f:fid; c:cty; c:dateg\n\u001a(Xc\nQ2)\n=ff: uid; c:ctyg\n\u001a(BA(Q 2;B1))\n=∅\nBQ(Q 2;B1)\n=∅\n\u001a(Xc\nQ2)\nWB1\nWB1=ff:uid; f:fid; c:ctyg\nBA(Q 2;B1)\nBR(Q 2;B1)\nBA(Q 2;B1)\nBQ(Q 2;B1)\nIn  the  first  iteration,  BEChk  starts  by  updating\n (line 3). To do this, it builds a universal rela-\ntion  via  function ρ that\nmaps c.uid to f.fid and keeps all other attributes intact (f\nand  c  stand  for  friend  and  checkin,  respectively).  Since\n,   and\n,  BEChk sets W to  and computes\nthe  fetch  closure  of W,  yielding\n.  Hence it updates  to\n{f.uid, f.fid, c.cty}. It then updates  to {f, c}\nsince  all  nontrivial  attributes  of  f  and  c  are  already  in\n (line  4).  BEChk  finally  updates \nto {Q3, Q2} (line 5) and terminates in next iteration and\nreturns “Yes”.\nB2\nUQ6=fA;\nB;C;E;F;W;F′g\n\u001a\n\u001a\n\u0006Q6⊢sum(y )\n=E\nQ7̸2BQ(Q 6;B2)\n=∅\nXC\nQ6\nUQ6\nBA(Q 6;B2)\nBA(Q 6;B2)\nBR(Q 6;B2)\nfRg\nBQ(Q 6;B2)\nUQ6=fA;\nB;C;E;F;Wg\nQ72BQ(Q 6;B2)\nIt gets more involved for Q6 from Example 5 and \nfrom  Example  4.  In  the  first  iteration,  BEChk  builds  a\nuniversal schema  via a map-\nping  function  that  keeps  attributes  of R and S and\nmaps  aggregate  field  (i.e., the  output)  sum(y)  of Q7 to\nF'.  Note  that  does  not  map  sum(y)  to E although\n since  yet.\nBEChk then computes the fetch closure of  over \nand sets  to {B, C, F}. It then finds that all\nnontrivial  attributes  of R are  in  and  hence\nupdates  to .  Consequently,  it  sets\n to Q7 as well. In the second iteration, BEChk\nbuilds  an  updated  universal  relation\n since  and\n\u0006Q6⊢sum(y )\n=E\nBA(Q 6;B2)\nBR(Q 6;B2)\nBQ(Q 6;B2)\nB2.  It continues to update  to\n{B, C, E, F, W},  to {R, S} and \nto {Q7, Q6}. It terminates after the third iterations and\nreturns “Yes” for Q6 under .\nLB\nBQ(Q;B)\nBA(Q;B)\nWB\nWB\nCorrectness  &  Complexity. To  see  that  BEChk\ncorrectly checks the effective syntax  of Fig. 1, observe\nthe  following.  (1)  For  any  fixed , the  corres-\nponding  decided by rules γ1, ··· , γ4 is exactly\nthe fetch closure  (recall the definition of  above).\n(2) The while loop propagates changes from BA to BR\nand  to  BQ,  and  finally  to  BA  again,  until  reaching  a\nfixed point w.r.t. the rules of Fig. 1.\nO(pQ(j\njQjjjBj +jQj))\nj\njBjj\njB\nj\nB\nO(j\njQjjjjBjj )\nO(j\njQjjjjBjj +jQj)\nBEChk  can  be  implemented  in \ntime, where pQ is the number of sub-queries in Q, ||Q|| is\nthe number of relation atoms in Q, |Q| is the number of\nattributes and aggregate fields in the relation atoms and\npredicates  of Q,  and  are  the  number  and  total\nlength of bag constraints in ,  respectively (see Table 1).\nIndeed, computing the fetch closure can be implemented\nin -time,  and  hence  each  while  iteration  is  in\n time; there are at most pQ iterations.\nLB\nQ2\nLB\nAlgorithm  BEChk  provides  a  constructive  proof  for\nproperty (c) of the effective syntax  in Theorem 7, i.e.,\nit is in PTIME to check whether  for an RAaggr\nquery Q.\nThis also completes the proof of Theorem 7.\n5.3   Generating bounded plans\nB\nB\nB\nWe next provide an algorithm underlying component\nC3  of  BEAS,  denoted  by  BPlan.  Given  a  bag  access\nschema  and an RAaggr query Q that is determined to\nbe  boundedly  evaluable  under  by  BEChk  of  Section\n5.2, BPlan generates a bounded RAaggr query plan for Q\nunder .\nQ2\nLB\nB\nAlgorithm BPlan. Given  a  boundedly  evaluable\nRAaggr query  (see Section 4), BPlan generates a\nbounded  plan ξQ for Q under  as  follows:  (1)  fetch  a\nbounded  amount  of  data  for  each  relation R that ap-\npears  in Q,  and  (2)  carry  out  operations  of Q over\nfetched data. While step (2) is straightforward, step (1) is\nrather involved.\nB\nB\nB\nTo carry out step (1), BPlan generates bounded logic-\nal access paths (bLAPs). A bLAP ξR for a relation R in\nQ fetches all values (partial tuples) of R that are neces-\nsary for evaluating Q with ;  moreover, ξR is a bounded\nRAaggr plan  under .  Intuitively,  bLAPs  play  the  same\nrole as conventional DBMS access paths. But instead of\naccessing  complete  tuples  by  scan  or  index,  bLAPs\nfetches  values  (partial  tuples)  using  such  that  the\namount of data accessed is bounded.\nB\nMore  specifically,  we  give  an  algorithm,  denoted  by\nBAP, as a sub-procedure of BPlan to find a bLAP ξR for\nR under .  While  there  may  exist  exponentially  many\nsuch bLAPs, BAP aims at computing those with minim-\num cost. 514 International Journal of Automation and Computing 17(4), August 2020\n \n\n\nBAfter BAP computes bLAP ξR for every relation R in\nQ, algorithm BPlan generates a bounded plan ξQ for Q\nunder ,  by replacing each R in Q with its bLAP ξR, and\nby carrying out RAaggr operations of Q on the data re-\ntrieved by ξR.\nIn the rest of the section, we focus on algorithm BAP.\nParametric cost measures. To  evaluate  the  qual-\nity of bLAPs found by BAP, we start with a generic class\nof cost functions. Conventional access path measures as-\nsess  the  cost  of  physical  table-access  methods, e.g., se-\nquential scan and index scan[11]. These metrics do not ap-\nply to bLAPs, which involve, e.g., fetch and joins. Hence,\nBAP  employs  a  generic  cost  function c(ξR)  that  takes\nuser specified functions as parameters, to express various\ncost measures over ξR as bLAPs, e.g., output size, data\naccess, etc.\nB\n\u00001\n\u0000U\n\u0000\u0000\n\u0000fetch\n\u0000gpBy\nThe  cost  of  a  bLAP ξR for R under ,  denoted  by\nc(ξR),  is  inductively  defined  in Table  2,  with  five  user\nconfigurable parameter functions ,  , ,  and\n.\n \nc()\n\u00001/\u0000/[/fetch/gpBy\nTable 2       with parameters  4\nbLAP\n\u0018R\nc(\u0018R)\n\u0018R\nof \nfcg\n∅\nor  1\n\u001bC(\u0018′)\nc(\u0018′)\u0002\u0015\u001b(C)\n\u001811C\u00182\n\u00001(c(\u0018 1);c(\u00182))\u0002\u00151(C)\n\u00181\u0000\u00182\n\u0000\u0000(c(\u0018 1);c(\u00182))\n\u00181[\u00182\n\u0000[(c(\u0018 1);c(\u00182))\n\u0019Y(\u0018′)\nc(\u0018′)\ngpBy(\u0018′;\nX;r\nmagg (V))\n\u0000gpBy (c(\u0018′);\n\u0015\u0019(X))\nfetch(\u0018′;\nφ)\nφ=R(jX!Y\n;Nj)\nwith \n\u0000fetch(c(\u0018′);\nN)\n \n\u00001(c1;\nc2)\nc1\u0003c2\n\u0000fetch(c′;\nN)\nc′\u0002N\n\u0000[(c1;\nc2)\nc1+c2\n\u0000\u0000(c1;\nc2)\n\u0000gpBy (c′;\nc)\nc̸=\n0\n\u0015\u0019(X)\n= 0\nX=∅\nBy  parameterizing  these  user  configurable  functions,\nwe can  support  various  measures  for  bLAPs.  For  ex-\nample,  to  estimate  the  worst-case  output  size  of ξ,  we\nsimply  set  (i)  to ,  (ii)  to\n,  (iii)  to , (iv)  to c1, and\n(v)  to c' if  and to 1 otherwise (assume\n when ).\nAlgorithm BAP. Algorithm  BAP  works  in  two\nsteps:\nR2BR(Q;B)\nG(Q;B)\n(1) it reduces bLAPs to proofs of  and\nencodes  all  proofs  with  a  directed  graph  in\nPTIME; and\nG(Q;B)\n(2) it searches  to find proofs with minimum\ncost,  where  a  proof  corresponds  to  a  subgraph  in  the\nsearch trace.\nR2BR(Q;B)\nHere a proof of  is a sequence of applica-tions of the rules given in Fig. 1. Each step of the proof\ncorresponds to one or several operations in a bLAP ξR for\nR.\nBelow we outline BAP (see Appendix for its pseudo\ncode).\nB\nR2BR(Q;B)\nR2BR(Q;B)\nG(Q;B)\nR(jX!Y\n;Nj)2B\nR2BR(Q;B)\nu∅\nG(Q;B)\nG(Q;B)\n2j\njBjj+jQj\nj\njBjj(jjBjj+jQj)\n(1) Reduction .  It  reduces  the  problem  of  generating\nbLAPs  for R of Q under  to  finding  proofs  of\n.  It  encodes  all  proofs  of \n(hence  all  bLAPs  for R)  in  a  weighted  directed  graph\n,  where  nodes  encode  (a)  attributes R[X]  and\nR[XY]  in  constraints , and  (b)  rela-\ntions and sub-queries of Q. Edges encode value propaga-\ntion  among  them.  It  ensures  that  each  proof  of\n is  encoded  by  a  traversal  from  a  dummy\nnode  to  node uR encoding R in .  Graph\n has at most  nodes and \nedges.\nWe illustrate  reduced  graphs  with  the  following  ex-\nample, and defer the construction details to Appendix.\nB1\nB2\nG(Q 2;B1)\nG(Q 6;B2)\nu∅\nExample 9. Recall RAaggr queries Q2 of Example 2\nand Q6 of Example 5, and bag access schemas  and \nfrom  Example  4.  Graphs  and  are\nshown in Fig. 3. Here  is a dummy node connected to\nall constant attributes in Q. Edges with numeric weights\nare to encode deduction steps with rule γ3 of Fig. 1, where\nthe weights are the cardinality N's of the corresponding\naccess constraints.\n \n \n(a) G(Q2, B1) for Q2 and B1\n(b) G(Q6, B2) for Q6 and B21 1 10\n101uø uA\nuFuEF\nuEFW uSuAB uB uBC\nuR uQ7\nuQ6uZ[Q7]5 000 193 1\n1uø uf. uid\nuu. ctyu{f. uid, f. fid}\nufu{c. uid, c. cty}\nuc uQ3\nuZ[Q3]uc. uid\n \nFig. 3     Reduced graphs for Example 9\n \nR2BR(Q;B)\nu∅\nG(Q;B)\nAs  will  be  show  below,  proofs  of  a  relation\n can be encoded as traversals from  to uR\nin .\nG(Q;B)\nu∅\nB\n(2) Conditional Dijkstra search .  Algorithm  BAP  then\nadopts  a  Dijkstra-like  search  over ,  from  the\ndummy node  to the relation node uR encoding R, such\nthat the trace of the search encodes a bLAP (i.e., proof)\nfor R under .\nIt extends Dijkstra algorithm[24] as follows.\nG(Q;B)\n(a)  Conditional  expansion.  Denote  by Uu the attrib-\nute,  relation  or  sub-query  encoded  by  a  node u in\n.  Note that Uu may be deduced from attributes or\n\u0015\u001b(C)\n\u00151(C)\n\u0015\u0019(X)4Following  query  optimizer  in  DBMS, ,  , \nare coefficients that can be estimated from database statistics as\na priori.Y. Cao et al. / Bounded Evaluation: Querying Big Data with Bounded Resources 515 \n \n\n\nR2BR(Q;B)sub-queries encoded by multiple predecessors of u as pre-\nconditions in the proof of .  To capture this,\nBAP visits a new node u under the condition that Uu can\nbe  obtained  from  predecessors  of u via,  e.g., joins  or\nfetch.\nR2BR(Q;B)\nG(Q;B)\nu∅\nB\nWith the condition, BAP ensures that for node u en-\ncoding relation ,  a traversal in  from\n to u encodes a bLAP for relation atom R in query Q\nunder . To illustrate this, let us consider  Example 10.\nf2BR(Q 2;B1)\nu∅\nG(Q 2;B1)\nc2BR(Q 2;B1)\nExample  10. A  proof  of  (here f  de-\nnotes friend) consists of the deduction steps (1), (2) and\n(4) in Example 7. It is encoded by the unique path from\n to uf in ;  similarly  for  the  proof  of\n.\nS2BR(Q 6;B2)\nu∅\nG(Q 6;B2)\n(us;\nuQ6)\nu∅\nA  more  informative  example  is .  Its\nproof is  also  described  in  Example  7.  The  proof  is  en-\ncoded by the traversal from  to uS, which is \nwithout the edge  as shown in Fig. 3. Note that\nalthough there are two simple paths from  to uS, none\nof them is a valid traversal because of the conditional ex-\npansion.\nB1\n\u0018Q2\nB2\n\u0018Q4\n\u0018Q4\nThe bLAPs encoded by these proofs are exactly sub-\nplans  of Q2 and Q6 given  in  Example  5.  Indeed,  the\nbLAP ξc for relation c of Q2 under  is (T1, T2) of the\nbounded plan  in Example 5, and the bLAP ξf for f is\nsimply T1. Similarly, the bLAP ξR for R of Q6 under  is\nsimply T1 of  in Example 5; and bLAP ξS for S is (T1,\nT2, T3) of .\nNote that a bLAP may involve multiple relations via\nfetch and join, e.g., ξS for S of Q6. Hence its costs cannot\nbe  assessed  by  traditional  access  path  measures  since\nthose  methods  are  developed  for  evaluating  the  access\nmethod of a single relation via, e.g., sequential or index\nscan.\n(b) Search revision. Note that the output of an RAag-\ngr sub-query  can  be  used  to  fetch  attributes  that  have\nalready been  deduced,  possibly  with  a  smaller  cost  re-\nduced by c(ξR). To retain the optimality of the search,\nwhen visiting a node u that encodes a sub-query of Q, al-\ngorithm BAP checks whether this yields a better bLAP\nby starting a new search from u and marking all nodes as\nunvisited. It terminates if it cannot further improve the\npreviously searched bLAPs.\nB1\nB2\nc(\u0018 f)\n= 5 000\nc(\u0018 c)\n= 5 000\u0002193\nB1\nc(\u0018R)\n= 10\nc(\u0018S)\n= 10\nQ6\nB2\n\u0018S\nQ6\nB2\nExample  11. Continuing  with  Example  9,  assume\nthat we use c(ξR) to express the worst-case output size of\nξR (recall its parameter functions described earlier). Then\nBAP computes exactly the bLAPs for Q2 and Q6 under\n and , respectively, as described in Example 10. In\nparticular,  and  for Q2\nunder ;   and  for  under . In\nthis case, when computing  for relation S of  under\n, it  restarts the search once due to the aggregate sub-\nquery Q7, which does not improve the bLAPs ξR and ξS.\nR2BR(Q;B)\nCorrectness & Complexity. The correctness of al-\ngorithm  BAP  is  warranted  by  the  following:  (1)  each\nsearch  trace  of  BAP  encodes  a  proof  of ;\nR2BR(Q;B)\nB\nO(jQjjB\nj(jjBjj +jQj log(jQj + 2jjBjj)))\nG(Q;B)and (2) a proof of  encodes a bLAP for R\nunder .  BAP  can  be  implemented  in\n-time  (ignoring  the\ncomplexity  of  parameter  functions  of c(ξR)).  One  can\nverify that BAP restarts at most N times, where N is the\nnumber of nodes in .\nOptimality. Algorithm BAP is able to find optimal\nbLAPs for a large class of parameter functions for c(ξR).\nWe defer detailed proofs of this optimality to Appendix.\n6   Experimental study\nWe have developed BEAS@PG by extending Postgr-\neSQL with bounded evaluation. Using a benchmark and\ntwo real-life  datasets,  we  conducted  four  sets  of  experi-\nments  to  evaluate  (1)  the  overall  performance  of\nBEAS@PG  vs  PostgreSQL;  and  the  effectiveness  of\nbounded evaluation for (2) bounded queries and (3) un-\nbounded queries.\nExperimental setting. We start with the setting.\nBench mark .  We  used  TPCH  benchmark[15].  It  uses\nTPCHdbgen to generate 8 relations with 61 attributes of\ndifferent scales. It contains 22 built-in benchmark queries.\nReal-life datasets . We also used two real-life datasets.\n(a) US Air carriers (AIRCA) records flight and stat-\nistic data of US air carriers. It consists of Flight On-Time\nPerformance  Data[25] for departure  and  arrival  informa-\ntion, and Carrier Statistic data[26] for airline market and\nsegment data of the air carriers. It has 3 tables, 200 at-\ntributes, and about 16 GB of data with records from 1990\nto 1997.\n(b) UK  MOT  data  (UKMOT)  integrates  the  an-\nonymised data[27] that records MOT tests and outcomes,\nand the roadside survey of vehicle observations[28] that in-\ncludes vehicles passing observation points in the UK. It\nhas 3 tables with 42 attributes, about 16 GB of data from\n2007 to 2011.\nQueries . To test the impact of query structures on the\neffectiveness of bounded evaluation, we designed a gener-\nator to generate queries with different structures over the\ntwo real-life datasets. More specifically, we manually cre-\nated  30  query  templates  for  each  of  the  two  datasets\n(Q1–Q15 are boundedly evaluable and Q16–Q30 are un-\nbounded),  with  0  to  4  joins.  The  generator  populates\nthese templates by randomly instantiating parameters in\nthe templates with values from the datasets, yielding 150\nqueries for each real-life dataset.\nφ=R(jX!Y\n;Nj)\nAccess schema . We built access schemas with 59, 18\nand 14 access constraints over TPCH, AIRCA and UK-\nMOT, respectively. We extended TANE[29], an algorithm\nfor discovering functional dependencies, to first find can-\ndidate  constraints  on  small  sample\ndatasets of 100 MB, and ranked them by their cardinalit-\nies N′s. We then checked whether their N′s are insensit-\nive to the size of datasets D, by varying the size of D,\ne.g., 200 MB  and  500 MB. We  picked  those  access  con- 516 International Journal of Automation and Computing 17(4), August 2020\n \n\n\nstraints with small and size-insensitive N′s, such that the\ntotal size of the indices is at most 3 times of the size of\nits D.\nR(jX!Y\n;Nj)\nConfiguration .  For  DBMS,  we  used  PostgreSQL  9.6\nwith  all  optimization  enabled  (BEAS@PG  is  built  with\nPostgreSQL 9.6). In favor of PostgreSQL, besides indices\nfor access constraints, we also built the following extra in-\ndices  for  PostgreSQL:  (1)  for  each  access  constraint\n,  we  built  a  B-tree  index  on  attributes X\nover R as well; (2) we built all primary key and foreign\nkey indices; and (3) we also built B-tree on numerical at-\ntributes. Note that these were only for PostgreSQL, not\nbuilt for BEAS@PG. We set the cost measure paramet-\ners of  BEAS@PG  as  the  worst-case  output  size  estima-\ntion (recall Section 5.3).\nThe experiments were conducted on an Amazon EC2\nDense-storage instance m4.xlarge, with 16 GB of memory,\n4  Intel  Xeon  E5-2676  vCPUs,  and  500 GB  of  EBS  SSD\nstorage. Both the plan generation time and the execution\ntime  of  the  generated  plans  are  included  in  evaluation\ntime. All the experiments were run 3 times. The average\nis reported here.\nExperimental results. We next report our findings.\nExp-1:  Overall  performance. We  first  report  the\nevaluation time of 22 TPCH queries over 16 GB of TPCH\ndata, and the 60 query templates over the entire AIRCA\nand UKMOT datasets, where evaluation time of a query\ntemplate is the average of the evaluation time of its 5 in-\nstantiated queries.\n(1) Index size . The  indices  of  all  the  access  con-\nstraints  over  TPCH,  AIRCA  and  UKMOT  account  for\n2.98, 0.01 and 0.25 times of the size of the datasets, re-\nspectively; the  additional  indices  built  only  for  Postgr-\neSQL  (in  favor  of  the  conventional  DBMS)  are  of  size\n2.21, 0.87 and 1.5 times of that of TPCH, AIRCA and\nUKMOT, respectively.\nR(jX!Y\n;Nj)\n(2) Query overview .  None  of  the  TPCH  queries  is\nboundedly evaluable  under  the  access  constraints  selec-\nted. This is because the TPCH data generator scales car-\ndinalities N's  of  almost  all  candidate  access  constraints\n due to its simple scaling up strategy. This\nrules out most of the candidate constraints when we scale\nup to larger datasets while using a fixed threshold for N.\nFor the 60 query templates over AIRCA and UKMOT,\n30 of them are boundedly evaluable under the access con-\nstraints  used,  15  for  each  dataset.  Note  that  one  could\nbuild  more  access  constraints  to  allow  more  bounded\nqueries. We will evaluate the performance of BEAS@PG\nfor  bounded  and  unbounded  queries  in  more  details  in\nExp-2 and Exp-3, respectively.\n(3) Performance . The results for TPCH, AIRCA and\nUKMOT are reported in Tables 3–5, respectively.\n\u0002104\n(a) BEAS@PG outperforms PostgreSQL on each and\nevery query on all the three datasets, when all indices are\nenabled for PostgreSQL. It is 1.11  times faster on\naverage.\n\u0002103\n\u0002103\n\u0002104\n\u0002104(b)  Even  though  all  TPCH  queries  are  unbounded,\nover  16 GB  of  TPCH  data,  BEAS@PG  is  up  to  40.46\ntimes  faster  than  PostgreSQL,  and  is  on  average  7.32\ntimes  faster.  For  unbounded  queries  over  AIRCA  and\nUKMOT, BEAS@PG is on average 1.32  and 4.61 \ntimes faster than PostgreSQL, respectively, up to 1.48 \nand 6.10  times.\n\u0002104\n\u0002104\n\u0002104\n\u0002105\n(c) For bounded queries, BEAS@PG is 1.79  and\n3.66  times faster than PostgreSQL on AIRCA and\nUKMOT,  respectively,  up  to  3.44  and  2.52 \ntimes.\nThe  results  show  that  with  a  modest  number  (and\nsize) of access constraints, BEAS@PG can speed up Post-\ngreSQL on both bounded queries and unbounded queries,\nwhen all relevant indices are enabled for PostgreSQL, in-\ncluding those of access constraints and additional indices\ntailored for PostgreSQL. This verifies the effectiveness of\nbounded evaluation for generic queries, bounded or not,\nwhile the speedup is much larger for bounded queries, as\nexpected.\nBelow we report more in-depth evaluation results for\nBEAS@PG  versus  PostgreSQL  (with  additional  indices)\nfor  bounded  queries  (Exp-2)  and  unbounded  queries\n(Exp-3).\nExp-2:  Effectiveness  for  bounded  queries. We\nnext evaluated the impact of datasets D and queries Q\non  the  evaluation  time  of  BEAS@PG  and  PostgreSQL\n(with  indices  enabled),  when  queries Q are  boundedly\nevaluable.\nVarying  |D|. To evaluate the impact of |D|, we parti-\ntioned AIRCA  and  UKMOT  datasets  by  their  date  at-\ntributes (year and month), yielding subsets of sizes from\n1 GB to 16 GB, consistent with how we scale up TPCH\ndatasets when testing unbounded queries below in Exp-3.\nWe  did  not  use  TPCH  here  since  it  has  no  boundedly\nevaluable queries.\n\u0002102\n\u0002104\n\u0002105\n\u0002105\n\u0002105\n\u0002104\n\u0002103\nAs  shown  in Figs. 4(a) and 4(b),  (a)  the  evaluation\ntime of BEAS@PG is indifferent to the size of D, as ex-\npected  for  boundedly  evaluable  queries.  (b)  Bounded\nquery plans work well with large D. Indeed, BEAS@PG\ntook  less  than  11.67 ms  and  3.94   ms  for  all  queries\nover all subsets of AIRCA and UKMOT, respectively, no\nmatter how large the datasets were. In contrast, even on\nthe subsets of AIRCA and UKMOT of size 8 GB, Postgr-\neSQL took 8.45   ms and 3.88  ms, respectively,\nup to 1.58   ms and 7.80  ms over the full data-\nsets.  That  is,  PostgreSQL  is  1.35  and  1.98 \nslower than  BEAS@PG  on  AIRCA  and  UKMOT,  re-\nspectively, even with all relevant indices built. The lar-\nger the  dataset  is,  the  bigger  the  gap  between  Postgr-\neSQL and BEAS@PG is for bounded queries.\nVarying  Q. To evaluate the impact of queries Q, we\nvaried the complexity of Q, measured as the number #Q\nof joins in the query templates Q, from 0 to 4, while us-\ning the entire AIRCA and UKMOT datasets. Note that\nfor each query template, we instantiated 5 queries by set-Y. Cao et al. / Bounded Evaluation: Querying Big Data with Bounded Resources 517 \n \n\n\nting  its  parameters  with  different  values  (hence  these\nqueries  share  the  same  query  structure  and  #Q).  The\nevaluation time of each query template is the average of\nall its instantiated queries.\n\u0002105\n\u0002104\nThe  results  are  reported  in Figs. 4(c) and 4(d).  We\nfind the following. (a) The complexity of Q has impacts\non the performance of both BEAS@PG and PostgreSQL,\nas expected. They both take longer time for queries with\nmore  joins  (i.e., #Q).  However,  (b)  BEAS@PG  scales\nmuch  better  with  the  number  #Q of  joins  in Q than\nPostgreSQL  (with  indices).  For  instance,  on  average\nBEAS@PG  found  answers  for  all  queries  with  #Q =  4\nwithin 11.67 ms on full-sized AIRCA, while PostgreSQL\ntakes  1.56   ms;  that  is,  PostgreSQL  is  1.34 \ntimes slower than BEAS@PG for large queries.\n\u0002103\n\u0002104\nRemark . We find that when queries Q incur joins on\nkeys only,  PostgreSQL  with  extra  key/foreign  key  in-\ndices built is almost as fast as BEAS@PG (e.g., TPCH\nQ4). However, as long as Q involves non-key attributes,\ne.g., many of the AIRCA and UKMOT queries, Postgr-\neSQL performs poorly on big tables, even provided with\nall  indices.  Indeed,  on  average  BEAS@PG  outperforms\nPostgreSQL by 8.98  times and 1.76  times forall bounded queries over all subsets of AIRCA and UK-\nMOT, respectively.  The  gap  gets  larger  when  the  num-\nber of non-key attributes increases.\nR(jX!Y\n;Nj)\nBy  looking  into  PostgreSQL′s  plan  and  its  EXPLAIN\noutput, we find that this is partially due to the following\nreason.  Given  an  access  constraint ,\nBEAS@PG  fetches  only  distinct  values  of  the  relevant\nXY attributes, but PostgreSQL fetches entire tuples with\nirrelevant attributes of R, although those attributes are\nnot  needed  for  answering Q at all,  no  matter  what  in-\ndices  are  provided.  This  led  to  duplicated  (X,Y)  values\nwhen X is  not  a  key,  and  the  duplication  got  inflated\nrapidly by joins, e.g., EXPLAIN output shows that Postgr-\neSQL  consistently  accesses  entire  tables  when  there  are\nnon-key attributes.\nExp-3: Effectiveness for unbounded queries. In\nthe same setting as in Exp-2, we evaluated the impact of\nD and Q on  the  performance  of  unbounded  queries  by\nBEAS@PG  and  PostgreSQL  with  indices  enabled  for\nPostgreSQL.\nVarying  |D|.  The  results  on  AIRCA,  UKMOT  and\nTPCH  are  in Fig. (4e), (4f) and (4g), respectively.  Ob-\nserve the following. \nTable 3    TPCH query evaluation time on 16 GB (ms)\nQueries Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11\ntP\nPostgreSQL 8.16 × 1053.68 × 1041.02 × 1051.56 × 1041.50 × 1052.07 × 1049.53 × 1043.71 × 1045.03 × 1042.28 × 1057.05 × 104\ntB\nBEAS@PG  5.72 × 1041.67 × 1042.97 × 1041.45 × 1041.43 × 1054.25 × 1037.65 × 1043.43 × 1043.24 × 1048.19 × 1043.46 × 103\ntP/t B\nSpeedup  14.28 2.21 3.44 1.07 1.05 4.88 1.24 1.08 1.55 2.79 20.39\nQueries Q12 Q13 Q14 Q15 Q16 Q17 Q18 Q19 Q20 Q21 Q22\ntP\nPostgreSQL 6.42 × 1041.79 × 1051.74 × 1045.10 × 1044.46 × 1046.04 × 1032.83 × 1057.27 × 1031.06 × 1052.66 × 1057.74 × 103\ntB\nBEAS@PG  8.58 × 1031.20 × 1051.10 × 1042.20 × 1043.02 × 1041.49 × 1022.38 × 1051.29 × 1032.70 × 1031.04 × 1055.70 × 103\ntP/t B\nSpeedup  7.48 1.49 1.58 2.32 1.48 40.46 1.19 5.65 39.16 2.55 1.36\n \n \nTable 4    Average query template evaluation time on AIRCA (ms)\nQueries Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10\ntP\nPostgreSQL 7.00 × 1037.2 × 1032.06 × 1049.04 × 1044.44 × 1049.41 × 1041.36 × 1051.44 × 1059.41 × 1041.38 × 105\ntB\nBEAS@PG  1.22 1.19 0.64 2.63 2.61 6.34 4.28 6.69 6.02 4.98\ntP/t B\nSpeedup  5.75 × 1036.04 × 1033.21 × 1043.44 × 1041.70 × 1041.48 × 1043.19 × 1042.15 × 1041.57 × 1042.77 × 104\nQueries Q11 Q12 Q13 Q14 Q15 Q16 Q17 Q18 Q19 Q20\ntP\nPostgreSQL 1.46 × 1059.46 × 1041.49 × 1051.56 × 10510.63 × 1044.46 × 1044.65 × 1044.22 × 1044.25 × 1049.29 × 104\ntB\nBEAS@PG  7.24 11.42 6.55 8.5 11.67 24.96 24.3 2.84 4.63 × 1027.26 × 102\ntP/t B\nSpeedup  2.01 × 1048.29 × 1032.29 × 1041.84 × 1049.11 × 1031.79 × 1031.91 × 1031.48 × 104 91.86 1.29 × 102\nQueries Q21 Q22 Q23 Q24 Q25 Q26 Q27 Q28 Q29 Q30\ntP\nPostgreSQL 9.30 × 1048.98 × 1049.44 × 1049.41 × 1041.39 × 1051.47 × 1059.58 × 1041.75 × 1051.85 × 1051.31 × 105\ntB\nBEAS@PG  5.43 × 1024.61 × 1027.25 × 1025.23 × 1021.4 × 1031.74 × 1031.36 × 1032.67 × 1043.06 × 1042.62 × 104\ntP/t B\nSpeedup  1.71 × 1021.94 × 1021.31 × 1021.80 × 102 99.52 84.49 70.35 6.54 6.06 5.02\n  518 International Journal of Automation and Computing 17(4), August 2020\n \n\n\n\u0002102\n\u0002103(a) BEAS@PG is able to speed up PostgreSQL even\nfor queries that are not bounded under the available ac-\ncess  constraints.  On  average,  BEAS@PG  is  7.22 ,\n2.29  and 3.43 times faster than PostgreSQL for un-\nbounded queries  on  AIRCA,  UKMOT  and  TPCH,  re-\nspectively. This is because while not all relations in these\nqueries are bounded, bounded evaluation can still speed\nup their “bounded” subqueries, and hence remains faster\nthan PostgreSQL.\n\u0002102\n\u0002103\n\u0002103\n\u0002103\n\u0002104\n\u0002104\n\u0002103\n\u0002104\n\u0002103\n\u0002105\n\u0002105\n\u0002105\n(b)  As  opposed  to  evaluating  bounded  queries,  both\nBEAS@PG  and  PostgreSQL  are  sensitive  to  the  size  of\nthe  datasets  when  evaluating  unbounded  queries.\nHowever, BEAS@PG  scales  much  better  than  Postgr-\neSQL,  and  their  performance  gap  becomes  larger  when\nthe dataset size increases. For example, when the dataset\nincreases  from  1 GB  to  16 GB,  the  average  processing\ntime  of  BEAS@PG  increases  from  9.53   ms,  1.67\n ms and 2.21  ms to 6.09  ms, 1.84   ms\nand  4.54   ms on  AIRCA,  UKMOT  and  TPCH,  re-\nspectively.  In  contrast,  PostgreSQL  increases  from  7.50\n ms, 2.61  ms and 5.98  ms to 1.04  ms,\n4.53   ms and 1.23   ms, respectively, even with\nall indices built and enabled.\nR(jX!Y\n;Nj)\nNote that the speedup for unbounded TPCH queries\nis not as good as for AIRCA and UKMOT queries. This\nis because (i) the N's of access constraints \nover TPCH scale linearly as the dataset gets larger, while\nthose on AIRCA and UKMOT are more stable and inde-\npendent of the dataset size; and (ii) joins in TPCH quer-\nies are mostly key/foreign key joins, and thus the extra\nkey  indices  built  for  PostgreSQL  can  mimic  bounded\nquery plans used by BEAS@PG to some extent, reducing\ntheir performance gaps.\nVarying  Q.  Varying  the  number  #Q of  joins  in  the\nqueries,  the  evaluation  time  of  unbounded  queries  over\n\u0002104\n\u0002104\n\u0002105AIRCA and UKMOT is reported in Figs. (4h) and (4i),\nrespectively.  The  results  tell  us  the  following.  (a)  The\nprocessing time of BEAS@PG and PostgreSQL increases\nwhen the number of joins increases. However, (b) the gap\nbetween  BEAS@PG  and  PostgreSQL  becomes  larger\nwhen #Q increases from 0 to 4. For instance, over AIR-\nCA,  on  average  BEAS@PG  and  PostgreSQL  take\n17.37 ms and 4.43   ms, respectively, to answer quer-\nies with #Q = 0; and the two take 2.78   ms and 1.64\n ms,  respectively,  when  #Q =  4;  the  results  over\nUKMOT are similar. Note that for bounded queries, the\ngap between the two is even larger (Exp-2).\n\u0002103\n\u0002104\n\u0002104\n\u0002105\n\u0002104\n\u0002104\n\u0002102\n\u0002103\nSummary.  We  find  the  following.  (1)  BEAS@PG\n(PostgreSQL with BEAS built on top) does better than\nPostgreSQL for each and every query in all cases, even\nwith  extra  indices  built  for  the  latter.  On  average\nBEAS@PG improves PostgreSQL by 7.32, 9.58  and\n2.06  times for TPCH benchmark of 16 GB, AIRCA\nand UKMOT, respectively, up to 40.46, 3.44 ,  and\n2.52  times in the best case. (2) For queries that are\nboundedly evaluable,  BEAS@PG  outperforms  Postgr-\neSQL  by  1.9  and  3.6  times  on  AIRCA  and\nUKMOT, respectively. (3) For queries with complicated\njoins, e.g., joins on non-key attributes (AIRCA and UK-\nMOT queries), BEAS@PG is particularly effective, even\nfor  unbounded  queries.  For  example,  on  average\nBEAS@PG  improves  PostgreSQL  by  5.97   and\n1.90  times for queries that are not boundedly evalu-\nable  over  AIRCA  and  UKMOT,  respectively.  For  cases\nwhere  conventional  DBMS  does  its  best, e.g., table\nscan/aggregation and key-foreign key joins (most TPCH\nqueries),  BEAS@PG  still  does  better  than  PostgreSQL.\n(4) The storage cost for indices of access schema is mod-\nest, accounting for 2.98, 0.01 and 0.25 times of the size of\n16 GB TPCH, AIRCA and UKMOT, respectively. \nTable 5    Average query template evaluation time on UKMOT (ms)\nQueries Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10\ntP\nPostgreSQL 1.37 × 1056.47 × 1047.80 × 1044.62 × 1054.65 × 1053.86 × 1055.8 × 1053.91 × 1055.72 × 1055.99 × 105\ntB\nBEAS@PG  0.55 2.73 0.62 16.13 75.2 5.62 1.50 × 1023.78 × 102 54.79 1.89 × 102\ntP/t B\nSpeedup 2.52 × 1052.38 × 1041.25 × 1052.86 × 1046.18 × 1036.88 × 1043.88 × 1031.04 × 1031.04 × 1043.18 × 103\nQueries Q11 Q12 Q13 Q14 Q15 Q16 Q17 Q18 Q19 Q20\ntP\nPostgreSQL 4.09 × 1055.91 × 1057.80 × 1055.91 × 1057.74 × 1051.61 × 1051.59 × 1051.53 × 1053.97 × 1053.93 × 105\ntB\nBEAS@PG  3.89 × 102 55.42 1.89 × 1023.94 × 102 96.24 30.49 65.09 2.51 7.4 × 1037.41 × 103\ntP/t B\nSpeedup 1.06 × 1031.07 × 1044.13 × 1031.49 × 1038.05 × 1035.28 × 1032.44 × 1036.10 × 104 53.55 53.14\nQueries Q21 Q22 Q23 Q24 Q25 Q26 Q27 Q28 Q29 Q30\ntP\nPostgreSQL 3.93 × 1056.01 × 1053.94 × 1055.98 × 1056.26 × 1054.13 × 1056.19 × 1057.04 × 1054.86 × 1056.96 × 105\ntB\nBEAS@PG  9.25 × 1037.51 × 1037.72 × 1039.34 × 1037.62 × 1037.82 × 1037.38 × 1036.42 × 1047.65 × 1046.26 × 104\ntP/t B\nSpeedup 42.48 80.07 51.12 64.08 82.14 52.87 83.81 10.95 6.37 11.12\n Y. Cao et al. / Bounded Evaluation: Querying Big Data with Bounded Resources 519 \n \n\n\n7   Related  work\nThe related work is categorized as follows.\nBounded evaluation . The  notion  of  bounded  evalu-\nation was introduced in [5], as an effort to formalize scale\nindependence [19, 30, 31]. The latter aims to guarantee that a\nbounded amount of work is required to execute all quer-\nies in an application, regardless of the size of the underly-\ning data. Under access schema proposed in [19], Fan et\nal.[5] defines boundedly  evaluable  RA  queries.  It  estab-\nlishes  the  complexity  of  deciding  whether  a  query  is\nboundedly evaluable, for queries in various fragments of\nRA,  ranging  from  EXPSPACE-hard  to  undecidable.\nBounded evaluation using views was studied in [32], fo-\ncusing on its complexity bounds.\nTo cope with the undecidability of the bounded evalu-\nability problem, an effective syntax was given for RA in\n[6] under  the  set  semantics.  Based  on  the  syntax,  al-\ngorithms were developed[6] for checking the bounded eval-\nuability of RA queries Q, and if affirmative, generating a\nbounded query plan for Q. These issues were also stud-\nied in [33] for SPC, using a restricted form of query plans.Based on [6], a prototype BEAS for RA queries was de-\nveloped [34].\nThis work extends the prior work in the following. (1)\nWe  define  bag  access  schema,  an  extension  of  access\nschema of [5, 19] to support the bag semantics (Section\n2). (2) We identify decidable special cases of the bounded\nevaluability problem that cover a variety of SQL queries\ncommonly used in practice. (3) We develop an effective\nsyntax  for  boundedly  evaluable  RA aggr queries  under  a\nbag access schema, supporting nested aggregations (Sec-\ntion 4). Moreover, the syntax allows us to make a larger\nclass of RA queries bounded, improving the result of [ 6]\nfor RA. (4) We extend BEAS [34] from RA to RAaggr, by\nseamlessly  integrating  bounded  evaluation  with  DBMS\nquery  optimizers,  which  is  quite  different  from  [6, 34].\nThese extend DBMS with bounded evaluation, which was\nnot studied in [ 5, 6, 33, 34].\nQuery answering with constrained resources . The  ob-\njective of this work is to make big data analytics access-\nible to small companies under constrained resources. For\nqueries that are not boundedly evaluable, an approach is\nto compute  approximate  answers  under  available  re- \n1 2 4 8 16\nDataset size (GB) (logscaled)0246810Evaluation time (104 ms)\nPostgreSQL\nBEAS@PG\n(a) AIRCA: varying |D| (bounded)1 2 4 8 16\nDataset size (GB) (logscaled)012345Evaluation time (105 ms)\nPostgreSQL\nBEAS@PG\n(b) UKMOT: varying |D| (bounded)0 1 2 3 4\nJoin number0255075100125150Evaluation time (103 ms)\nPostgreSQL\nBEAS@PG\n(c) AIRCA: varying #Q (bounded)\n0 1 2 3 4\nJoin number0246Evaluation time (105 ms)\nPostgreSQL\nBEAS@PG\n(d) UKMOT: varying #Q (bounded)1 2 4 8 16\nDataset size (GB) (logscaled)0246810Evaluation time (104 ms)\nPostgreSQL\nBEAS@PG\n(e) AIRCA: varying |D| (unbounded)1 2 4 8 16\nDataset size (GB) (logscaled)01234Evaluation time (105 ms)\nPostgreSQL\nBEAS@PG\n(f) UKMOT: varying |D| (unbounded)\n1 2 4 8 16\nDataset size (GB) (logscaled)0255075100125Evaluation time (103 ms)\nPostgreSQL\nBEAS@PG\n(g) TPCH: varying |D| (unbounded)0 1 2 3 4\nJoin number0255075100125150Evaluation time (103 ms)\nPostgreSQL\nBEAS@PG\n(h) AIRCA: varying #Q (unbounded)0 1 2 3 4\nJoin number0246Evaluation time (105 ms)\nPostgreSQL\nBEAS@PG\n(i) UKMOT: varying #Q (unbounded)\nFig. 4     Effectiveness  of bounded  evaluation  for bounded  and unbounded  queries\n  520 International Journal of Automation and Computing 17(4), August 2020\n \n\n\nQ(D Q)\nD\nDQ\nD\ns2Q(D Q)\nt2Q(D )\ns2Q(D Q)sources. Approximation techniques have been extensively\nstudied,  based  on  synopsis  (e.g.,[35–39])  or  dynamic\nsampling (e.g.,[40–42]). We have proposed a data-driven\napproximation scheme[17] that computes approximate an-\nswers  to  an  RAaggr query Q in  a  dataset ,  by\nidentifying a fraction  of  under an extension of the\naccess schema of [5]. It ensures a deterministic accuracy\nbound η: (a) for each tuple , there  exists an ex-\nact  answer t that  is  within  distance  at  most η from S,\nand  (b)  for  each  exact  answer ,  there  exists\n within distance η from t.\nThis work differs from [17] in that we focus on com-\nputing exact answers instead of approximation. The tech-\nniques are hence quite different. In particular, a bag ac-\ncess  schema  carries  the  multiplicities  of  tuples  to  deal\nwith the bag semantics, as opposed to distance bounds in\naccess templates of [17]. This said, this work and [17] are\ncomplementary to each other. On one hand, the methods\nof [17] can be used to compute approximate answers to\nunbounded  queries  under  constrained  resources.  On  the\nother hand, the techniques developed in this work can be\nincorporated into the methods of [17], to improve the ac-\ncuracy of approximate answers by making use of DBMS\noptimizers and bounded sub-plans.\nR(jX!Y\n;Nj)\nIndices . Hash-based or tree-based, DBMS indices are\ntypically  defined  at  the  tuple  level[11],  to  retrieve  tuple\nIDs  and  fetch  full  tuples.  In  contrast,  a  bag  constraint\n offers a value-based index. Bounded plans\nfetch distinct partial tuples( Y-values) for each input X-\nvalue, and thus reduce duplicated and unnecessary attrib-\nutes in tuples fetched by DBMS, i.e., reduce data access\nand intermediate relations. The redundancies get inflated\nrapidly with joins. Moreover, the cardinality constraints\nin  a  bag  access  schema  allow  us  to  determine  whether\ndata access is bounded.\nRelated to bag access schema is a notion of access pat-\nterns,  which  require  a  relation  to  be  accessed  only  by\nproviding certain combinations of attributes, e.g.,[43–45].\nAs opposed  to  access  patterns,  a  bag  access  schema  of-\nfers cardinality constraints, tuple multiplicity and indices.\nMoreover, it is not required to cover all the attributes of\na relation and hence, allows us to fetch partial tuples and\nreduce  redundancy.  Further,  this  work  studies  bounded\nevaluation  of  RAaggr queries  and  its  integration  with\nDBMS, which were not considered in the prior work on\nquery answering under access patterns.\nQuery optimization . There has been a host of work on\nquery optimization in DBMS, including access path selec-\ntion[46], join optimization[47, 48] and recently, machine lean-\ning methods[49–51]. These focus on access path cost mod-\nels for, e.g., main-memory concurrent systems[46], heurist-\nics  for  join[47] and  group-by[48] re-ordering,  learned\nindices[50, 51] or  optimizers[49, 52–54].  Our  algorithms  and\ntechniques are complementary to the prior work, to incor-\nporate bounded  evaluation  into  DBMS  query  optimiza-\ntion.8   Conclusions\nWe have presented an approach to extending DBMS\nwith bounded evaluation of SQL queries. The novelty of\nthe work consists of (a) a notion of bag access schema to\nsupport the bag semantics of nested aggregations; (b) de-\ncidable special cases of the bounded evaluability of RAaggr\nqueries; (c) an effective syntax to characterize boundedly\nevaluable RAaggr queries; and (d) a framework and its un-\nderlying  algorithms  for  integrating  bounded  evaluation\nwith DBMS. Our experimental study has verified that the\napproach is promising. Together with the approximation\nscheme  of  [17],  we  hope  that  this  work  provides  small\nbusinesses  with  a  capacity  for  querying  big  data  under\nconstrained resources.\nOne topic for future work is to develop algorithms for\ndiscovering bag access schemas by incorporating machine\nlearning techniques. Another topic is to extend bounded\nevaluation of SQL queries to column-oriented DBMS.\nAppendix\nB\nBounded plans under  (Section 2)\n\u0004B\nB\nThe set  of bounded query plans under a bag ac-\ncess scheme  is inductively defined in Fig. 5.\n \n \n \nB\n\u0004B\nFig. 5     Bounded plans under    (set  )\n \nDetails of Algorithm BPlan (Section 5.3)\nG(Q;B)\nWe provide (1) the construction of weighted directed\ngraph  for generating bLAPs, (2) algorithm BAP,\nand (3) justification for the optimality of bLAPs found by\nBAP.\nG(Q;B)\nG(Q;B)\nR(jX!Y\n;Nj)2B\nuQs\nvZ[Qs]\nu∅\nConstructing .  Let V and E be the node set\nand edge set of , respectively.  They are construc-\nted  as  follows:  (1)  for  each  access  constraint\n,  (a)  include uR[X], uR[XY] in V, re-\nferred to as BA-node; (b) include (uR[X], uR[XY]) in E, re-\nferred to as a fetch-edge; (2) for each relation S, include a\nnode uS in V, referred to as a BR-node; (3) for each sub-\nquery Qs of Q, include  in V as a BQ-node and \nin V as a BA-node, where Z[Qs] includes the output at-\ntributes of Qs; (4) for each constant attribute A = c in\nQ, there is a BA-node uA in V, and an additional node ;\n(5) for any two BA-nodes uX and uY, if uX (resp. uY) is\nnot the head (resp. tail) of a fetch-edge, then (uX, uY) isY. Cao et al. / Bounded Evaluation: Querying Big Data with Bounded Resources 521 \n \n\n\nA2X\nB2Y\n\u0006Q⊢A=B\n(u∅;\nuA)\nuQs\n(uR;\nuQs)an edge in E if there exist  and  such that\n;  (6)  is an edge in E for every con-\nstant attribute A in Q; (7) for any BA-node uX and BR-\nnode uR, if uX is the tail of a fetch edge and X contains\nall nontrivial attributes of R, then (uX, uR) is an edge in\nE;  and  (8)  for  any  BR-node uR and  BQ-node ,\n is an edge in E if R is a relation of Qs.\nG(Q;B)\nR(jX!Y\n;Nj)2B\n(u∅;\nuA)\nG(Q;B)\n2∥B∥+jQj\n∥B∥(∥B∥+\njQj)\nIn graph ,  fetch-edges carry cardinality N′s in\ntheir  encoded  access  constraints  as\ntheir weights; each edge  for constant node uA has\nweight  1;  and  the  other  edges  have  no  weight.  Graph\n has  at  most  nodes  and \n edges.\nG(Q;B)\nφ=R(jX!Y\n;Nj)2B\nu∅\nuX1\nuXm\nuY\n\u0018Y=\u0019Y(\u0018X11\u0001\n\u0001\u00011\u0018Xm)\n\u0018Xi(i2[1;\nm])\nu∅\nuXi\nEncoding proofs using .  Traversing a fetch-\nedge uR[X], uR[XY])  encodes  fetch h(ξR[X], φ)  for  some\n that fetches values for Y, where\nξX is the bLAP encoded by the traversal from  to uR[X],\nwhich  retrieves  values  for R[X]  necessary  for  answering\nQ; a traversal from a set S of BA-nodes , ···,  to a\nBA-node  encodes a bLAP \nfor Y, where  is the bLAP encoded by the\ntraversal from  to  that retrieves values for Xi. Oth-\ner cases are similar.\nAlgorithm 2. BAP\nB\nInput: RAaggr query Q, bounded relation R of Q, bag\naccess schema  and cost function c().\nB\nOutput: A bLAP ξR for R under .\nG(Q;B)\n1 construct graph ;\nPQ:=∅\nSv\nt:=∅\nH:=∅\nDT[u∅]\n:= 0\nLT[u∅]\n:=∅\nGATE[u ∅]\n:=∅\n2 ;  ; ; ; ;\n;\nG(Q;B)\n3 for each u in  do\nu̸=u∅\nDT[u]\n:= +1\nLT[u]\n:=∅\n4　if  then ; ;\n  GATE[u] := L[u];\nPQ:push(u ∅)\n5 ; //Initialization\nPQ̸=∅\n6 while:  do\n7　u := PQ.pop();//PQ pops out u with minimum\n   DT[u] in PQ\nSv\nt:=Svt[fug\n8　 ;\n9　for each neighbor v of u that is not in Svt do\nGATE[v ]\n:= GATE[v]nL[u]\n10　　 ;\n(u;\nv)\nDT[v]>\n\u0000fetch(DT[u];\n11　　if  is a fetch-edge and \n  w(u, v)) then\n12　　　PQ.push(v);\nDT[v]\n:=\u0000 fetch(DT[u];w (u;v ))\n13　　　 ; L T[v]:= {u}\n14　　else if v is a BR-node then\n15　　　PQ.push(v), DT[v]:= DT[u]; LT[v]:={u}\nGATE[v ]\n=∅\n16　　else if v is a BQ-node and  then\n17　　　PQ.push(v); DT[v]:= c(ξv);\n　　　　LT[v]:=pre(v) //ξv is the plan for Q encoded\n  by v, composed from predecessors pre(v) of v\n        following the structure of Q\nGATE[v ]\n=∅\n18　　else if  then\npre(v )\\Sv\nt\n　　　//attributes X of v are joined from those of\n 19　　　PQ.push(v);\n(DT[v];\nLT[v];Svt) := SC(u; pre(v )\\Svt;v)\n20　　　 ;\nd:=\u00001(LT[v])\n　　　   ;\nuq̸2H\n21　　　if LT[v] contains BQ-node uq and DT[v] and\n   then\nSv\nt:=fu∅;vg\nH:=H[\nfvg\n22　　　DT[v]  := d; ;  //\n restart the search\nu∅\n23 return bLAP  that  is  encoded  by  the  traversal\n  from  to uR recorded in LT[].\nu∅\nH\nAlgorithm BAP. BAP  is  given  as  Algorithm  2.  It\nuses (a) GATE[u] to record the condition for visiting u,\ne.g., for the head uX of a fetch-edge, GATE[u] = X; (b)\nL[u] to denote the attributes or relations u encoded; (c)\nDT[u] to denote the cost of the part of bLAP encoded by\nthe search trace from  to u; (d) LT[u] to store the nodes\nto be visited before visiting u; (e) a priority queue PQ for\nnodes to explore; and (f) sets Svt of visited nodes and \nof nodes triggered restarts.\nv∅\nAlgorithm BAP starts the search from . It  first ini-\ntializes data structures (lines 2–5). It then iteratively ex-\nplores nodes in PQ (lines 6–22). The search extends the\nDijkstra search  with  conditional  node  expansion  con-\ntrolled by GATE[v] and types of the edges (lines 9–22),\nusing c()  to  calculate  the  traversal  cost.  It  restarts  the\nsearch if the output of a sub-query is used as an input for\na fetch (i.e., to visit the head of a fetch-edge; determined\nby SC given as Algorithm 3) with a reduced cost (lines\n21–22). It returns bLAP encoded by the search trace if\nrestarts cannot improve its cost (line 23).\nAlgorithm 3. SC\nInput: visited vertex u and vertex set Svt, and vertex\n  v to be visited.\nOutput: DT[v], LT[v] and updated Svt.\nGATE[v ]̸=∅\nDT[v]\n:=\u0015(DT[u];w (u;v ))\nLT[v]\n:=fug\n1 if  then ;\n  ;\n2 return DT[v], LT[v], Svt\nW:=L[v]\nHv:=∅\n3 ;  ;\nW̸=∅\n4 while:  do\nu′2Sv\nt\\pre(v )\ngv(fD T[v′]jv′2Hv[fu′gg)\njW\\L[u′]j\n5　choose  with minimum  \n  ;\nW:=WnL[u′]\nHv:=Hv[\nfu′g\n6　 ;  \n\u0015(DT[u];\nw(u;v ))<\ngv(fDT[v′]jv′2Hv)\n7 if (u, v) is a fetch-edge and \n   then\nDT[v]\n:=\u0015(DT[u];w (u;v ))\nLT[v]\n:=fug\n8　 ;  \n9 else\nDT[v]\n:=gv(fDT[v′]jv′2Hv)\n10　 ;  LT[v] := Hv;\n11　if Hv contains q-vertex then Svt := {v};\n12 return DT[v], LT[v], Svt);\nc(\u0018R)\n\u00001\n\u0000\u0000\n\u0000[\n\u0000gpBy\n\u0000fetch\nOptimality of BAP. We say that cost  is regu-\nlar if (a) all parameter functions are monotonically non-\ndecreasing w.r.t. each of their arguments; and (b) ,  ,\n,   and  are commutative and associative.\nmax φ=R (jX!Y\n;Nj)2BjYj\n#B\nDenote  by , where |Y| is the 522 International Journal of Automation and Computing 17(4), August 2020\n \n\n\nnumber of attributes in Y. Then we have the following.\n#B\u00141\nProposition 11. Under any access schema B, BAP\nfinds  optimal  bLAPs  with  regular  cost  functions  if\n.\nProof sketch. We discuss SPC Q first, followed by\nRAaggr.\n(1) Q is in SPC . We first prove the following lemmas.\nu2Sv\nt\nu∅\nu∅\n(a) For each node ,  DT[u] is the shortest dis-\ntance from  to u; and for each unvisited node v, DT[v]\nis the shortest distance from  when traversing nodes in\nSvt only.\nu2Sv\nt\nu∅\n#B=\n1\n(b)  For  each , the  plan  encoded  by  the  tra-\nversal from  to u is of cost DT[u] when c() is regular\nand .\nu∅\nFor if these hold, then when BAP terminates, the en-\ncoded plan from  to uR is an LAP for R with minim-\num c().\nS0\u0012S\n#B=\n1\nu∅\nG(Q;B)\nB\nLemma (a) can be proved by induction on the num-\nber of nodes in Svt, along the same line as Dijkstra′s op-\ntimality proof, by observing that SC(v, S) always selects\nthe subset  with minimum cost w.r.t. c() for visit-\ning v when .  Lemma  (b)  can  be  verified  by  the\nsame induction with (i) the observation that DT[u] mim-\nics c() for the encoded bLAP from  to u, and (ii) the\ncorrespondence  between  proofs  (traversals  in )\nand bLAPs under  in the proof of Theorem 7 (part of\nthe proof of Lemma (II)).\n(2) Q is in RA aggr.  For  RAaggr queries,  we  show  that\nBAP preserves the optimality of SPC with the following\nlemmas:\n(c)  Every  sub-query Qs of Q can  improve  searched\nLAP once.\n(d)  The  order  of  sub-queries  to  restart  does  not\nchange the final bLAP (up to equivalence).\n[\n\u0000\u0002\nBoth lemmas are proved by induction on the number\nof  –,  and  gpBy  operations  in Q,  using  the  condition\nthat  is associative and commutative and c() is mono-\ntonic. □\nOne may expect BAP to find optimal bLAP for more\ncases while remaining in PTIME. This is, however, bey-\nond reach.\nk\n>1\nB\n#B =k\nQ2\nLB\nc(\u0018R)\u0014r\nc(\u0018R)\nProposition  12. For  each  integer ,  it  is  NP-\nhard  to  decide,  given  any  bag  access  schema  with\n,  RAaggr query , relation atom R of Q and\nnumber R, whether there exists a bLAP ξR for R with\ncost , even when   is regular.\nS\u0012V\ne2E\nu2S\ne\njSj\n\u0014n\nProof. We show the NP-hardness by reduction from\nVERTEX COVER (VC),  which  is  NP-complete[1]. An  in-\nstance of VC consists of a graph G(V, E) and an integer\nn.  Given G and n (in  binary  form),  VC  is  to  decide\nwhether there exists a subset  such that (1) S cov-\ners G, i.e., for any edge ,  there exists  on ;\nand (2) .\nG(V =fv1;\u0001\n\u0001\u0001;vpg;E =fe1;\u0001\u0001\u0001;\neqg)\nR\nGiven  an  instance \n and n of VC, we construct a database schema , a\nB\nR\n#B=k\nk\u00152\nR\nB\nc(\u0018)\u0014r\njSj\n\u0014nbag access schema  over  with  (  is an in-\nteger), RAaggr Q over ,  a bounded relation RB in Q, a\nreal number R, a regular cost function c() such that there\nexists a bLAP ξ for RB under  with  if and only\nif G has a cover S with . More  specifically, the re-\nduction is given as follows.\nR\nR(A0;\nA)\nS(A1;\u0001\n\u0001\u0001;Aq;I)\nT(F1;\u0001\n\u0001\u0001;Fk)\nB\n#B =k\n(1) Database schema  consists of 3 relation schemas\n,  , and . Here rela-\ntion R is to encode the vertices of G, S is to represent\nedges of G, and T will be used to make  with .\n(2) Query Q is defined as follows:\n\u0019S[I](\u001bR1[A0]=1(R1)1\u0001\n\u0001\u00011\u001bRp[A0]=p(Rp)1S)\nRi[A]\n=S[Aj]\nvi2V\nej2E\nRi(i2[1;\np])\n\u0019S[I]\nwhere the join condition is  if  is an\nend point of  in G. Here relation atom \nis a renaming of relation schema R. Intuitively, the join\ncondition encodes the edge relation of G, and  is to\nensure that every attribute in S is nontrivial.\nB\n(3) The bag access schema  consists of 3 access con-\nstraints:\nφR=R(jA0!A;2j)\n,\nφS=S(jfA 1;\u0001\n\u0001\u0001;Aqg!I;1j)\n, and\nφT=T(j∅\n!fF1;\u0001\u0001\u0001;Fkg;1j)\n.\nR[A1;\u0001\n\u0001\u0001;Aq]\n#B=k\nHere φR is to fetch values of attribute R[A] (i.e., ver-\ntices of G), and φS is to fetch edges encoded by S[I] us-\ning  (i.e., edges of G). Note that .\nB\n(4) The bounded relation RB is set to be R. One can\neasily verify that R is bounded under .\n(5) We set r = 2n. Note that this is in PTIME since n\nin the VC instance is in binary.\n\u0000\u0002(c(\u0018 1);c(\u00182))\n=c1\u0002c2\n\u00181̸=\u00182\nmax(c(\u0018 1);\nc(\u00182))\n\u0000fetch(c;\nN) =c\u0002N\n(6)  Function c()  is  instantiated  as  follows:  (i)\n if  and  is \n otherwise.  (ii) ;  and  (iii)  we\nsimply set all other functions as constants. Note that c()\nis regular.\nc(\u0018)\u0014r\nWe show that G has a vertex cover S of size at most\nn if and only if R has a bLAP ξ with cost \n)\njSj\n\u0014n\nB\n\u0018= fetch(1q\ni=1\u0018Ai;\nφS)\n\u0018Ai= fetch(fjg;\nφR)\nvj2S\nB\njSj\n\u0014n;\nc(\u0018)\n=\u0000\u0002(1q\ni=1\u0018Ai)\u00021\u00142n=r\n Assume that G has a vertex cover S with .\nWe  construct  a  bLAP ξ for R under  as  follows:\n,  where  if ei is\ncovered  by  (when ei is covered  by  multiple  ver-\ntices in S, we pick one of them randomly). By the con-\nstruction of Q and by that S covers all edges of G, ξ is a\nbLAP  for S under .  From  we  know  that\n.\n(\nB\nc(\u0018)\u00142n\nS=fvi(i2[1;\np])j9j2[1;q];\u0018Aj= fetch\n(fig;\nφR)g\njSj\n\u0014n\n Assume that R has a bLAP ξ under  with cost\n.  By the join condition of Q and φS, there exist\nat most n distinct fetch operations for fetching S[A1], ··· ,\nS[Aq], i.e., S[A1], ··· , S[Aq] can be fetched from at most n\nnumbers 1, 2, ···, p using φR. This gives us a cover S of\nG as  follows: \n.  By the construction of Q, S is a cover of G\nwith . □Y. Cao et al. / Bounded Evaluation: Querying Big Data with Bounded Resources 523 \n \n\n\nAcknowlegements\nThe authors are supported in part by Royal Society\nWolfson Research Merit Award WRM/R1/180014, ERC\n652976,  EPSRC  EP/M025268/1,  Shenzhen  Institute  of\nComputing  Sciences,  and  Beijing  Advanced  Innovation\nCenter for Big Data and Brain Computing.\nOpen access\nThis article is licensed under a Creative Commons At-\ntribution  4.0  International  License,  which  permits  use,\nsharing, adaptation, distribution and reproduction in any\nmedium or format, as long as you give appropriate credit\nto the original author(s) and the source, provide a link to\nthe  Creative  Commons  licence,  and  indicate  if  changes\nwere made.\nThe images or other third party material in this art-\nicle are  included  in  the  article’s  Creative  Commons  li-\ncence,  unless  indicated  otherwise  in  a  credit  line  to  the\nmaterial. If material is not included in the article’s Creat-\nive Commons licence and your intended use is not per-\nmitted by statutory regulation or exceeds the permitted\nuse, you will need to obtain permission directly from the\ncopyright holder.\nTo view a copy of this licence, visit http://creative-\ncommons.org/licenses/by/4.0/.\nReferences\n C. H. Papadimitriou.  Computational  Complexity , Read-\ning, USA: Addison-Wesley, 1994.[1]\n S. Abiteboul,  R. Hull,  V. Vianu.  Foundations  of Data-\nbases , Boston, USA: Addison Wesley, 1995.[2]\n R. Horak.  Telecommunications  and Data Communica-\ntions Handbook , New York, USA: Wiley, 2007.[3]\n W. F. Fan,  X. Wang,  Y. H. Wu,  D. Deng.  Distributed\ngraph  simulation:  Impossibility  and possibility.  Proceed-\nings of the VLDB Endowment , vol. 7, no. 12, pp. 1083–\n1094, 2014. DOI: 10.14778/2732977.2732983.[4]\n W. F. Fan,  F. Geerts,  Y. Cao,  T. Deng,  P. Lu. Querying\nbig data  by accessing  small  data.  In Proceedings  of the\n34th ACM SIGMOD-SIGACT-SIGAI  Symposium  on\nPrinciples  of Database  Systems , ACM,  Melbourne,  Victor-\nia,  Australia,  pp. 173–184,  2015.  DOI:\n10.1145/2745754.2745771.[5]\n Y. Cao,  W. F. Fan.  An effective  syntax  for bounded  rela-\ntional  queries.  In Proceedings  of 2016 International  Con-\nference on Management  of Data , ACM,  San  Francisco,\n USA, 2016. DOI: 10.1145/2882903.2882942.[6]\n The University  of Edinburgh.  Huawei deal to advance ex-\npertise in data science , [Online],  Available:  https://\nwww.ed.ac.uk/news/2017/huawei-deal-to-advance-ex-\npertise-in-data-science, June 14, 2017.[7]\n Facebook.  Introducing  graph search beta, [Online],  Avail-\nable:  https://about.fb.com/news/2013/01/introducing-\ngraph-search-beta/, January 15, 2013.[8] I. Grujic,  S. Bogdanovic-Dinic,  L. Stoimenov.  Collecting\nand analyzing  data  from  e-government  Facebook  pages.  In\nICT Innovations , Ohrid, Macedonia, pp. 86–96, 2014.[9]\n Facebook.  Newsroom , [Online],  Available:  http://news-\nroom.fb.com.[10]\n R. Ramakrishnan,  J. Gehrke.  Database  Management  Sys-\ntems, 2nd ed., New  York,  USA:  McGraw-Hill  Education,\n2000.[11]\n J. D. Ullman.  Principles  of Database  Systems , 2nd ed.,\nComputer Science Press, 1982.[12]\n A. P. Stolboushkin,  M. A. Taitslin.  Finite  queries  do not\nhave  effective  syntax.  In Proceedings  of the 14th ACM\nSIGACT-SIGMOD-SIGART  Symposium  on Principles  of\nDatabase  Systems , ACM,  San  Jose,  USA,  pp. 277–285,\n1995. DOI: 10.1145/212433.212477.[13]\n A. van Gelder,  R. W. Topor.  Safety  and translation  of re-\nlational  calculus  queries.  ACM Transactions  on Database\nSystems , vol. 16, no. 2, pp. 235–278,  1991.  DOI:  10.1145/\n114325.103712.[14]\n TPC.  TPC-H,  [Online],  Available:  http://www.tpc.org/\ntpch/.[15]\n W. F. Fan.  Making  Big Data  Small,  UK: British  Royal So-\nciety, 2019. DOI: 10.1098/rspa.2019.0034.[16]\n Y. Cao,  W. F. Fan.  Data  driven  approximation  with\nbounded  resources.  Proceedings  of the VLDB Endowment ,\nvol. 10, no. 9, pp. 973–984,  2017.  DOI:  10.14778/3099622.\n3099628.[17]\n Y. Cao,  W. F. Fan,  T. F. Yuan.  Block  as a value  for SQL\nover  NoSQL.  Proceedings  of the VLDB Endowment ,\nvol. 12, no. 10, pp. 1153–1166,  2019.  DOI:  10.14778/3339490.\n3339498.[18]\n W. F. Fan,  F. Geerts,  L. Libkin.  On scale  independence  for\nquerying  big data.  In Proceedings  of the 33rd ACM SIG-\nMOD-SIGACT-SIGART  Symposium  on Principles  of\nDatabase  Systems , ACM,  Snowbird,  USA,  2014.  DOI:\n10.1145/2594538.2594551.[19]\n D. Abadi,  P. A. Boncz,  S. Harizopoulos,  S. Idreos,  S. Mad-\nden.  The  design  and implementation  of modern  column-\noriented  database  systems.  Foundations  and Trends® in\nDatabases , vol. 5, no. 3, pp. 197–280,  2013.  DOI:  10.1561/\n1900000024.[20]\n Microsoft  SQL  server  columnstore  indexes:  Overview,  [On-\nline],  Available:  https://docs.microsoft.com/en-us/sql/re-\nlational-databases/indexes/columnstore-indexes-over-\nview?view=sql-server-ver15.[21]\n TPC.  TPC-DS,  [Online],  Available:  http://www.tpc.org/\ntpcds/.[22]\n M. R. Garey,  D. S. Johnson.  Computers  and Intractabil-\nity: A Guide to the Theory of NP-Completeness , San\nFrancisco, USA: W. H. Freeman, 1979.[23]\n M. L. Fredman,  R. E. Tarjan.  Fibonacci  heaps  and their\nuses in improved  network  optimization  algorithms.  Journ-\nal of the ACM , vol. 34, no. 3, pp. 596–615,  1987.  DOI:\n10.1145/28869.28874.[24]\n Bureau  of Transportation  Statistics.  The  carrier  on-time\nperformance  database,  [Online],  Available:  http://www.[25] 524 International Journal of Automation and Computing 17(4), August 2020\n \n\n\ntranstats.bts.gov/DatabaseInfo.asp?DB_ID=120.\n Bureau  of Transportation  Statistics.  The air carrier  stat-\nistics  database,  [Online],  Available:  http://www.transtats.\nbts.gov/DatabaseInfo.asp?DB_ID=110.[26]\n Department  for Transport.  Anonymised  mot tests  and res-\nults,  [Online],  Available:  http://data.gov.uk/dataset/an-\nonymised_mot_test, January 11, 2019.[27]\n Department  for Transport.  Roadside  survey  of vehicle  ob-\nservations,  [Online],  Available:  https://data.gov.uk/data-\nset/52e1e2ab-5687-489b-a4d8-b207cd5d6767/roadside-\nsurvey-of-vehicle-observations.[28]\n Y. Huhtala,  J. Kärkkainen,  P. Porkka,  H. Toivonen.  Tane:\nAn efficient  algorithm  for discovering  functional  and ap-\nproximate  dependencies.  The Computer  Journal , vol. 42,\nno. 2, pp. 100–111, 1999. DOI: 10.1093/comjnl/42.2.100.[29]\n M. Armbrust,  A. Fox,  D. A. Patterson,  N. Lanham,  B.\nTrushkowsky,  J. Trutna,  H. Oh. Scads:  Scale-independent\nstorage  for social  computing  applications.  In Proceedings\nof the 4th Biennial  Conference  on Innovative  Data Sys-\ntems Research , Asilomar, USA, 2009.[30]\n M. Armbrust,  S. Tu, A. Fox,  M. J. Franklin,  D. A. Patter-\nson, N. Lanham,  B. Trushkowsky,  J. Trutna.  PIQL:  A per-\nformance  insightful  query  language.  In Proceedings  of\nACM SIGMOD  International  Conference  on Management\nof Data , ACM,  Indiana,  USA,  pp. 1207–1210,  2010.  DOI:\n10.1145/1807167.1807320.[31]\n Y. Cao,  W. F. Fan,  F. Geerts,  P. Lu. Bounded  query  re-\nwriting  using  views.  In Proceedings  of the 35th ACM SIG-\nMOD-SIGACT-SIGAI  Symposium  on Principles  of Data-\nbase Systems , ACM,  San  Francisco,  USA,  pp. 107–119,\n2016. DOI: 10.1145/2902251.2902294.[32]\n Y. Cao,  W. F. Fan,  T. Y. Wo,  W. Y. Yu. Bounded  con-\njunctive  queries.  Proceedings  of the VLDB Endowment ,\nvol. 7, no. 12, pp. 1231–1242,  2014.  DOI:  10.14778/2732977.\n2732996.[33]\n Y. Cao,  W. F. Fan,  Y. H. Wang,  T. F. Yuan,  Y. C. Li, L.\nY. Chen.  BEAS:  Bounded  evaluation  of SQL  queries.  In\nProceedings  of ACM International  Conference  on Manage-\nment of Data , ACM,  Chicago,  USA,  pp. 1667–1670,  2017.\nDOI: 10.1145/3035918.3058748.[34]\n S. Acharya,  P. B. Gibbons,  V. Poosala.  Congressional\nsamples  for approximate  answering  of group-by  queries.  In\nProceedings  of ACM SIGMOD  International  Conference\non Management  of Data , ACM,  Dallas,  Texas,  USA,\npp. 487–498, 2000. DOI: 10.1145/342009.335450.[35]\n Y. E. Ioannidis,  V. Poosala.  Histogram-based  approxima-\ntion  of set-valued  query-answers.  In Proceedings  of the\n25th International  Conference  on Very Large Data Bases ,\nEdinburgh, Scotland, UK, pp. 174–185, 1999.[36]\n H. V. Jagadish,  N. Koudas,  S. Muthukrishnan,  V. Poosala,\nK. C. Sevcik,  T. Suel.  Optimal  histograms  with  quality\nguarantees.  In Proceedings  of the 24rd International  Con-\nference on Very Large Data Bases , New  York  City,  USA,\npp. 275–286, 2009.[37]\n K. Chakrabarti,  M. N. Garofalakis,  R. Rastogi,  K. Shim.\nApproximate  query  processing  using  wavelets.  The VLDB\nJournal , vol. 10, no.  2–3, pp.  199–223, 2001.[38] G. Cormode,  M. Garofalakis.  Sketching  streams  through\nthe net: Distributed  approximate  query  tracking.  In Pro-\nceedings  of the 31st International  Conference  on Very\nLarge Data Bases , ACM, Trondheim, Norway, 2005.[39]\n B. Babcock,  S. Chaudhuri,  G. Das.  Dynamic  sample  selec-\ntion  for approximate  query  processing.  In Proceedings  of\nACM SIGMOD  International  Conference  on Management\nof Data , ACM,  San Diego,  USA,  pp. 539–550,  2003.  DOI:\n10.1145/872757.872822.[40]\n S. Kandula,  A. Shanbhag,  A. Vitorovic,  M. Olma,  R.\nGrandl,  S. Chaudhuri,  B. Ding.  Quickr:  Lazily  approxim-\nating  complex  AdHoc  queries  in BigData  clusters.  In Pro-\nceedings  of  International  Conference  on Management  of\nData , ACM,  San Francisco,  USA,  pp. 631–646,  2016.  DOI:\n10.1145/2882903.2882940.[41]\n S. Agarwal,  B. Mozafari,  A. Panda,  H. Milner,  S. Madden,\nI. Stoica.  BlinkDB:  Queries  with  bounded  errors  and\nbounded  response  times  on very  large  data.  In Proceed-\nings of the 8th ACM European  Conference  on Computer\nSystems , SCM,  Prague,  Czech  Republic,  pp. 29–42,  2013.\nDOI: 10.1145/2465351.2465355.[42]\n C. Li. Computing  complete  answers  to queries  in the pres-\nence  of limited  access  patterns.  The VLDB Journal ,\nvol. 12, no. 3, pp. 211–227,  2003.  DOI:  10.1007/s00778-002-\n0085-6.[43]\n M. Benedikt,  J. Leblay,  B. ten Cate,  E. Tsamoura.  Gener-\nating Plans from Proofs: Synthesis  Lectures  on Data Mar-\nagement,  vol.8,  no.1,  pp. 1–205,  2016.  DOI:  10.2200/\nS00703ED1V01Y201602DTM043.[44]\n A. Nash,  B. Ludäscher.  Processing  first-order  queries  un-\nder limited  access  patterns.  In Proceedings  of the 23rd\nACM SIGMOD-SIGACT-SIGART  Symposium  on Prin-\nciples of Database  Systems , ACM,  Paris,  France,\npp. 307–318, 2004. DOI: 10.1145/1055558.1055601.[45]\n M. S. Kester,  M. Athanassoulis,  S. Idreos.  Access  path  se-\nlection  in main-memory  optimized  data  systems:  Should  I\nscan  or should  I probe?  In Proceedings  of ACM Interna-\ntional Conference  on Management  of Data , ACM,  Chica-\ngo,  USA,  pp. 715–730,  2017.  DOI:  10.1145/3035918.\n3064049.[46]\n T. Neumann.  Query  simplification:  Graceful  degradation\nfor join-order  optimization.  In Proceedings  of ACM SIG-\nMOD International  Conference  on Management  of Data ,\nACM,  Rhode  Island,  USA,  pp. 403–414,  2009.  DOI:\n10.1145/1559845.1559889.[47]\n M. Eich,  P. Fender,  G. Moerkotte.  Faster  plan  generation\nthrough  consideration  of functional  dependencies  and\nkeys.  Proceedings  of the VLDB Endowment , vol. 9, no. 10,\npp. 756–767, 2016. DOI: 10.14778/2977797.2977802.[48]\n B. L. Ding,  S. Das,  R. Marcus,  W. T. Wu,  S. Chaudhuri,\nV. R. Narasayya.  AI meets  AI: Leveraging  query  execu-\ntions  to improve  index  recommendations.  In Proceedings\nof  International  Conference  on Management  of Data ,\nACM,  Amsterdam,  The Netherlands,  pp. 1241–1258,  2019.\nDOI: 10.1145/3299869.3324957.[49]\n T. Kraska,  A. Beutel,  E. H. Chi,  J. Dean,  N. Polyzotis.\nThe case for learned  index  structures.  In Proceedings  of In-\nternational  Conference  on Management  of Data , ACM,[50]Y. Cao et al. / Bounded Evaluation: Querying Big Data with Bounded Resources 525 \n \n\n\nHouston,  USA, pp. 489–504, 2018. DOI: 10.1145/3183713.\n3196909 .\n A. Galakatos,  M. Markovitch,  C. Binnig, R. Fonseca,  T.\nKraska. Fiting-tree:  A data-aware  index structure.  In Pro-\nceedings  of International  Conference  on Management  of\nData , ACM, Amsterdam,  The Netherlands,  pp. 1189–1206,\n2019. DOI: 10.1145/3299869.3319860 .[51]\n R. C. Marcus, P. Negi, H. Z. Mao, C. Zhang, M. Alizadeh,\nT. Kraska, O. Papaemmanouil,  N. Tatbul. Neo: A learned\nquery optimizer.  Proceedings  of the VLDB Endowment ,\nvol. 12, no. 11, pp. 1705–1718, 2019. DOI: 10.14778/3342263.\n3342644 .[52]\n J. Sun, G. Li. An end-to-end  learning-based  cost estimat-\nor. Proceedings  of the VLDB Endowment , vol. 13, no. 3,\npp. 307–319, 2019. DOI: 10.14778/3368289.3368296 .[53]\n I. Trummer,  J. Wang, D. Maram, S. Moseley,  S. Jo, J.\nAntonakakis.  Skinnerdb:  Regret-bounded  query evalu-\nation via reinforcement  learning.  https://arxiv.org/abs/\n1901.05152v1 , 2019. DOI: 10.1145/3299869.3300088 .[54]\n \nYang Cao  received the B. Sc. degree from\nBeihang  University,  China. He received\nthe Ph.D. degree from University  of Edin-\nburgh, UK. He is a faculty member in the\nSchool of Informatics,  University  of Edin-\nburgh, UK.  He is the recipient  of SIG-\nMOD Research  Highlight  ward 2018, SIG-\nMOD Best Paper ward 2017, and Mi-\ncrosoft Research  Asia Fellowship.  His re-\nsearch has been invited to publish in TODS special issues on\n“Best of SIGMOD  2017” and “Best of PODS 2016”, and in the\nComputer  Journal special issue on “Best of BICOD 2015”.\n     His  research  interests  include query processing,  graph data\nmanagement  and distributed  databases.\n     E-mail: yang.cao@ed.ac.uk  (Corresponding  author)\n     ORCID iD: 0000-0001-7984-3219 \nWen-Fei  Fan  received the B. Sc. degree\nand M.Sc. degree from Peking University\nChina. He received the Ph. D. degree from\nUniversity  of Pennsylvania,  USA. He is the\nChair of Web Data Management  at the\nUniversity  of Edinburgh,  UK, the Chief\nScientist  of Shenzhen  Institute  of Comput-\ning Science, and the Chief Scientist  of\nBeijing Advanced  Innovation  Center for\nBig Data and Brain Computing,  China. He is a Fellow of the\nRoyal Society (FRS), a Fellow of the Royal Society of Edin-\nburgh (FRSE),  a Member  of the Academy  of Europe (MAE), an\nACM Fellow (FACM),  and a Foreign Member  of Chinese\nAcademy  of Sciences.  He is a recipient  of Royal Society Wolfson\nResearch  Merit Award in 2018, ERC Advanced  Fellowship  in\n2015, the Roger Needham  Award, UK in 2008, Yangtze  River\nScholar, China in 2007, the Outstanding  Overseas  Young Schol-\nar Award, China in 2003 , the Career Award, USA in 2001, and\nseveral Test-of-Time  and Best Paper Awards USA (Alberto  O.\nMendelzon  Test-of-Time  Award of ACM PODS 2015 and 2010,\nBest Paper Awards for SIGMOD  2017, VLDB 2010, ICDE 2007\nand Computer  Networks  2002).\n     His research  interests  include database  theory and systems,  in\nparticular  big data, data quality, data sharing, distributed  query\nprocessing,  query languages,  recommender  systems and social\nmedia marketing.\n     E-mail: wenfei@inf.ed.ac.uk\n     ORCID iD: 0000-0001-5149-2656\n \nTeng-Fei Yuan   received the B.Eng. de-\ngree from Shandong  University  China. He\nis Ph.D. degree cadidate  in LFCS, School\nof Informatics,  University  of Edinburgh\nUK.\n     His  research  interest is development  of\nBEAS, a system for bounded  evaluation  of\nSQL queries.\n     E-mail: tengfei.yuan@ed.ac.uk 526 International Journal of Automation and Computing 17(4), August 2020\n \n",
  "textLength": 127935
}