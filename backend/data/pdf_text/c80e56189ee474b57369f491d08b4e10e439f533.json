{
  "paperId": "c80e56189ee474b57369f491d08b4e10e439f533",
  "title": "Simple and Robust Dynamic Two-Dimensional Convex Hull",
  "pdfPath": "c80e56189ee474b57369f491d08b4e10e439f533.pdf",
  "text": "Simple and Robust Dynamic Two-Dimensional Convex Hull\nEmil Toftegaard Gæde∗Inge Li Gørtz\n�∗Ivor van der Hoog\n�∗Christoffer Krogh∗\nEva Rotenberg\n�∗\nAbstract\nTheconvex hull of a data set Pis the smallest convex set\nthat contains P. Adynamic data set is one where points\nare inserted and deleted. In this work, we present a new\ndata structure for convex hull, that allows for efficient\ndynamic updates, in theory and practice.\nIn a dynamic convex hull implementation, the fol-\nlowing traits are desirable: (1) algorithms for efficiently\nanswering queries as to whether a specified point is in-\nside or outside the hull, (2) adhering to geometric ro-\nbustness, and (3) algorithmic simplicity.\nFurthermore, a specific but well-motivated type of\ntwo-dimensional data is rank-based data. Here, the\ninput is a set of real-valued numbers Ywhere for any\nnumber y∈Yits rank is its index in Y’s sorted\norder. Each value in Ycan be mapped to a point\n(rank ,value ) to obtain a two-dimensional point set.\nNote that for a single update, a linear number of\n(rank ,value )-pairs may change; posing a challenge\nfor dynamic algorithms. It is desirable for a dynamic\nconvex hull implementation to also (4) accommodate\nrank-based data.\nIn this work, we give an efficient, geometrically ro-\nbust, dynamic convex hull algorithm, that facilitates\nqueries to whether a point is internal. Furthermore,\nour construction can be used to efficiently update the\nconvex hull of rank-ordered data , when the real-valued\npoint set is subject to insertions and deletions. Our im-\nproved solution is based on an algorithmic simplification\nof the classical convex hull data structure by Overmars\nand van Leeuwen [STOC’80], combined with new algo-\nrithmic insights.\nOur theoretical guarantees on the update time\nmatch those of Overmars and van Leeuwen, namely\nO(log2|P|), while we allow a wider range of functional-\nities (including rank-based data). Our algorithmic sim-\nplification includes simplifying an 11-case check down\nto a 3-case check that can be written in 20 lines of eas-\nily readable C-code. We extend our solution to pro-\nvide a trade-off between theoretical guarantees and the\npractical performance of our algorithm. We test and\ncompare our solutions extensively on inputs that were\n∗Technical University of Denmark, Kongens Lyngby, Denmarkgenerated randomly or adversarially, including bench-\nmarking datasets from the literature.\nAcknowledgements. This research was sup-\nported by Independent Research Fund Denmark grant\n2020-2023 (9131-00044B) “Dynamic Network Analysis”\nand Eva Rotenberg’s Carlsberg Foundation Young Re-\nsearcher Fellowship CF21-0302 - “Graph Algorithms\nwith Geometric Applications”. This project has ad-\nditionally received funding from the European Union’s\nHorizon 2020 research and innovation programme un-\nder the Marie Sk lodowska-Curie grant agreement No\n899987.\n1 Introduction\nIn analysis of spatial data, computing the convex hull\nyields one of the most fundamental characteristics of\nthe data set. The convex hull itself serves as a com-\nputational stepping stone towards promptly answering\nrelevant queries as they arrive online. Seen from the\nstatic perspective, the problem of computing the con-\nvex hull has received much attention. In this paper,\nwe study the dynamic setting, where data points may\narbitrarily be added, deleted, or altered. Convex hulls\nhave many applications for evolving or changing data\nsets, illustrating the need for an efficient, practical, and\npublicly available dynamic convex hull implementation.\nProblem statement. The convex hull CH(P) of\na point set Pis the minimal convex shape that con-\ntains all points in P. Convex hulls are one of the\nmost prominent studied objects in computational ge-\nometry [9] due to their many applications which include\ntop-queries [28, 37], clustering [33, 25, 44], road network\nanalysis [34, 47, 25], and data pruning/dimension reduc-\ntion [26, 38, 30, 35]. A convex hull data structure can\nstore CH(P) either explicitly orimplicitly . An explicit\ndata structure stores the vertices (or edges) of the hull,\nin their cyclical ordering, as a balanced binary tree.\nAnimplicit convex hull data structure supports\n(a subset of) common convex hull queries without\nmaintaining the edges of the convex hull. The points\nofPthat lie on the convex hull of Pare called the\nextreme points of P. An implicit data structure stores\na data structure on Pthat can answer queries on the\nconvex hull such as [13]:arXiv:2310.18068v2  [cs.CG]  31 Oct 2023\n\n1. Finding the extreme point of Pin a query direction,\n2. Deciding whether a line intersects CH(P),\n3. Finding the two hull vertices tangent to a query,\n4. Deciding whether a query point qlies in CH(P),\n5. Finding the intersection with a query line,\n6. Finding the intersection between two hulls.\nWe briefly note that with any explicit convex hull\n(storing hpoints) one can answer each of these queries\ninO(logh) time. We wish to dynamically maintain a\nconvex hull supporting these queries subject to point\ninsertions and deletions.\nRelated work. In the static setting, where the\ndata set does not change, computing an explicit convex\nhull of a set of npoints can be done in optimal O(nlogn)\ntime, e.g., with Graham’s scan [27] or Andrew’s vertical\nsweep line [2], or with the QuickHull O(nlogn) expected\ntime algorithm [5]. Crucially, Graham’s scan takes O(n)\ntime if the point set is already sorted by their radial\nordering. There also exist static, theoretically optimal,\noutput-sensitive algorithms, due to Kirkpatrick and\nSeidel [31] and later Chan [11]: They obtain O(nlogh)\nrunning time where hdenotes the number of points of\nPthat lie on the convex hull. In a dynamic setting, the\nonly data structure to explicitly maintain the convex\nhull is the O(log2n) algorithm by Overmars and van\nLeeuwen [40]. This is also the best explicit dynamic\nconvex hull algorithm with worst-case updates.\nThe first dynamic implicit data structure for the\nconvex hull is by Chan [12], who achieves a linear-size\ndata structure with O(log1+εn) amortized update time,\nand supports queries 1–3 in O(logn) time (here, ε >0 is\nsome arbitrarily small constant). The update time was\nimproved by Brodal and Jacob [9] to O(lognlog log n)\namortized. The original work by Chan [12] can answer\nqueries 4–6 in O(log3/2n) worst case time. This result\nwas later improved by Chan [13] to support these queries\ninO(log1+εn)expected time.\nConvex hull implementations. Despite its nu-\nmerous practical applications, implementations of dy-\nnamic convex hulls are scarce. Many approaches rely\nupon static algorithms for the convex hull (e.g., [7, 45,\n8, 23]), and thus have a linear update time. The CGAL\nlibrary for computational geometry algorithms has no\nimplementation of dynamic convex hull algorithms. In-\nstead, they use a dynamic algorithm for maintaining\nthe Delaunay triangulation of a point set, which it-\nself contains the convex hull. However, dynamic De-\nlaunay triangulations have near-linear update time and\nlinear recourse, rendering them useless for polylogarith-\nmic dynamic updates. Chi, Hac´ ıg¨ um¨ u¸ s, Hsiung, and\nNaughton [16] provide a Java implementation of the dy-\nnamic algorithm by Overmars and van Leeuwen, which\nthey use for an application in scheduling. Comparedto ours, their algorithm lacks complete geometric ro-\nbustness, it does not facilitate queries, and it cannot\nbe extended to handle rank-ordered data. Indepen-\ndently, Cisneros [19] presents a C implementation of\nthe algorithm by Overmars and van Leeuwen. Unfor-\ntunately, this implementation is insertion-only and has\nmemory leaks. The algorithms for implicit convex hulls\nby Chan [12] and Brodal and Jacobs [9] are not imple-\nmented and do not support the operations required for\nour applications. The newer algorithm by Chan [13]\ndoes support these operations. It is our impression that\nthe three latter papers [12, 9, 13], present algorithms\nthat are sufficiently complex that further simplifications\nand new ideas are needed if they should be implemented\nin a way that is efficient in practice.\nApplications of (dynamic) convex hull. Con-\nvex hulls, or convex hull queries, have countless appli-\ncations. Here, we list some broad areas of application of\ndynamic convex hull queries. In Appendix C we elabo-\nrate on recent applications.\nQuery 4 can be used for constraint satisfaction\nproblems. Indeed, consider a set of constraints given\nby a collection of halfplanes. Each line supporting these\nhalfplanes can be mapped to a point (i.e. its dual). The\nfeasible region is subsequently given by the convex hulls\nof these points. Using Query 4, we can efficiently test if\na candidate value satisfies all constraints.\nQuery 5 can, given a preference vector specifying\nthe weight of the xandycoordinates, return the pre-\nferred element of P. Repeated application of the con-\nvex hull can give the top kpreferred elements [37, 28].\nTop-direction queries are often used as an intermediary\npipeline step in database algorithms [18, 16, 42].\nQuery 6 can be used to determine a line that\nminimizes the maximal distance to P. This has a\ndirect application in (linear) regression, where we want\nto replace Pby a line that for any x-coordinate, can\npredict the corresponding value in P[14, 46, 23].\nThe explicit convex hull itself (represented as a sub-\nset of point P′⊂P) has applications as a pruning\nstep for classification algorithms. Intuitively, the convex\nhullP′is the subset of ‘extremal’ points in P. Many\nclassification algorithms are most sensitive to these ex-\ntremal values. By maintaining the convex hull, one can\nsubsequently run classification algorithms on smaller-\ncomplexity input [44, 48, 26, 29]. Similarly, sometimes\nonly extremal points are interesting for learning al-\ngorithms (pruning the number of points in the train-\ning data). Examples include support vector machines\n(SVM) algorithms that use convex hull computations in\ntheir underlying algorithms [7, 45, 15, 20, 36]. Existing\nSVM algorithms use static convex hulls algorithms.\nWe want to briefly note one special application of\n\nconvex hull algorithms. Suppose that we are storing\na (large) set of values Y⊂R. The rank of each\ny∈Y, is its index in the sorted order of Yand we\nwant to support rank queries that for query values q\nreport the corresponding rank. If Yis a set subject\nto insertions and deletions then this is the dynamic\nindexing problem and it is well-studied [3, 6, 10, 41, 43].\nRecently, a new family of indexing data structures,\ncalled learned indexes, has been introduced [32, 22, 23].\nConsider a set of values Yand the corresponding two-\ndimensional point set PYthat maps every value in x\nto the coordinate ( rank ,value ). By maintaining the\nconvex hull of PY, recent work [32, 22, 23] uses ML\ntechniques that, for some given parameter ε, predict\nthe rank of each element with some additive error ε.\nOur contribution. Via new theoretical insights,\nwe provide a new practical algorithm for the dynamic\nconvex hull problem, and provide an efficient, geomet-\nrically robust implementation. Our implementation\nmakes use of the CGAL CORE library, to facilitate us-\nage in geometric computations. More specifically:\n•We establish a characterization for where to insert\nedges into a dynamic convex hull based on edge-to-\nedge comparison. This allows for storing the convex\nhull as a collection of edges (as opposed to points)\nwhich simplifies update logic compared to [40, 16].\n•We apply this characterization to the algorithm\nby Overmars and van Leeuwen [40] to get an\nimplementation of a linear-size data structure to\nexplicitly maintain a convex hull of size hin a\nbalanced binary tree with O(log2n) update time\nthat facilitates queries in O(logh) time.\n•We observe that OvL [40], even when simpli-\nfied using our streamlined edge-based logic, comes\nwith considerable overhead by maintaining what is\ncalled concatenable queues. We propose a new defi-\nnition of explicit convex hull, where we do not store\nthe edges of the convex hull in their cyclical order-\ning. Instead, we only require that we may (contrary\nto previous implicit convex hulls) answer queries 1–\n6 and that we can report the hpoints on the convex\nhull in O(hlogn) time.\n•With our edge-based logic, we construct a new\nalgorithm, Eilice , for maintaining this hull in\nO(log2n) worst-case update time with O(logn)\nqueries.\n•We provide both a geometrically robust version of\nEilice, as well as an approximate version since both\nversions have applications in practice.\n•For rank-based convex hulls, we present and imple-\nment new algorithms with the guarantees.\nNote: These are the first dynamic algorithms for\nrank-based hulls with polylogarithmic update time.\n(a)\n(b)Figure 1: (a) The hulls CH(P) and CH+(P). (b)\nGiven two upper convex hulls CH+(R) and CH+(B),\nwe construct their bridge.\n•We compare our implementations (the simplified\nOvL and the new Eilice) to the preexisting dynamic\nconvex hull implementations on a variety of gener-\nated and adversarial outputs. We conclude that:\n–geometric robustness comes at an expense of\ncomputation time,\n–as soon as the access pattern has less than\na few hundred queries per update, dynamic\nalgorithms have a clear advantage,\n–we obtain improved performance compared to\nthe state-of-the-art (including [18, 16]).\n2 Preliminaries\nLetPbe a set of npoints in R2. For any two points\n(α, β) we denote by αβthe segment between them. We\nsay that a line ℓseparates Pwhenever it contains at\nleast one point of Pin the interior of either halfplane\nbounded by the line. The convex hull CH(P) is the\nedge-set of the minimal convex shape that contains all\npoints in P. Equivalently, the convex hull consists of all\npoints P′such that each line through ( p1, p2)∈P′×P′\ndoes not separate P.\nWe say a point aprecedes a convex hull edge α\nif it has an x-coordinate that is lesser or equal than\nthe left endpoint of α. The upper convex hull CH+(P)\nis defined as the convex hull of the set P∪ {0,−∞}\n((Figure 1 (a)). The lower convex hull CH−(P) is\ndefined as the convex hull of P∪ {0,∞}, and when\nwe view convex hulls as an area in R2,CH(P) =\nCH+(P)∩CH−(P).\nConsider two point sets AandBthat are separated\nby a vertical line. The convex hull CH(A∪B) is formed\nby two segments of CH(A) and CH(B), together with\nup to two edges called bridges . Commonly, a bridge is\ndefined as a minimal segment abfor points ( a, b)∈A×B\nwhere the line extending abdoes not separate A∪B,\nsee Figure 1(b). One of the bridges coincides with\nCH+(A∪B), and one with CH−(A∪B).\nPartial Hull Trees Overmars and van\nLeeuwen [40] maintain the convex hull of a two-\ndimensional point set Pby maintaining CH+(P) and\nCH−(P) in two separate linear-size data structures\n\nthat can answer each of the queries (1)–(6) in O(logh)\ntime where his the size of the convex hull. By\ncomputing the points of intersection between CH+(P)\nandCH−(P) they can identify all edges of CH(P).\nThey store CH+(P) and CH−(P) in a data struc-\nture that we will refer to as a Partial Hull Tree (PHT).\nWe recall the data structure for storing the upper convex\nhullCH+(P) as these data structures are symmetrical.\nDefinition 1. Given a two-dimensional point set P,\nthePartial Hull Tree stores Pin a leaf-based balanced\nbinary tree T+(sorted by x-coordinates). For each\ninterior node v∈T+, denote by π(v)the points in the\nleaves at the subtree rooted at v. For each node v∈T+\nwith children (x, y)and parent v′, the Partial Hull Tree\nstores:\n•The unique bridge e+(v)between the upper hulls\nCH+(π(x))andCH+(π(y)).\n•Aconcatenable queue E∗(v). This is a balanced\nbinary tree of the vertices of CH+(π(v))that are\nnot in CH+(π(v′))(where v′is the parent of v).\n•For the root rofT∗,E∗(r)equals CH+(P).\nDynamically maintaining a Partial Hull Tree.\nLetpbe a point added to or removed from Pand denote\nbyρthe root-to-leaf path to p. In [40], they restore the\nPartial Hull Tree by computing for every node v∈ρthe\nbridge e+(v). Let xandybe the children of v. We define\napivot (αx, βx, γx) as any triple of consecutive points\nonCH+(π(x)). Overmars and van Leeuwen consider a\npair of pivots ( αx, βx, γx) and ( αy, βy, γy) ofxandy.\nThrough a case distinction of 11 cases (Figure 2) they\ncan conclude if e+(v) has its left endpoint preceding or\nsucceeding βx. This gives the following dynamic update\nalgorithm [40] that has two main steps:\nTraversing down. First, they traverse the path\nfrom the root to the leaf containing p. For every node v\nthey encounter, they consider the concatenable queues\nE∗(v),E∗(x),E∗(y). Here xandydenote the left and\nright child of v, respectively. Through the split and\njoin operations of balanced binary trees, they obtain\nthe convex hulls CH+(π(x)\\p) and CH+(π(y)\\p) in\nO(logn) time as balanced binary trees E(x) and E(y).\nBubbling up. Next, they traverse the path from\nthe leaf containing pto the root bottom-up and compute\nfor every vertex von the path the bridge e+(v). Let v\nhave children xandy:\n1. Each inner node of E(x) represents an vertex βx. In\nO(1) time they obtain the predecessor or successor\nofβxonCH+(π(x)\\p). The endpoints of these\nedges give a pivot ( αx, βx, γx).\n2. Similarly, each inner node of E(y) comes with a\npivot. Given two pivots, they decide in O(1) time if\nx\ny\nβx\nβyFigure 2: The 9 main cases for a line through the pivots\n(βx, βy). For each case, [40] can exclude at least1\n4of the\nremaining convex hull points as an endpoint of e+(v).\nThe 9’th case is further split into three others.\nthe endpoints of e+(v) succeed, precede or coincide\nwith the pivots (Figure 2). Depending on the case,\nthey recurse down E(x) and/or E(y).\n3. Since there are at most O(n) points on CH+(π(x))\nand CH+(π(v)), they recurse at most O(logn)\ntimes before they find the bridge e+(v) between\nCH+(π(x)) and CH+(π(y)).\nGiven the bridge e+(v), they update E∗(v). After\nhaving updated E∗(r) for the root r, they have com-\nputed the convex hull CH+(P).\nRuntime analysis. There are O(logn) nodes von\nthe root-to-leaf path ρinT+. They iterate over ρto\nobtain for all v∈ρa binary tree E(v) inO(log2n) total\ntime. Then, they traverse ρfrom ptowards the root.\nFor each v∈ρthat the three steps are performed in\nO(logn) time. Thus the total running time is O(log2n).\nThe logarithmic method We briefly mention\nthe logarithmic method, since Ferragina and Vin-\nciguerra [23] used it to maintain convex hulls to predict\nthe rank of elements in a fully dynamic set. The loga-\nrithmic method transforms (decomposable) static data\nstructures into insertion-only dynamic structures (see\ne.g. [39]). It uses a bucketing scheme of buckets that\nincreases in size exponentially. In Appendix D we de-\nscribe the logarithmic technique applied to the convex\nhull, and why doing so leads to incorrect query algo-\nrithms and hulls.\n3 Simplified Algorithm for Convex Hulls\nIn this section, we establish a new characterization for\nwhere to insert new edges into a dynamic convex hull.\nIn this analysis, we use edges of the current convex\nhull as pivots, as opposed to the analysis in [40] that\nuses points (Figure 2). We then use it to provide a\nmore straightforward implementation of the algorithm\nin [40]. Our analysis makes the algorithm in [40] not\nonly simpler but also more efficient as we may store and\n\ntraverse fewer pointers. To this end, we denote by T+\nthe Partial Hull Tree of Pwhere we redefine bridges\nand concatenable queues:\nDefinition 2. Letv∈T+have children xandy. We\ndefine its bridge e+(v)as a maximal segment abfor\npoints (a, b)∈CH+(π(x))×CH+(π(y))where the line\nextending abdoes not separate π(x)∪π(y)(Figure 3).\n(a)\n(b)\ny\nx\nv\nFigure 3: (a) v∈T+with children xandy. We show\nthe upper convex hull CH+(π(y)). (b) We redefine the\nbridge e+(v) as the maximal non-separating segment\nbetween CH+(π(x)) and CH+(π(y)).\nDefinition 3. Letv∈T+have children xandy.\nDenote by E(v)the edges of CH+(π(v))in their cyclical\nordering. We define E∗(x) :=E(x)\\E(v)(Figure 4).\nTheconcatenable queue (or c-queue) is E∗(x)stored in\nits cyclical ordering as a balanced binary tree.\nLemma 3.1. Letv∈T+have children xandy. Given\nE(v),E∗(x), andE∗(y), we may obtain E(x)inO(logn)\ntime using the split and join operations on binary trees.\nProof. The edges of E∗(x) are a contiguous interval in\nE(v). Moreover, an edge is in E(x)∩E(y) if and only\nif it precedes the bridge e+(v). Thus, we achieve the\nlemma through Algorithm 1.\nWhenever we invoke Algorithm 1, we store the tree\nERso that we may invert the algorithm to obtain E(v)\nfromE∗(x) inO(logn) time.\nThe Partial Hull Tree and its implementa-\ntion. The Partial Hull Tree T+is a balanced binary\ntree on Psorted by x-coordinate. Each node v∈T+\nwith children xandystores the bridge e+(v) between\nCH+(π(x)) and CH+(π(y)) and the c-queue E∗(v).\nThe Partial Hull Tree T−is defined analogously, using\nlower convex hulls.\nWe note that we can avoid storing Ptwice: by\nmaintaining only one tree Twhere every node vmain-\ntains both e+(v) and e−(v). We choose to implement\nthe Partial Hull Tree and all c-queues as AVL trees be-\ncause we want to have worst-case guarantees. To sim-\nplify our internal algorithm’s logic, we define the leaves\nof our c-queue to be points that are the endpoints of\ntheir parent edges. With slight abuse of notation, we\n(a)\n(b)\ny\nx\nvFigure 4: (a) Hulls E(x) andE(y). (b) The root vstores\nE∗(v) =E(v). Its left child xstores E∗(x) =E(x)\\E(v).\nrefer indistinguishably between edges σ∈E(v) and\ntheir c-queue node. That is, for each node w∈T\nthere is a unique ancestor vofwwhere the bridge\ne+(w) =σ∈E∗(v).\nAlgorithm 1 splitHull(left child x, balanced tree E(v))\n(EL,ER←E(v).Split( e+(v))\nE(x)←EL(v).Join( E∗(x))\nreturn (E(x),ER)\n3.1 Recomputing bridges using only edges\nLetv∈Thave children xandy. Our new definition of\nbridges and c-queues allows for new logic to recompute\nthe bridge e+(v) from E(x) and E(y) inO(logn) time.\nWe show this through two lemmas:\nIn Lemma 3.2, we consider two edges ( α, β)∈\nE(x)×E(y). In our data structure, these are both roots\nof a subtree in their respective trees. We can decide in\nO(1) time whether e+(v)’s endpoints succeed or precede\nthese edges: discarding at least one child of either αor\nβuntil we find one endpoint of e+(v).\nIn Lemma 3.3, let e+(v) = ( a, b). Given aand\nβ∈E(y), we can decide in O(1) time whether bprecedes\nor succeeds β. The result of these two lemmas is an\nO(logn) algorithm to find e+(v) (Algorithm 2).\nLemma 3.2. Letv∈Thave children xandy. Given\nedges α∈E(x)and β∈E(y)with center points\nlandr, respectively, we can decide whether e+(v)’s\nendpoints succeed/precede αandβinO(1)time using\nonly arithmetic and comparisons.\nProof. The proof is a case distinction, depending on\nthe slope of the segment lr. Denote by ( a, b) the\n(unknown) endpoints of e+(v). We consider three cases\n(where the first two are not mutually exclusive) and\ntheir consequence:\nSlope( α)≤Slope( lr):amust precede α.\nDenote by ( α1, α2) the endpoints of α. Consider the\ntriangle ∆ = ( α1, l, r). Since slope( α)≤slope( lr), and\nrper construction has a x-coordinate greater or equal to\nthat of α2, the point α2must be on or under the edge lr\nof this triangle (Figure 5). Per definition of convexity,\nthe bridge e+(v) bounds a halfplane that contains all\n\nα1\nα2\nl\nl′\nr\nα1\nα2\nl\nr\nl′Figure 5: Lemma 3.2, case 1, for upward and downward\nslopes. The purple triangle denotes ∆.\npoints in CH+(π(v)). Thus, the bridge e+(v) bounds a\nhalfplane that must contain ∆.\nWe claim that any point l′inπ(x) right of α1cannot\nbe an endpoint of e+(v). Indeed, any such point l′\nmust lie on or above the line through α1r(since the\nhalfplane bounded by e+(v) must contain both a1and\nr). This implies that we have found a l′∈π(x) such\nthat the segment α1l′has a greater slope than α: which\ncontradicts the assumption that αwas part of the upper\nconvex hull of π(x).\nSlope( lr)≤Slope( β):bmust succeed β.This\nproof is symmetric to the previous case.\nSlope( α)>Slope( lr)>Slope (β).Denote by\nma vertical line separating π(x) and π(y) (we can\ncompute such an min constant time). Denote by γ\nthe intersection point between the supporting lines of α\nandβ. We prove that:\n•ifγlies on or left of m,amust succeed α, and\n•ifγlies on or right of m,bmust precede β.\nWe prove the first subcase (Figure 6), as the second\nsubcase is symmetric. Denote by Γ the area that can\ncontain b, the area bounded by the halfplane supporting\nβand right of m. Because γlies left of m, Γ is entirely\ncontained in the halfplane bounded by the supporting\nline of β. Consider any vertex l′∈π(x) preceding α, the\nsegment l′bmust be contained in the halfplane bounded\nbyα. However, this implies that the segment l′bbounds\na halfplane that excludes α2. Thus, amust succeed α.\nNote that if asucceeds α(and, alies in the green area\nof the figure) then bmay succeed or precede β.\nl\nr\nγ\nα2\nΓ\nm\nFigure 6: Lemma 3.2, case 3.\nLemma 3.3. Letv∈Tbe an internal node with chil-\ndrenxandy. Given the left endpoint aofe+(v)and any\nedgeβ∈E(y), we can decide whether the right endpointbofe+(v)succeeds or precedes βinO(1)time using\nonly arithmetic and comparisons.\nProof. Denote by rthe center point of β. The sequence\nof edges on the upper convex hull of π(v) per definition\nhas decreasing slope. It immediately follows that if\nSlope( ar)>Slope( β) then bmust precede β. Similarly,\nif Slope( ar)<Slope( β) then bmust succeed β. Finally,\nif Slope( ar) = Slope( β) then the points a, rand the\nendpoints of βare collinear. Since our bridge is the\nmaximal segment bounding a halfplane that contains\nπ(v),bmust succeed β.\nCorollary 3.1. Letv∈Thave children xandy.\nGiven E(x)andE(y)as balanced trees, we may compute\nthe bridge e+(v)inO(logn)time (Algorithm 2).\nAlgorithm 2 FindBridge(node v,α∈E(x),β∈E(y))\n1:while ! (α.isLeaf andβ.isLeaf) do\n2: (l, r)←(α, β).getCenter()\n3:ifSlope( α)≤Slope( lr)and !α.isLeaf then\n4: α←α.leftChild\n5:ifSlope( lr)≤Slope( β)and !β.isLeaf then\n6: β←β.rightChild\n7:ifneither first two cases apply then\n8: ifβ.isLeaf then\n9: α←α.rightChild\n10: else if α.isLeaf then\n11: β←β.leftChild\n12: else\n13: γ←intersectLines( α,β)\n14: m←verticalLineSeparating( π(x), π(y))\n15: ifγleft of mthen\n16: α←α.rightChild\n17: else\n18: β←β.leftChild\n19:return (α,β)\n3.2 The update algorithm using c-queues Now,\nwe are ready to present our implementation of the\ndynamic algorithm in [40], using our edge-based logic.\nWe call this algorithm OvL. Let us insert or delete a\npoint p∈Pand denote by ρthe root-to-leaf path to p\ninT. We compute for all v∈ρthe bridge e+(v). This\nallows us to restore all c-queues, and store CH+(P) in\nE∗(r) (where ris the root of T). Our algorithm works\nin two steps, that both take O(log2n) time:\nTraversing down. We start at the root rwhere\nE∗(r) =E(r). We traverse ρfrom the root to p. For\neach node v, we assume we have E(v) as a balanced\nbinary tree. Let plie in the left child xofv(p∈\n\nπ(x)). We invoke splitHull( x,E(v)): destroying E(v)\nand storing ER(v) inv. The splitHull function gives us\nE(x) inO(logn) time, and with E(x) we recurse on x.\nBubbling up. For the leaf lthat contains p, the\nbridge e+(l) equals ( p, p). We create or delete this\nbridge accordingly. From the downwards traversal in\nthe previous step, we have the tree E(l) atl. We traverse\nρfrom lto the root. For each node v, we compute\nE(v) as follows. Let xandybe the children of v. If\nxis the child on the path, we computed E(x) before\nmoving up to vand we have E(y) from our downwards\ntraversal. We first invoke Algorithm 2 to compute e+(v)\ninO(logn) time (Corollary 3.1). We then compute E(v)\njoining E(x) and E(y) around the bridge e+(v).\nTheorem 3.1. LetPbe a two-dimensional point set.\nWe can maintain the edges of CH+(P)subject to\ninsertions and deletions in Pas a balanced binary tree\nE(r)inO(log2n)worst-case time per update.\nThe balanced binary tree E∗(r) at the root stores\nthehedges of CH+(P). Queries 1–6 can subsequently\nbe answered in O(logh) time using the standard search\nalgorithms over E∗(r) [13].\n4 Improving the Solution\nThe update algorithm presented in [40] differs from our\nnew approach in the following choices:\n•It traverses the path ρinTtwice: once top-down\nto ensure that we can compute for all v∈ρthe tree\nE(v), and once bottom-up to compute the bridges.\n•It stores points in Pmultiple times (both in Tand\nin the c-queues) requiring either double the space\nor pointers that point to non-contiguous data.\n•It uses the split and join operations on binary trees.\nAlthough these have O(logn) theoretical running\ntime, they are inefficient in practice.\nIn Appendix A, we resolve these issues. Our\nalgorithm no longer maintains the convex hull CH+(P)\nin a balanced binary tree. Instead, we maintain a new\nstructure that we call the Partial Bridge Tree (PBT).\nDefinition 4. ThePartial Bridge Tree (PBT) stores a\npoint set Pin a leaf-based balanced binary tree T(sorted\nbyx-coordinate). Each node v∈Tstores e+(v)and\ne−(v).\nWe can cleverly navigate our Partial Bridge Tree to get\ntwo properties:\n1.∀v∈T, given an edge e∈CH+(π(v)), we can find\nits successor on CH+(π(v)) in O(logn) time.\n2.∀v∈T, given an edge e∈CH+(π(v)), we can\nfind the median edge of all edges preceding eon\nCH+(π(v)), in O(logn) time.The first property allows us to report CH+(P) in\nO(hlogn) time. The second property naively allows\nus to answer Queries 1–6 in O(log2n) time. Hence,\nwe obtain an output that is somewhere in between the\nimplicit and explicit convex hull.\nMaintaining the Partial Bridge Tree. The sec-\nond property naively also gives us an O(log3n) update\ntime to maintain the Partial Bridge Tree. Indeed, con-\nsider after inserting or deleting point pinPthe path ρ\nfrom pto the root of T. To restore the Partial Bridge\nTree, we need to compute for all v∈ρ(with children x\nandy) the bridge e+(v). Algorithm 2 requires as input\nvplus two edges ( α, β)∈E(x)×E(y). We then recurse\nby replacing αwith α′(the median successor, or prede-\ncessor, on E(x)). In Section 3.2, we obtained α′inO(1)\ntime because we had E(x) as a balanced binary tree. Us-\ning Property 2, we may instead get α′inO(logn) time.\nThus, we obtain an update algorithm with O(log3n)\nupdate time and O(log2n) query time just by replacing\nthe functions ‘ α.leftChild’ and ‘ α.rightChild’ with the\nalgorithm from Property 2.\nWe can, however, do better. We show that invoking\nProperty 2 O(logn) times takes O(logn) worst-case\ntotal time. This creates a new algorithm for dynamic\nconvex hull which we call Eilice . Eilice has a worst-\ncase update time of O(log2n), matching OvL [40], and\na query time of O(logn). This update algorithm no\nlonger requires us to maintain c-queues. In addition, we\nno longer require the initialization step of OvL: ensuring\nthat we traverse Texactly once. Thus, it circumvents\nthe downsides of OvL at the cost of query time efficiency.\n5 Rank-based Convex Hulls\nFinally, we consider rank-based convex hulls. Let Ybe\na set of values, where the rank of y∈Yis its index in\nthe sorted order. We denote by PYthe two-dimensional\npoint set that is obtained by mapping each value in\nYto (rank ,value ) and wish to dynamically maintain\nCH(PY). The problem in this setting is that after\ninserting into or deleting from Y, the x-coordinate of\nlinearly many points in PYchanges. Changing a value y\nmay change CH(PY) by Θ( n) edges, even if yitself was\nnot on the convex hull (Figure 14). The key observation\nto maintaining the convex hull in this setting is the\nfollowing. After updating an element y∈Ya bridge\ne+(v) = (a, b) in the Partial Hull Tree is updated if and\nonly if yis in the subtree rooted at v. That is, if yis\nnot in the subtree rooted at vthen the x-coordinates\nof (a, b) may both increase or decrease by one, but the\nbridge e+(v) remains a segment between the same two\nvalues. Since the convex hull is implied by the set of\nall bridges in T, we may still maintain the Partial Hull\nTree with the previous root-to-leaf update strategy.\n\nImplicit bridges In a Partial Hull Tree T, the\nleaves store the values in PY, sorted by x-coordinate.\nI.e., we store the values of Yin the leaves of Tin\ntheir stored order. For a node vwith children x\nand y, the bridge e+(v) is the bridge between the\nconvex hulls CH+(π(x)) and CH+(π(y)). For a bridge\ne+(v), we can no longer store the endpoints of the\nbridge explicitly: as the x-coordinate of all bridges may\nradically change after an update in Y. We define the\nimplicit bridge ε+(v) which stores only the two values\n(y1, y2) corresponding to the endpoints of e+(v). At this\npoint, we wish to note that we can easily maintain the\nPartial Hull Tree using implicit bridges with a factor\nO(logn) overhead. Indeed, we may run any of the two\nproposed algorithms. Whenever we need to consider a\nbridge α=e+(x), we can get the corresponding values\n(y1, y2) from the implicit bridge. Then, we may perform\na binary search over Yto obtain their corresponding\nranks. Thus, at O(logn) overhead, we always have\nexplicit access to the endpoints of α.\nIn Appendix B we show that we can cleverly nav-\nigate Tto avoid this overhead. Our key contribution\nis that we show that we can perform a similar trick\nas for Eilice: performing O(logn) such rank queries\ninO(logn) total time. This gives the first dynamic\nalgorithm for rank-based convex hulls with worst-case\nO(log2n) update time. Our solution has O(logh) query\ntime (used as an extension on OvL) or O(logn) query\ntime (when applied as an extension of Eilice).\n6 Experiments\nIn order to examine the empirical performance of our\ndata structures, we perform a series of tests across\nseveral types of input, comparing the performance of our\nstructure variants with each other, and to state of the\nart implementations of static convex hull algorithms.\nTest environment and implementations. For\nexperiments we consider the following implementations:\nSimplified OvL our simplified Partial Hull Tree struc-\nture using concatenable queues.\nEilice our simplified Partial Hull Tree structure with-\nout concatenable queues.\nCHHN a Java implementation of the original Over-\nmars and van Leeuwen structure [17].\nEddy CGAL implementation of Eddy’s algorithm [21]\n(O(nh) construction time).\nGA CGAL implementation of Andrew’s variant of the\nGraham scan algorithm [1] ( O(nlogn) construction\ntime).\nThe implementations of our data structures are\navailable at [4]. As a robustness check, we have\ncompared the points we have found on the hull to thosefound by static convex hull algorithms implemented in\nCGAL, and verified that they are in agreement.\nWe note that comparing implementations across\nprogramming languages is inherently a dubious task.\nNot only do the languages differ in their approach to\nthings like memory management, which can greatly in-\nfluence practical performance, but in this case, the com-\nparisons are further troubled by the fact that geometric\nrobustness has not been implemented for CHHN . The\ncomparisons between the Java and C++ implementa-\ntions should therefore not be seen as direct performance\ncomparisons, but rather the Java implementation acts\nas an indicator of existing solutions.\nThe experiments are run on a cluster node with an\nIntel Xeon Gold 6226R CPU on a single core at 2.8GHz.\nTest data. We generated four distinct data sets of\n220points each, following Gamby and Katajainen [24]\nwho perform experimental analysis on static convex hull\nalgorithms. The first three categories are from [24], and\nthe last is tailored to measure behaviour when all points\nlie on the convex hull. Recall that hdenotes the number\nof points in CH(P). We consider the following data\nsets:\nUniformly random data each point of Pis drawn\nuniformly at random from a square; thus, the\nexpected number of extremal points is Θ(log n).\nDisk-truncated data where each point is drawn uni-\nformly at random, but only added to Pwhen it lies\nin a pre-specified disk. Here, the expected number\nof extremal points is Θ( n1/3).\nBell data where data is generated according to a nor-\nmal distribution (and thus, we expect Θ(√logn)\nextremal points).\nCircular data where points are sampled from the\nboundary of a pre-specified disk; i.e. every data\npoint belongs to the hull.\nFor the uniformly random and Bell data points, we\nfollow the specifications of [24]. For the disk-truncated\nand circular points, we consider disks of radius 1000\ncentered at (0 ,0). We note that in all cases, contrary\nto Gamby and Katajainen [24], we do not restrict the\npoints to have integer coordinates. This restriction\nserved to avoid correctness issues that can arise in\npractice when comparing floating point values of finite\nprecision. Integration with the CGAL geometry kernel\nallows us to circumvent these geometric robustness\nissues, at some cost of performance, opening up for use\nin applications that do not allow for such a restricted\ninput.\nExperiments. The contribution of this work is\nan updatable, queriable convex hull implementation for\ntwo-dimensional and rank-based datasets. We thus test\n\nfor the following categories:\nDynamic construction a simulated dynamic sce-\nnario in which we construct the hull of a point set\nby repeated extension.\nExtension the time it takes to extend the point set P\nwith an additional point set and obtain the convex\nhull of their union.\nQueries the time it takes to perform a sequence of\npoint-containment queries on an existing hull.\nUpdates the time it takes to perform an interspersed\nsequence of insertions and deletions on an existing\nhull.\nThe dynamic construction test serves to emulate\nbehaviour one might encounter in a typical dynamic\nsetting. The hull is repeatedly extended, so that queries\ncan be answered often on the current state of the\nhull. This brings a clear disadvantage to the static\nalgorithms, and thus we examine how various rates of\nextension affect their performance.\nFor extensions, the static algorithms simply rebuild\nthe hull. This is to determine if the dynamic variations\ncan compare to simply rebuilding the hull using a static\nalgorithm, eliminating the need for a dynamic structure\nin cases where queries are needed on an irregular basis.\nEach measurement of extension adds 50 ,000 new points,\nwhile each set of updates consists of 1000 updates split\nevenly between insertions and deletions. There is no\noverlap between inserted and deleted points, and the\norder of updates is random, emulating the updates\npattern one might encounter in practical applications.\nDue to the speed at which queries can be an-\nswered, we for each measurement perform 220queries\nfor points chosen according to a uniform distribution\nover a bounding box of the area in which the full test\ndata resides.\nResults and discussion. For ease of readability,\nwe highlight only tests on specific data sets. The\nremainder can be found in Appendix E, and the raw\nresults can be found in [4].\nIn Figure 8 we show the dynamic construction test\nusing 500 point extensions. At roughly a million points\nand forward we see that exact Eilice beats the static\nvariations, while the inexact implementations take over\nsooner.\nIn practical applications, one’s access pattern might\nrequire access to the hull more often than once every 500\nupdates. For a scenario with access every 50 updates we\nget the results seen in Figure 9 where the clear benefit\nof a dynamic structure can be seen.\nTo explicitly showcase the difference in performance\nwhen comparing exact and inexact implementations, we\nshow in Figure 7 the extension time on uniform data.\nFigure 7: Extension time on uniform data.\nFigure 8: Dynamic construction time using 500 point\nextensions on uniform data.\nWhat should be noted here is the gap between the inex-\nact and exact data structures. Replacing simple floating\npoint comparisons with more robust and involved oper-\nations takes a large toll on performance. This is perhaps\nnot surprising, but it is necessary if one wants to guar-\nantee correct comparisons, and thus correct behaviour.\nWe also show the time spent extending the rank-ordered\nimplementation. This is because rank-ordered integers\navoid some of the pitfalls of geometric robustness, and\nthus fall into a similar category as the inexact imple-\nmentations. Of note is that the rank-ordered imple-\nmentation has to do additional bookkeeping, placing it\nsomewhat in the middle of the extremes. We also note\nthe logarithmic nature of the exact dynamic implemen-\ntations. The jagged curve of CHHN does not stem from\n\nFigure 9: Dynamic construction time using 50 point\nextensions on uniform data.\nthe usage of an amortized structure, but rather the Java\nlanguage’s built-in garbage collector periodically per-\nforming memory cleaning. The static algorithms have a\nlarge advantage here, requiring a single reconstruction\nfor every 50 ,000 insertions, placing them far ahead of\nmost of the competition.\nTo clarify the behaviour of extension we also show\nin Figure 10 the behaviour excluding the exact dynamic\nimplementations. Although tempting to simply claim\nthat our simplification causes a speedup of an order\nof magnitude compared to the regular Overmars and\nvan Leuween structure, the difference here between Java\nand C++ muddles any conclusions. Here it is also\nclearer that the static algorithms have super-logarithmic\ngrowth, however, the constants associated with the\nexact implementations mean that data has to grow\nmuch larger for the exact dynamic implementations to\nextend faster.\nFor the queries, we specifically consider the circular\nand uniform random data. Recall that the expected\nnumber of points on the hull of the uniform data, h, is\nO(logn) for this point set. The benefit of maintaining\nconcatenable queues is that they provide the ability\nto answer queries in O(logh) time rather than worst-\ncase O(logn). In Figure 11, however, we see that\nthe Eilice algorithm obtains similar performance to\nthe simplified OvL solution, even whilst not having\nconcatenable queues. This behaviour can be explained\nas follows: the Eilice query algorithm considers an edge\ne+(v) = αon the upper convex hull. Then, Eilice\neither outputs the correct answer or considers the left\n(or right) child xofv. If the Eilice algorithm does\nnot output the correct answer, there exist two cases.\nEither the bridge e+(x) is also on the convex hull, or\nFigure 10: Extension time on uniform data of select\nimplementations.\nthex-coordinate of e+(x) succeeds the left endpoint of\nα. The Eilice algorithm makes a comparison that the\nsimplified OvL does not make, only in the latter case.\nDue to how the tree is defined and constructed, that\ncase is rare. Thus, in practice, the Eilice and simplified\nOvL algorithms oftentimes execute the same decision\ntree before reaching the desired output (even though\nEilice has a worse worst-case guarantee).\nFor the update measurements, shown in Figure 12,\nwe again see the logarithmic behaviour for both dynamic\nalgorithms. As expected, Eilice beats simplified OvL\nby virtue of not having the overhead associated with\nmaintaining concatenable queues.\nOur experiments highlight several key points when\ndeciding what algorithms to employ for dynamic convex\nhulls in practice. If geometric robustness is not neces-\nsary, one can achieve much greater performance. This\nmight be the case in applications that accept erroneous\nqueries, in which data is inherently already unreliable,\nor where data happens to be distributed enough that\nerrors become unlikely. As an example of the latter,\nthe uniform random data set was correctly handled by\nthe inexact data structures, while the circular data was\nmuch more prone to precision errors.\nIf geometric robustness is necessary, but queries can\nbe relegated to infrequent batches, static recomputa-\ntions might be preferred, if the queries are infrequent\nenough or the data sizes are large enough.\nIf both geometric robustness and dynamic be-\nhaviour is required, or data is rank-based, Eilice is the\nclear winner. While leaving out the concatenable queues\ngives worse worst-case guarantees, it requires an adver-\nsarial query pattern for the overhead of Eilice to become\nworse.\n\nFigure 11: Query time on circular and uniform data.\nTo conclude: We simplify the bridge-finding pro-\ncedure of Overmars and van Leuween, by a clever change\nfrom vertex based to edge-based computations. This\nsimplification leads to much less error-prone implemen-\ntations, at no practical cost. We implement and test\nour simplified data structure, along with an additional\ntrade-off between queries and updates, by leaving out\nconcatenable queues. The implementations are publicly\navailable at [4]. We examine the practical implications\nof these simplifications, providing insight into not only\nhow our structure performs, but also what factors one\nshould consider when employing a dynamic convex hull\ndata structure, with guidance for various use cases.\nFinally, the simplified algorithm also easily ex-\ntends to rank-ordered data, accommodating updates\nand queries in polylogarithmic time, thus giving the first\ndata structure for dynamic maintenance of convex hulls\nof rank-ordered data with non-trivial update bounds.\nFigure 12: Time spent on an interspersed sequence of\n500 insertions and 500 deletions on an existing convex\nhull on uniform data.\nReferences\n[1] A. M. Andrew. Another efficient algorithm for convex\nhulls in two dimensions. Inf. Process. Lett. , 9(5):216–\n219, 1979.\n[2] Alex M Andrew. Another efficient algorithm for con-\nvex hulls in two dimensions. Information Processing\nLetters , 1979.\n[3] Manos Athanassoulis and Anastasia Ailamaki. Bf-tree:\napproximate tree indexing. Proceedings of the 40th\nInternational Conference on Very Large Databases ,\n2014.\n[4] Anonymous authors. Dynamic Convex Hull imple-\nmentations. https://anonymous.4open.science/r/\nDynamicConvexHull-1E62/ , 2023.\n[5] C Bradford Barber, David P Dobkin, and Hannu Huh-\ndanpaa. The quickhull algorithm for convex hull. Tech-\nnical report, Technical Report GCG53, The Geometry\nCenter, MN, 1993.\n[6] Michael A Bender, Erik D Demaine, and Martin\nFarach-Colton. Cache-oblivious b-trees. Proceedings\n41st Annual Symposium on Foundations of Computer\nScience , 2000.\n[7] Kristin P Bennett and Erin J Bredensteiner. Geometry\nin learning. MAA NOTES , 2000.\n[8] Antoine Bordes and L´ eon Bottou. The huller: a simple\nand efficient online svm. In Machine Learning: ECML\n2005: 16th European Conference on Machine Learning,\nPorto, Portugal, October 3-7, 2005. Proceedings 16 ,\npages 505–512. Springer, 2005.\n[9] Gerth Stølting Brodal and Riko Jacob. Dynamic pla-\nnar convex hull. The 43rd Annual IEEE Symposium on\nFoundations of Computer Science, 2002. Proceedings. ,\n2002.\n\n[10] Chee-Yong Chan and Yannis E Ioannidis. Bitmap in-\ndex design and evaluation. Proceedings of the 1998\nACM SIGMOD international conference on Manage-\nment of data , 1998.\n[11] Timothy M Chan. Optimal output-sensitive convex\nhull algorithms in two and three dimensions. Discrete\n& Computational Geometry , 1996.\n[12] Timothy M Chan. Dynamic planar convex hull oper-\nations in near-logarithmic amortized time. Journal of\nthe ACM (JACM) , 2001.\n[13] Timothy M Chan. Three problems about dynamic\nconvex hulls. Proceedings of the twenty-seventh annual\nsymposium on Computational geometry , 2011.\n[14] Yuan-Chi Chang, Lawrence Bergman, Vittorio\nCastelli, Chung-Sheng Li, Ming-Ling Lo, and John R\nSmith. The onion technique: Indexing for linear\noptimization queries. ACM SIGMOD International\nConference on Management of data , 2000.\n[15] Asdr´ ubal L´ opez Chau, Xiaoou Li, and Wen Yu. Con-\nvex and concave hulls for classification with support\nvector machine. Neurocomputing , 2013.\n[16] Yun Chi, Hakan Hac´ ıg¨ um¨ u¸ s, Wang-Pin Hsiung, and\nJeffrey F Naughton. Distribution-based query schedul-\ning. Proceedings of the VLDB Endowment , 2013.\n[17] Yun Chi, Hakan Hac´ ıg¨ um¨ u¸ s, Wang-Pin Hsiung, and\nJeffrey F Naughton. Java implementation convex\nhull. https://github.com/yunchi/Dynamic_Convex_\nHull, 2013.\n[18] Yun Chi, Hyun Jin Moon, and Hakan Hacig¨ um¨ u¸ s.\nicbs: incremental cost-based scheduling under piece-\nwise linear slas. Proceedings of the VLDB Endowment ,\n4(9):563–574, 2011.\n[19] Jose Alberto Cisneros. Maintenance of the convex hull\nof a dynamic set. Master’s thesis, 2007.\n[20] David Crisp and Christopher J Burges. A geometric\ninterpretation of v-svm classifiers. Advances in neural\ninformation processing systems , 1999.\n[21] William F. Eddy. A new convex hull algorithm for\nplanar sets. ACM Trans. Math. Softw. , 3(4):398–403,\n1977.\n[22] Paolo Ferragina and Giorgio Vinciguerra. Learned\ndata structures. Recent Trends in Learning From Data:\nTutorials from the INNS Big Data and Deep Learning\nConference (INNSBDDL2019) , 2020.\n[23] Paolo Ferragina and Giorgio Vinciguerra. The pgm-\nindex: a fully-dynamic compressed learned index with\nprovable worst-case bounds. Proceedings of the VLDB\nEndowment , 2020.\n[24] Ask Neve Gamby and Jyrki Katajainen. Convex-hull\nalgorithms: Implementation, testing, and experimen-\ntation. Algorithms , 2018.\n[25] Xu Gao and Fusheng Yu. Trajectory clustering using\na new distance based on minimum convex hull. 2017\nJoint 17th World Congress of International Fuzzy Sys-\ntems Association and 9th International Conference on\nSoft Computing and Intelligent Systems (IFSA-SCIS) ,\n2017.\n[26] Thomas Giorginis, Stefanos Ougiaroglou, GeorgiosEvangelidis, and Dimitris A Dervos. Fast data reduc-\ntion by space partitioning via convex hull and mbr com-\nputation. Pattern Recognition , 2022.\n[27] Ronald L. Graham. An efficient algorithm for deter-\nmining the convex hull of a finite planar set. Informa-\ntion Processing Letters (IPL) , 1972.\n[28] Sun-Young Ihm, Ki-Eun Lee, Aziz Nasridinov, Jun-\nSeok Heo, and Young-Ho Park. Approximate convex\nskyline: a partitioned layer-based index for efficient\nprocessing top-k queries. Knowledge-Based Systems ,\n2014.\n[29] MA Jayaram and Hasan Fleyeh. Convex hulls in image\nprocessing: a scoping review. American Journal of\nIntelligent Systems , 2016.\n[30] Hamid Reza Khosravani, AE Ruano, and Pedro M\nFerreira. A convex hull-based data selection method\nfor data driven models. Applied Soft Computing , 2016.\n[31] David G Kirkpatrick and Raimund Seidel. The ulti-\nmate planar convex hull algorithm? SIAM journal on\ncomputing , 1986.\n[32] Tim Kraska, Alex Beutel, Ed H Chi, Jeffrey Dean, and\nNeoklis Polyzotis. The case for learned index struc-\ntures. Proceedings of the 2018 international conference\non management of data , 2018.\n[33] Luca Liparulo, Andrea Proietti, and Massimo Panella.\nFuzzy clustering using the convex hull as geometrical\nmodel. Advances in Fuzzy Systems , 2015.\n[34] Kaiqi Liu and Jianqiang Wang. Fast dynamic vehicle\ndetection in road scenarios based on pose estimation\nwith convex-hull model. Sensors , 2019.\n[35] Dragos D Margineantu and Thomas G Dietterich.\nPruning adaptive boosting. ICML , 1997.\n[36] Michael E Mavroforakis, Margaritis Sdralis, and Ser-\ngios Theodoridis. A novel svm geometric algorithm\nbased on reduced convex hulls. 18th International Con-\nference on Pattern Recognition (ICPR’06) , 2006.\n[37] Kyriakos Mouratidis. Geometric approaches for top-k\nqueries [tutorial]. 2017.\n[38] George Ostrouchov and Nagiza F Samatova. On\nfastmap and the convex hull of multivariate data: to-\nward fast and robust dimension reduction. IEEE trans-\nactions on pattern analysis and machine intelligence ,\n2005.\n[39] Mark H Overmars. The design of dynamic data\nstructures . Springer Science & Business Media, 1983.\n[40] Mark H Overmars and Jan van Leeuwen. Dynamically\nmaintaining configurations in the plane (detailed ab-\nstract). Proceedings of the twelfth annual ACM Sym-\nposium on Theory of Computing , 1980.\n[41] Rasmus Pagh and Flemming Friche Rodler. Cuckoo\nhashing. Journal of Algorithms , 2004.\n[42] Hongchao Qin, Rong-Hua Li, Ye Yuan, Guoren Wang,\nLu Qin, and Zhiwei Zhang. Mining bursting core\nin large temporal graphs. Proceedings of the VLDB\nEndowment , 2022.\n[43] Jun Rao and Ross. Kenneth. Cache conscious indexing\nfor decision-support in main memory. Conference on\nVery Large Data Bases (VDLB) , 1999.\n\n[44] J¨ org Sander, Martin Ester, Hans-Peter Kriegel, and\nXiaowei Xu. Density-based clustering in spatial\ndatabases: The algorithm gdbscan and its applications.\nData mining and knowledge discovery , 1998.\n[45] Di Wang, Hong Qiao, Bo Zhang, and Min Wang. On-\nline support vector machine based on convex hull ver-\ntices selection. IEEE transactions on neural networks\nand learning systems , 2013.\n[46] Tom F Wilderjans, Eva Ceulemans, and Kristof Meers.\nChull: A generic convex-hull-based model selection\nmethod. Behavior research methods , 2013.\n[47] Da Yan, Zhou Zhao, and Wilfred Ng. Efficient algo-\nrithms for finding optimal meeting point on road net-\nworks. Proceedings of the VLDB Endowment , 2011.\n[48] Bo Yuan and Chew Lim Tan. Convex hull based skew\nestimation. Pattern Recognition , 2007.\ny\nz\nx\n(a)\n(b)\nα∈E(x)\nα=e+(w)\n2\n1Figure 13: (a) A node vwith children xandy. We\nshow the medians as vertices with the same colour as\nthe corresponding node.\nA Eilice: updates without c-queues\nThe update algorithm OvL has three components that\nmake it practically less efficient:\n•It traverses the path ρinTtwice: once top-down\nto ensure that we can compute for all v∈ρthe tree\nE(v), and once bottom-up to compute the bridges.\n•It stores points in Pmultiple times (both in Tand\nin the c-queues) requiring either double the space\nor pointers that point to non-contiguous data.\n•It uses the split and join operations on binary trees.\nAlthough these have O(logn) theoretical running\ntime, are very inefficient in practice.\nIn this subsection, we show that we may avoid\nmaintaining c-queues and these downsides by navigating\nonlyT. As a result, we obtain different outputs than the\nOvL algorithm. We no longer are able to store CH(P)\nin a balanced binary tree. Instead, we ensure that at all\ntimes we can report the hpoints on CH(P) inO(hlogn)\ntime. In addition, we show that we facilitate convex hull\nqueries in O(logn) time as opposed to O(logh) time.\nKey definitions. Definition 4 gives the definition\nof our data structure: the Partial Bridge Tree T(PBT).\nLetv∈Tbe an internal node, then per definition, vhas\ntwo children. The median med(v) is the leftmost point\nin the subtree of the right child of v(see Figure 13 (a) ).\nOur key observation is that for every node v: the bridge\ne+(v) (when projected onto the x-axis) is an x-interval\nthat contains med(v):\nLemma A.1. Letvbe a node in Tandebe the corre-\nsponding bridge. Then e+(v)either has med(v)as its\nright endpoint or has two endpoints that precede and\nsucceed med(v), respectively.\nProof. Letvhave children xandy. The lemma follows\nfrom the fact that med(v) is the leftmost point in π(y),\nall points in π(x) precede med(v), and e+(v) = (a, b)∈\nπ(x)×π(y).\nWe may use this lemma, together with the following\nobservation to obtain an equivalent to Corollary 3.1:\n\nObservation 1. Letw∈Tand denote by α=\ne+(w) = ( a, b). For any vertex lin the left subtree un-\nderwwith bridge γ=e+(l), there are two cases (see\nFigure 13(b)):\n1. The left endpoint of γsucceeds a. Then all bridges\nin the right subtree of lare either not on E(x)(as\nthey are ‘covered’ by α) or also succeed a.\n2. The right endpoint of γprecedes a. Then γ∈E(x).\nLemma A.2. Letv∈Thave children xandy. Re-\ncall that E(x)andE(y)are the convex hull edges of\nCH+(π(x))andCH+(π(y))in their cyclical ordering.\nGiven edges α=e+(x)andβ=e+(y), we may compute\nthe bridge e+(v)inO(logn)time (Algorithm 2+3).\nProof. We no longer have access to E(x) and E(y) as\nbalanced binary trees. In Algorithm 2, we consider\nedges ( α, β)∈E(x)×E(y) and we use Lemma 3.2\nto decide whether the bridge endpoints e+(v) precede\nor succeed α. Suppose that the left endpoint of e+(v)\nprecedes α(all other scenarios are symmetrical). Then,\nwe replace αby an edge α′∈E(x) that precedes α. In\nSection 3, we obtain α′by simply replacing αwith its\nleft child in the balanced binary tree on E(x).\nSince we no longer have this binary tree, for any\nedge α∈E(x) its left child (or right child) is no longer\nwell-defined. Thus all code lines that say α.leftChild\n(orα.rightChild) were no longer well-defined. However,\nfor all α∈E(x) there exists a node w∈Twhere\nα=e+(w). We now note that Algorithm 3 gives us\nan edge α′preceding αonE(x).\nThis leads to a simple alteration of Algorithm 2.\nNote that the function α.rightChild() can be defined\nanalogously. We replace all calls:\n•α.leftChild by α.leftChild(),\n•β.leftChild by β.leftChild(),\n•α.rightChild by α.rightChild(),\n•β.rightChild by β.rightChild().\nIn each iteration of the while loop, either αis a leaf\ninTor an edge on E(x). We may call invoke the function\nleftChild() at most O(logn) times until we reach a leaf\nofT. Thus, Algorithm 2 terminates in O(logn) time\nand computes the bridge e+(v).\nAlgorithm 3 α.leftChild() for α=e+(w) and α∈E(x)\n1:l←the left child of winT\n2:γ←e+(l)\n3:ifγ.x succeeds α.xthen\n4:return l.leftChild()\n5:return (e+(l),l)Lemma A.3. Given the Partial Bridge Tree T, we can\nreport the hedges on CH+(P)inO(hlogn)time.\nProof. This lemma follows almost immediately from\nObservation 1 and the leftChild() and rightChild()\nfunctions. Indeed, let rbe the root of T, then\ne+(r) = α∈E(r) = CH+(P). We recursively in-\nvoke e+(r).leftChild () to obtain an edge β∈CH+(P).\nAll edges of CH+(P) in between αandβ=e+(w),\nper definition succeed αand precede β. Thus, we may\nrecurse into the right subtree of wto obtain vertices\nx∈T. We may again apply Observation 1 to note that\nife+(x)∈CH+(P) if and only if it precedes βand suc-\nceeds α. This way, each time we explore a new subtree in\nTwe find at least one edge of CH+(P). Since our func-\ntion recurses at most O(logn) times before it reaches\na leaf of Tand thus we output CH+(P) inO(hlogn)\ntime.\nUpdate algorithm. Letpbe a point that is\ninserted or deleted in P. We restore the Partial Bridge\nTree as follows: we do a root-to-leaf traversal in Tto\nthe leaf lthat contains p: spending O(1) time per node.\nFor deletions, we may avoid this by following a pointer\nto the leaf in T. Denote by ρthe path from lto the\nroot of T. For all v∈ρ, bottom-up, we use Lemma A.2\nto compute e+(v) and this restores the Partial Bridge\nTree. Thus, we have an O(log2n) update algorithm to\nmaintain our Partial Bridge Tree.\nA.1 Supporting queries What remains is to show\nthat our data structure can answer Queries (1)-(6) in\nO(logn) time. The standard algorithms to answer these\nqueries assume access to a balanced binary tree E(r)\nthat stores the upper convex hull edges in their sorted\norder. Each of these algorithms subsequently does the\nfollowing: they consider an edge α∈E(r). They can\neither answer the query immediately using αor discard\nall edges of the convex hull preceding or succeeding α.\nDoing this for both the upper and lower convex hull\nallows queries can be answered in O(logh) time where\nhis the number of edges in E(r). Using Algorithm 3\nto navigate Tinstead of E(r) allows our approach to\nimmediately answer queries in O(logn) time instead.\nTo illustrate this, we show how to answer Query (4):\ndeciding whether a query point qlies in CH(P).\nLemma A.4. Letqbe an arbitrary query point in R2.\nUsing our data structure we can test if q∈CH(P)using\nour Partial Hull Tree in O(logn)time.\nProof. Note that qlies in CH(P) if and only if it\nlies in both CH+(P) and CH−(P). The point qlies\ninCH+(P) if and only if there exists a unique edge\n\nγ∗∈E(r) where: qsucceeds the left endpoint of γ∗,q\nprecedes the right endpoint of γ∗. Moreover, qmust lie\nbelow the line through γ∗. Denote by rthe root of the\nPartial Hull Tree.\nPer definition, e+(r)∈E(r). Set α←e+(r) We test\ninO(1) time whether qsucceeds the left endpoint of α\nand precedes the right endpoint of α, If both conditions\nare true then γ∗=α, we output whether qis below\nthe line through α. Ifqprecedes the left endpoint of α\nthen γ∗must precede αon the upper convex hull. Thus,\nwe may step left from αusing Algorithm 3. It follows\nthat in O(logn) steps, we find γand answer the query\naccordingly.\nMaintaining our data structure, with the above\nquery algorithms, implies the following theorem:\nTheorem A.1. LetPbe a two-dimensional point set.\nWe can store Pin an O(n)size data structure with\nO(log2n)worst-case time per update such that we may\nreport the hedges on CH(P)inO(hlogn)worst-case\ntime. Moreover, we support all convex hull queries in\nO(logn)worst-case time.\nB Ranked-based convex hulls\nIn this section, we consider rank-based convex hulls. Let\nYbe a set of values, where the rank of y∈Yis its\nindex in the sorted order. We denote by PYthe two-\ndimensional point set that is obtained by mapping each\nvalue in Yto (rank ,value ) and wish to dynamically\nmaintain CH(PY). The problem in this setting is that\nafter inserting into or deleting from Y, the x-coordinate\nofO(n) points in PYchanges. Changing a value ymay\nchange CH(PY) byO(n) edges, even if yitself was not\non the convex hull (Figure 14). The key observation\nto maintaining the convex hull in this setting is the\nfollowing. After updating an element y∈Ya bridge\ne+(v) = (a, b) in the Partial Hull Tree is updated if and\nonly if yis in the subtree rooted at v. That is, if yis\nnot in the subtree rooted at vthen the x-coordinates\nof (a, b) may both increase or decrease by one, but the\nbridge e+(v) remains a segment between the same two\nvalues. Since the convex hull is implied by the set of\nall bridges in T, we may still maintain the Partial Hull\nTree with the previous root-to-leaf update strategy.\nImplicit bridges In a Partial Hull Tree T, the\nleaves store the values in PY, sorted by x-coordinate.\nI.e., we store the values of Yin the leaves of Tin\ntheir stored order. For a node vwith children x\nand y, the bridge e+(v) is the bridge between the\nconvex hulls CH+(π(x)) and CH+(π(y)). For a bridge\ne+(v), we can no longer store the endpoints of the\nbridge explicitly: as the x-coordinate of all bridges may\nradically change after an update in Y. We define theimplicit bridge ε+(v) which stores only the two values\n(y1, y2) corresponding to the endpoints of e+(v). At this\npoint, we wish to note that we can easily maintain the\nPartial Hull Tree using implicit bridges with a factor\nO(logn) overhead. Indeed, we may run any of the two\nproposed algorithms. Whenever we need to consider a\nbridge α=e+(x), we can get the corresponding values\n(y1, y2) from the implicit bridge. Then, we may perform\na binary search over Yto obtain their corresponding\nranks. Thus, at O(logn) overhead, we always have\nexplicit access to the endpoints of α.\nIn the remainder of this section we show that we\ncan cleverly navigate Tto avoid this overhead. To this\nend, we recall that for a vertex vits median med(v)\nwas the leftmost child in the right subtree rooted at\nv. We define the widths ω+\n1(v) (and ω+\n2(v)) to be the\nrank-difference between y1andmed(v) (and y2and\nmed(v)). Finally, we denote ω(e+(x)) =ω+\n1(v)+ω+\n2(v).\nSee Figure 14(b) for an example. In our Partial Hull\nTree, we now require that each v∈Tstores the size\nof its subtree, a pointer to the median of v med (v),\nand two implicit bridges ε+(v), ε−(v) plus their widths\nω+\n1(v), ω+\n2(v), ω−\n1(v), ω−\n2(v). We note:\nLemma B.1. Letv∈T, and denote by rthe rank of\nmed(v). Given randv, we can compute the bridge\ne+(v)inO(1)time.\nProof. Thex-coordinate of the left endpoint of e+(v) is\nsimply rminus ω+\n1(v). The x-coordinate of the right\nendpoint of e+(v) isrplusω+\n1(v). The y-coordinates of\nboth endpoints are stored in the implicit bridge ε+(v).\nB.1 Updates using c-queues Recall that for any\nv∈T,E(v) was a balanced binary tree on the convex\nhull edges CH+(π(v)) in their cyclical ordering. If\nvhad a child x, then the concatenable queue E∗(x)\nwas defined as the balanced binary tree E(X)\\E(v).\nWe now define E(v) and E∗(x) analogously, where the\ninner nodes of the balanced binary trees store implicit\nedges bridges instead. Moreover, we demand that every\nα∈ E(x) stores the sum over all its descendants β\nofω(β). Note that these sums can be maintained at\n(a)\n(b)\nω+\n1(v)\nω+\n2(v)\nFigure 14: (a) A set Yof values, mapped to PY.\nDeleting the blue value adds O(n) edges to CH(PY).\n(b) The bridge e+(v), the vertex med(v) as a square\nand the corresponding widths.\n\nO(logn) time per insertion, deletion, split or join in\nthe tree. Moreover, for each tree rotation, these sums\ncan be updated in O(1) time. When storing the convex\nhull for rank-ordered data, we demand that each node\nv∈Tstores E∗(v); with the aforementioned sums in\neach node.\nLet us insert or delete a value y∈Y. The update\nalgorithm consists of three components which we will\nexplain in order:\n•an initialization over the root-to-leaf traversal in T\ntoy,\n•a bubble-up update strategy, where we compute\nfor each node von the leaf-to-root path the new\nbridge e+(v). We compute the bridge with its exact\ncoordinates; from which we will derive ε+(v) and\nthe widths in O(1) time. Finally,\n•a search algorithm to recompute for vthe bridge\ne+(v).\nTraversing down. We start at the root rwhere\nE∗(r) =E(r). We do a root-to-leaf traversal to y. For\neach node vthat we encounter, we store the rank of\nmed(v). We assume that as we arrive at a node v, we\nhaveE(v) as a balanced binary tree. Let y∈π(x) for\nthe left child xofv. We invoke splitHull( x,E(v)), store\nER(v) inv. We compute E(x) from the result of splitHull\nand recurse.\nBubbling up. In the leaf lthat contains y, the\nbridge e+(l) equals ( y, y) and med(l) =y. We then\nconsider each node von the leaf-to-root path from lin\nT. Note that we have stored the rank rofmed(v) Using\nr,E(x), and ER(v), we recompute e+(v). From e+(v)\nandr, we compute ε+(v) and the corresponding widths.\nThis allows us to compute E(v) and continue upwards\ninT. If our update requires us to rotate vinT, we\nrecompute the bridge of all rotating nodes.\nRecomputing bridges. Given a node v∈T, the\nrank rofmed(v),E(x), and ER(v) we do as follows.\nDenote by xthe left child of vand by zthe right child\nofv. From r, we can compute the ranks of med(x)\nandmed(z) inO(1) time. Given ER(v) we can compute\nE(z) from E∗(z) using a single join operation. The root\nofE(x) isα′=ε+(x). We apply Lemma B.1 to compute\nα=e+(x) inO(1) time. Similarly, we obtain β=e+(z)\ninO(1) time. It follows that we may apply Lemma 3.2.\nSuppose that the Lemma indicates that we may\ndiscard the subtree of E(x) right of α. Let γ=e+(w)\nbe the left child of α(for some w∈T). Denote by\nγ′=ε+(w) the left child of γ′. The rank of the right\nendpoint of γis equal to the rank of the left endpoint of\nα, minus the width of all edges between γandα. Thus,\nwe may compute the edge γfrom γ′inO(1) time by\nsubtracting the width sum stored in γ. We can performa symmetrical procedure to compute an edge ζ∈E(z)\nand recurse to compute e+(v). Doing this for all v∈T\non the leaf-to-root path from the update implies the\nfollowing theorem:\nTheorem B.1. LetYbe a dynamic set of values. We\ncan maintain the edges of CH+(PY)(stored as implicit\nedges ε(w)) subject to insertions and deletions in Pas\na balanced binary tree E(r)inO(log2n)worst-case time\nper update.\nWhat remains is to show that we can support\nqueries in O(logh) time. Let rbe the root of the Partial\nHull Tree Tand denote by E(r) the corresponding\nconcatenable queue. The root of E(r) is the implicit\nbridge ε+(r). We may maintain the rank of med(r) at\nno additional overhead. Thus by Lemma B.1, we may\ncompute the edge αat the root of E(r) inO(1) time.\nFrom here, we can perform queries in the same way that\nwe find bridges: deciding whether to go into the left or\nright subtree of our current edge in E(r), and computing\nthe explicit edge at the root of the new subtree in O(1)\ntime. It follows that we may answer Queries (1)-(6) in\nO(logh) time (where his the number of edges on the\nconvex hull of PY.\nB.2 The update algorithm without c-queues\nLetv∈Tandrbe the rank of med(v). Finally let\nxbe any child of v. In the previous section we showed\nthat we may compute the rank r′ofmed(x) from rin\nO(1) time by subtracting from (or adding to) rthe size\nof the other subtree of v. By Lemma B.1, we may use r′\nto compute e+(x) from ε+(x) inO(1) time. This implies\nthat by maintaining our new concatenable queues E∗(x),\nwe may run the algorithm of Section A, without any\nadditional overhead (other than maintaining for every\nnode v∈Tthe size of its subtree).\nOur repository also includes implementations for\nmaintaining rank-based convex hulls.\nC Applying Dynamic Convex Hull\nWe review three applications of a dynamic convex hull\nin VDLB.\nQuery scheduling. For the query scheduling\nproblem we consider incoming database queries, which\neach come with associated costs and gains. Efficient\nqueries may be prioritized, whereas expensive queries\nmay even be dropped if they bring too little gain com-\npared to the other current queries. The goal is to pri-\noritize queries to maximize the gains. At VDLB 2011,\nChi, Moon, and Hac´ ıg¨ um¨ u¸ s [18] study this problem, as-\nsuming that the cost/gain function of queries follows a\npiecewise linear function. I.e., the gains of answering\na query diminish piecewise linearly with the response\n\ntime. They present a heuristic optimizer that relies\nupon a dynamic convex hull algorithm. This convex\nhull algorithm maps (dualizes) the piecewise linear func-\ntions to two-dimensional points. Because they work\nwith dualized points, they need to maintain the con-\nvex hull explicitly. They maintain the convex hull using\nthe Overmars and van Leeuwen algorithm. They subse-\nquently can use the convex hull to deduce which queries\nto prioritize. At VDLB 2013, Chi, Hac´ ıg¨ um¨ u¸ s, Hsi-\nung, and Naughton [16] study the same problem, under\nthe assumption that there exists some underlying cost\ndistribution on query time per query type. On a high\nlevel, they design an equation that maps every query q\nto a two-dimensional point which they call their Shep-\nard score. They subsequently want to prioritize queries\nwith critical Shepard scores. To this end, they maintain\nthe Shepard scores (dualized) in the convex hull data\nstructure by Overmars and van Leeuwen. The authors\npresent their own Java implementation to maintain this\nhull, which can be found at [17].\nMining bursty subgraphs In temporal graphs,\neach edge can be represented as a triple ( u, v, t ), where\nu, vare two end nodes of one edge and tdenotes the\ninteraction time between uandv[42]. A time-frame is\nbursty whenever a large number of events occurs in a a\nshort time. In VDLB 2022, Qin, Li, Yuan, Wang, Qin\nand Zhang [42] study the problem of ‘mining’ bursty\npatterns in a temporal graph. They present a dynamic\nprogram, that for every vertex uin the graph computes\nthe cumulative density of a ‘front’ from uin the graph\nGover time. To compute this front, they repeatedly\nrecompute the (lower) convex hull of their function from\nu. This step may be replaced by a dynamic convex hull\nalgorithm.\nPGM index Ferragina and Vinciguerra [23] study\na dynamic sorted set of values Ysubject to rank queries.\nThey map Yto the point set PYand choose some\nε > 0. A segment s ε-covers a consecutive set of\nvalues ( y1, . . . , y k) whenever sis within distance εof\nall corresponding points ( p1, . . . , p k). An ε-cover is\na set of segments Sthat together ε-cover all points\ninPY. Denote by mεthe minimal size for an ε-\ncover. The authors present an amortized O(logn)\nalgorithm to maintain an ε-cover. They claim to\nsupport rank queries in O(logn(logmε+ log ε)) time.\nTheir approach (under the hood) maintains the convex\nhull of PYthrough the logarithmic method: splitting\nYover buckets B, and maintaining for the points\nPBa minimal ε-cover (through indirectly maintaining\nCH(PB)). Their approach has the same pitfall as hull\nqueries under the logarithmic method: when Yis split\nover buckets, the complexity CH(PB) (and thereby\nthe complexity of the ε-cover) may significantly exceedthat of CH(PY). Without an algorithm to maintain\nCH(PY) explicitly, their query time is O(logn(logn+\nlogε)).\nD The Logarithmic Method and Convex Hull\nHere we describe the logarithmic technique applied to\nthe convex hull, and why doing so leads to incorrect\nquery algorithms and hulls.\nConsider Punder insertions and Graham’s scan\nalgorithm (which uses O(n) time for a sorted input set).\nWe store Pin buckets Biof 2ielements, where each Bi\nis either full or empty. Denote by π(B)⊂Pthe points\nstored in a bucket B. For each bucket Bwe store the\nconvex hull CH(π(B)) Whenever we insert an element,\nwe insert it in B2. Suppose that an insertion causes B2\nto be full and let the first kbuckets be full. We then\nmerge buckets B2, . . . , B kinto the new bucket Bk+1.\nDuring the merge, we ensure that the new bucket Bk+1\ncontains all values in sorted order in O(2k+1) time by\nthe same procedure as merge sort. Then, we construct\nthe convex hull in O(2k+1) time using Graham’s scan.\nThis procedure has O(logn) amortized update time.\nHowever it does not maintain the convex hull of P, nor\ndoes it answer convex hull queries correctly:\nConsider (Figure 15) a set Pof red and blue points\nwhere the convex hull of Pcontains three points. When\nwe split the convex hull over two buckets (red and blue)\nboth convex hulls contain many points. Moreover, sup-\npose that we query whether a point qlies in CH(P) (the\nblack square). It may be that qis in none of the convex\nhulls CH(Bi), even though it does lie in CH(P). This\ninconsistency causes [23] to store something slightly dif-\nferent from advertised (Appendix C).\n(a)\n(b)\nFigure 15: (a) A point set Pand its convex hull. (b)\nWhen we split Pover two buckets B,B′, the hulls\nCH(π(B)) and CH(π(B′)) have considerably higher\ncomplexity, and don’t contain the black query square.\nE Additional Results\n\nFigure 16: Dynamic construction time using 500 point\nextensions on various distributions.\nFigure 17: Dynamic construction time using 500 point\nextensions on various distributions.\n\nFigure 18: Extension time on various distributions.\n Figure 19: Extension time on various distributions.\n\nFigure 20: Update time on various distributions.\n Figure 21: Update time on various distributions.\n\nFigure 22: Query time on various distributions.\n Figure 23: Query time on various distributions.",
  "textLength": 73820
}