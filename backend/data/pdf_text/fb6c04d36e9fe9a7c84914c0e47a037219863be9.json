{
  "paperId": "fb6c04d36e9fe9a7c84914c0e47a037219863be9",
  "title": "Indexing Temporal Relations for Range-Duration Queries",
  "pdfPath": "fb6c04d36e9fe9a7c84914c0e47a037219863be9.pdf",
  "text": "Indexing Temporal Relations for Range-Duration Queries\nMatteo Ceccarello\nFaculty of Computer Science\nFree University of Bozen-Bolzano, Italy\nmceccarello@unibz.itAnton DignÃ¶s\nFaculty of Computer Science\nFree University of Bozen-Bolzano, Italy\ndignoes@inf.unibz.it\nJohann Gamper\nFaculty of Computer Science\nFree University of Bozen-Bolzano, Italy\ngamper@inf.unibz.itChristina Khnaisser\nFacultÃ© de mÃ©decine et des sciences de la santÃ©\nUniversitÃ© de Sherbrooke, Canada\nchristina.khnaisser@usherbrooke.ca\nABSTRACT\nTemporal information plays a crucial role in many database applica-\ntions, however support for queries on such data is limited. We present\nan index structure, termed RD- INDEX , to support range-duration\nqueries over interval timestamped relations, which constrain both\ntherange of the tuplesâ€™ positions on the timeline and their duration .\nRD- INDEX is a grid structure in the two-dimensional space, repre-\nsenting the position on the timeline and the duration of timestamps,\nrespectively. Instead of using a regular grid, we consider the data\ndistribution for the construction of the grid in order to ensure that\neach grid cell contains approximately the same number of inter-\nvals. RD- INDEX features provable bounds on the running time of\nall the operations, allow for a simple implementation, and supports\nvery predictable query performance. We benchmark our solution\non a variety of datasets and query workloads, investigating both the\nquery rate and the behavior of the individual queries. The results\nshow that RD- INDEX performs better than the baselines on range-\nduration queries, for which it is explicitly designed. Furthermore,\nit outperforms specialized indexes also on workloads containing\nqueries constraining either only the duration or the range.\n1 INTRODUCTION\nTemporal information plays a crucial role in many database appli-\ncations: in fact, many database management systems and the SQL\nstandard [ 27] provide automated version control of the data and\ntime travel facilities, allowing to efficiently access past history. Past\nresearch mainly concentrated on efficient solutions for important\ntemporal operators, such as temporal aggregation [ 9,23,29,33],\ntemporal joins [ 11,15,34], and time travel [ 22] queries. All these\napproaches consider only the position of intervals along the timeline,\nignoring another important aspect, namely the duration of intervals.\nAs a result, index structures to support more general selection queries\nthat constrain both the duration and the position in time of intervals\nhave been missing [ 8,14,27] until recently [ 4]. In many application\ndomains, however, both aspects of temporal information are useful\nto formulate queries.\nExample 1.1. As a concrete use case, consider the use of antibi-\notics in healthcare. Antibiotic resistance is a world challenge, and\nthe emergence of new resistance factors is very difficult to monitor\nand to predict due to the diversity of antibiotic usage and events (e.g.,\nenvironment, species evolution, medical practices, etc.) [ 19,28]. Se-\nlecting the most appropriate antibiotic and the appropriate treatment\nduration is an essential step to reduce antibiotic resistance [ 19]. Thus,defining guidelines for the duration of antibiotic treatments, measur-\ning the adherence to these guidelines, and developing stewardship\ntools regarding antibiotics usage can help clinicians in choosing the\noptimal treatment considering the patientâ€™s medical history [ 28,39].\nSuch measures should be implemented at a national level in order\nto monitor and audit antibiotic resistance on a larger scale. In this\ncontext, the following types of temporal queries are frequent:\nğ‘„1:â€œFind all antibiotics prescriptions from October 1, 2016 to\nMarch 31, 2017. â€\nğ‘„2:â€œFind all antibiotics prescriptions with a treatment duration\nbetween 5 and 8 days. â€\nğ‘„3:â€œFind all antibiotics prescriptions from October 1, 2016 to\nMarch 31, 2017, with a treatment duration between 1 and 2\nweeks. â€\nThe first query ğ‘„1retrieves tuples based on the position of the\nevents on the timeline; we call it range query . In contrast, query\nğ‘„2imposes constraints on the duration of matching events, and we\ncall it duration query . Finally, query ğ‘„3constrains both types of\ninformation; we call it range-duration query . This type of queries\ncan be found and have been reported as a primitive operation in other\napplication scenarios that deal with interval data, e.g., in air traffic\nanalysis [ 5,37,38], event detection for video surveillance [ 32], or\nthe analysis of clinical data [6].\nExisting index structures typically support only one of the two\naspects, either the position of the interval on the timeline or the\nduration of the interval. For instance, the well-known relational\ninterval tree [ 25] is optimized for efficiently determining temporal\nrelationships between intervals but not interval lengths. In the worst\ncase, the entire index tree must be traversed if a query solely contains\nrestrictions on the interval length. Alternatively, the duration of\nthe intervals can be indexed straightforwardly using a classic data\nstructure such as a B-tree. In this case, however, queries constraining\nonly the range of the intervals will need to traverse the entire tree.\nCombining the two indexes is typically inefficient since a query\ncan have different selectivities in the two dimensions. Therefore, to\nefficiently support workloads involving a mix of all three types of\nqueries mentioned above we seek a new index structure that supports\nboth dimensions at the same time.\nIn this paper, we introduce RD- INDEX , a novel two-dimensional\ndata structure that indexes time intervals both on their position on the\ntimeline and their duration. Our index structure partitions the inter-\nvals in a grid according to their start times and durations. Rather than\nconstructing a regular grid, the boundaries between the grid cells arearXiv:2206.07428v1  [cs.DB]  15 Jun 2022\n\nMatteo Ceccarello, Anton DignÃ¶s, Johann Gamper, and Christina Khnaisser\ndetermined by taking into account the data distribution. Such a strat-\negy ensures that each cell contains approximately the same number\nof intervals, with the exception of some edge cases if the distribution\nof the intervals is extremely skewed. The uniform distribution of the\ndata over all grid cells allows to obtain very predictable query times,\nwhich are proportional to the selectivity of the query. We prove that\nthe time for answering a range-duration query with RD- INDEX is\nğ‘‚(ğ‘›\nğ‘ 2logğ‘›\nğ‘ +ğ‘›\nğ‘ +ğ‘ 2+ğ‘˜), whereğ‘›is the size of the input relation,\nğ‘˜is the number of intervals matching the query predicate, and ğ‘ is\nthe page size. The index can be constructed in ğ‘‚(ğ‘›logğ‘›)time. The\npage sizeğ‘ is the only parameter of our index structure, and it is\nindependent of the data distribution. The index structure also lends\nitself to a rather simple implementation. While being explicitly de-\nsigned to address range-duration queries, RD- INDEX also supports\nrange-only and duration-only queries efficiently.\nWe present the results of a detailed experimental evaluation. The\nresults show that the overhead introduced by the data structure is\nindeed negligible and that the running time in practice is largely\nproportional to the selectivity of the query. This is in contrast to the\ncompetitors we compare to. On range-duration queries we find that\nRD- INDEX clearly outperforms the competitors. On mixed work-\nloads comprising all three types of queries, we find that RD- INDEX\noutperforms the competitors in the vast majority of the workloads,\neven for cases for which specialized solutions exist.\nOur contributions can be summarized as follows:\nâ€¢We describe RD- INDEX , a novel index structure that supports\ntemporal queries involving both the duration and the range of\ntime intervals.\nâ€¢We prove bounds on the performance of RD- INDEX , which\ncan be tuned with a single page size parameter ğ‘ .\nâ€¢We provide an extensible open source implementation, which\nwe benchmark against state-of-the-art competitors, showing\nsignificantly better performance across several workloads. In\nparticular, we show how RD- INDEX can efficiently handle\nmixed workloads where all three types of queries coexist.\nThe rest of the paper is organized as follows. In Section 2 we re-\nview the state of the art, before laying out the fundamental concepts\nunderlying our approach in Section 3. Our data structure is intro-\nduced in Section 4, and the complexity of all operations is analyzed\nin Section 5. Experimental results are presented in Section 6, before\ndrawing our conclusions in Section 7.\n2 RELATED WORK\nThe type of selection queries we are studying in this paper are queries\nwith a conjunctive predicate, where one predicate in the conjunction\nrestricts the position of intervals on the time line and the second the\nduration of intervals. In this section, we review indexing structures\nthat are (partially) suitable for such selection queries, and also review\nstructures similar to our approach that are used for interval joins.\nThere are several approaches devoted to indexing interval times-\ntamped data. Edelsbrunnerâ€™s Interval Tree [ 17] is one of the most\npopular indexing structure for intervals. It is asymptotically optimal\nfor selection queries involving the overlap predicate, and there exists\nan implementation using standard relational database technology\nbased on B-tree indexes [ 25]. A shortcoming of the interval tree isthat, in contrast to our indexing structure, it does not provide a mech-\nanism to restrict the duration of intervals, and thus can only solve\none part of a range-duration query. A similar indexing structure is\nthe segment tree [ 7]. It builds disjoint segments over intervals at the\nleaf level using all start and end points in a relation, and recursively\nmerges segments in intermediate nodes of the tree. This data struc-\nture was originally designed for point queries over intervals (also\nknown as time travel queries), i.e., for retrieving all intervals over-\nlapping a given time point. The segment tree also supports selection\nqueries with the overlap predicate given a query interval, albeit in\nthis case a duplicate elimination step for intervals retrieved multiple\ntimes is required. Another index structure that support time travel\nqueries is the timeline index [ 21,22]. The timeline index stores the\nstart and end points of intervals in an event list in sorted order and\nallows to retrieve all tuples that overlap a given time point by scan-\nning through the event list and discarding tuples that ended before\nthe given time point. To avoid scanning through the entire event\nlist, the index maintains regular checkpoints that store all tuples that\noverlap the time point of the checkpoint. Similarly to the interval\ntree, the segment tree and timeline index do not support to restrict\nthe duration of intervals.\nIn a two dimensional space, intervals can be represented as 2D\npoints, where one dimension is the start point and the second dimen-\nsion is either the end point or the duration of an interval. In such\na space, a selection query with the overlap predicate corresponds\nto a selection query over a 2D area. For this, multidimensional in-\ndices can be used. R-trees [ 1,3] are multidimensional indices that\ngroup objects in a multidimensional space using minimum bounding\n(hyper) rectangles. Quadtrees and octrees [ 18,36,40] recursively\ndivide the space into partitions and place objects into the best fit-\nting partition according to some criteria. All of the aforementioned\nindexes are linked data structures, which suffer from poor locality,\nboth when implemented in-memory and on disk. In contrast, our\nRD- INDEX can be implemented by means of simple arrays, and thus\nenjoys high cache locality.\nAnother multidimensional index structure is the grid file [ 31]. In\nthe context of time intervals, the idea would be to partition the span\nof durations and of starting times into cells of equal width, thus\nallowing efficient access to both dimensions. The main drawback\nof this data structure is that in case of skewed data distributions\nthe load of the cells is unequal, which might significantly harm the\nperformance.\nA recent approach to multidimensional indexing is that of learned\nindexes [24]: the proposition is that index structures are models map-\nping keys to records. Therefore machine learning models can be used\nto provide this mapping, in lieu of the classic data structures. In par-\nticular, Flood and Tsunami [ 16,30] use Recursive Model Index [ 24]\nand a variant of decision trees to model the position of records in the\ndatabase, adapting to the distribution of the data and of the query\nworkload. Our approach shares some ideas with this line of work,\nnamely adapting to the data distribution by means of the conditional\ncumulative distribution function. However, while our index supports\nboth insertions and deletions, both Flood and Tsunami are tailored\nat read-only workloads. Furthermore, we prove bounds on the worst\ncase running times for all the operations, while [ 16,30] provide an\nempirical evaluation. Finally, our approach is arguably simpler, in\nthat it is based just on sorting and iterating through records.\n\nIndexing Temporal Relations for Range-Duration Queries\nVery recently, Behrend et al. [ 4] proposed an index, named PERIOD -\nINDEX â˜…, that explicitly supports range-duration queries. The index\npartitions the time domain in buckets . An interval is assigned to all\nbuckets it intersects with. Within each bucket, intervals are further\npartitioned in levels according to their duration, with the minimum\nduration indexed within each level decreasing geometrically. To sup-\nport efficient indexing along the start time dimension, each level is\nfurther partitioned in the time domain. This data structure is adaptive\nto the distribution of start times, while it assumes a Zipf-like distri-\nbution for the duration of the intervals. Our index structure removes\nthis assumption, thus supporting datasets with arbitrary distributions\nof the tuplesâ€™ duration. Furthermore, our index features only one\ndata-independent parameter, instead of the two data-dependent pa-\nrameters of PERIOD -INDEX â˜…, and it allows to control whether to\nindex first by duration or time. Moreover, we do not replicate inter-\nvals in the index, yielding a significantly smaller structure, thereby\navoiding the consequent possible performance degradation. Finally,\nPERIOD -INDEX â˜…does not support updates of the index.\nIn recent years, algorithms for interval joins, which can be seen as\na sequence of range queries, have been actively studied. Approaches\nbased on the timeline index [ 22] process sets of intervals as sorted\nevent lists of their start and end points. The interval join is computed\nby scanning these event lists in an interleaved fashion, thereby keep-\ning and joining sets of active intervals, i.e., intervals whose start has\nbeen encountered but not the end point. To improve the performance\nof the original linked list data structure for storing active intervals, a\ngapless hash map has been proposed in [ 34] that provides a higher\nperformance for scanning active intervals. The same idea has also\nbeen extended for joins using general Allenâ€™s predicates [ 35] rather\nthan only overlap predicates. The works in [ 10,11,15] compute an\ninterval join using sorting and backtracking. First, the input rela-\ntions are sorted by start time and then an interleaving merge-join is\nperformed to compute the temporal join between the two relations.\nOther approaches [ 12,13] for the interval join are based on partition-\ning intervals according to their position and then produce the join\nresult by joining relevant partitions. While all these approaches for\nthe interval join provide mechanisms to join overlapping intervals,\nin contrast to our work they are not applicable for general selection\nqueries as they always require to read the entire relations. Moreover,\nthe duration of intervals is not considered at all in these works.\n3 PRELIMINARIES\nWe assume a linearly ordered, discrete time domain, Î©ğ‘‡. A time\ninterval is a set of contiguous time points, and ğ‘¡=[ğ‘¡ğ‘ ,ğ‘¡ğ‘’)denotes\nthe closed-open interval of points from ğ‘¡ğ‘ toğ‘¡ğ‘’. We use|ğ‘¡|=ğ‘¡ğ‘’âˆ’ğ‘¡ğ‘ \nto denote the duration of time interval ğ‘¡andğ‘¡âˆ©ğ‘¡â€²to denote the set\nof time points shared by two intervals ğ‘¡andğ‘¡â€², which, if not empty,\nis itself an interval. The schema of a temporal relation is given\nbyğ‘…=(ğ´1,...,ğ´ğ‘š,ğ‘‡), whereğ´1,...,ğ´ğ‘šare the non-temporal\nattributes with domains Î©ğ‘–andğ‘‡is the time interval attribute with\ndomain Î©ğ‘‡Ã—Î©ğ‘‡representing, for instance, the tupleâ€™s valid time.\nA temporal relation rwith schema ğ‘…is a finite set of tuples, where\neach tuple has a value in the appropriate domain for each attribute in\nthe schema. We use ğ‘Ÿ.ğ´ğ‘–to denote the value of attribute ğ´ğ‘–in tuple\nğ‘Ÿ, andğ‘Ÿ.ğ‘‡=[ğ‘Ÿ.ğ‘‡ğ‘ ,ğ‘Ÿ.ğ‘‡ğ‘’)to refer to its time interval.The index we propose efficiently supports the three following\ntypes of temporal queries (defined as in [4]).\nDefinition 3.1 (Range query). Given a temporal interval ğ‘¡=\n[ğ‘¡ğ‘ ,ğ‘¡ğ‘’)and a temporal relation r, arange query is defined as\nğ‘„(r,ğ‘¡)={ğ‘Ÿâˆˆr:ğ‘Ÿ.ğ‘‡âˆ©ğ‘¡â‰ âˆ…}\nDefinition 3.2 (Duration query). Given a duration interval ğ‘‘=\n[ğ‘‘ğ‘šğ‘–ğ‘›,ğ‘‘ğ‘šğ‘ğ‘¥]and a temporal relation r, aduration query is defined\nas\nğ‘„(r,ğ‘‘)={ğ‘Ÿâˆˆr:|ğ‘Ÿ.ğ‘‡|âˆˆ[ğ‘‘ğ‘šğ‘–ğ‘›,ğ‘‘ğ‘šğ‘ğ‘¥]}\nDefinition 3.3 (Range-duration query). Given a temporal interval\nğ‘¡=[ğ‘¡ğ‘ ,ğ‘¡ğ‘’), a duration interval ğ‘‘=[ğ‘‘ğ‘šğ‘–ğ‘›,ğ‘‘ğ‘šğ‘ğ‘¥], and a temporal\nrelation r, arange-duration query is defined as\nğ‘„(r,ğ‘¡,ğ‘‘)={ğ‘Ÿâˆˆr:ğ‘Ÿ.ğ‘‡âˆ©ğ‘¡â‰ âˆ…âˆ§|ğ‘Ÿ.ğ‘‡|âˆˆ[ğ‘‘ğ‘šğ‘–ğ‘›,ğ‘‘ğ‘šğ‘ğ‘¥]}\nA range query retrieves all tuples whose time interval intersects\nwith the query range ğ‘¡. A duration query retrieves all tuples whose\ntime interval has a duration that is between ğ‘‘ğ‘šğ‘–ğ‘›andğ‘‘ğ‘šğ‘ğ‘¥. A range-\nduration query is a combination of the former two.\nExample 3.4. As a running example, we consider real-world drug\nprescriptions from the MIMICIII open source database [ 20] (cf. use\ncase in Example 1.1). It stores antibiotic prescriptions, characterized\nby a start date and an end date of the prescription and the duration\nof the treatment. An excerpt of four tuples is shown in Figure 1a.\nConsider the following range-duration query: Retrieve all prescrip-\ntions in the period from June 15 to July 15 with a treatment duration\nbetween 5 and 15 days. Figure 1b shows a graphical representation\nof the relation and the query, where the time intervals are drawn\nby thick solid horizontal lines. The red area indicates the constraint\non the position. The red segment below of each timestamp interval\ndenotes the duration constraint, where the dotted red line indicates\nthe range of minimum and maximum duration. Hence, an interval\nsatisfies the range constraint if it intersects with the red area, and it\nsatisfies the duration constraint if its end point is within the dotted\nred line. Tuple ğ‘Ÿ1satisfies only the duration constraint, tuple ğ‘Ÿ2sat-\nisfies neither constraint, tuple ğ‘Ÿ3satisfies only the range constraint,\nand tupleğ‘Ÿ4satisfies both.\n4 THE RD-INDEX STRUCTURE\n4.1 Overview\nAn interval can be completely described by its starting time and\nduration, alternatively, to its starting and ending time. Therefore,\na set of temporal intervals can be represented as a set of points in\na two dimensional space, with one coordinate being the start time\nand the other the duration. A range-duration query ğ‘„(r,ğ‘¡,ğ‘‘)with\nğ‘¡=[ğ‘¡ğ‘ ,ğ‘¡ğ‘’)andğ‘‘=[ğ‘‘ğ‘šğ‘–ğ‘›,ğ‘‘ğ‘šğ‘ğ‘¥]in such a space is represented by a\npolygon containing all tuples ğ‘Ÿâˆˆrsuch that\n|ğ‘Ÿ.ğ‘‡|âˆˆ[ğ‘‘ğ‘šğ‘–ğ‘›,ğ‘‘ğ‘šğ‘ğ‘¥] (1)\nğ‘Ÿ.ğ‘‡ğ‘’>ğ‘¡ğ‘  (2)\nğ‘Ÿ.ğ‘‡ğ‘ <ğ‘¡ğ‘’ (3)\nExample 4.1. Figure 2 shows a sample of 31 192 drug prescrip-\ntions from the MIMICIII dataset in the two dimensional space, where\n\nMatteo Ceccarello, Anton DignÃ¶s, Johann Gamper, and Christina Khnaisser\ndrug ğ‘‡ğ‘ ğ‘‡ğ‘’ duration\nğ‘Ÿ1Amoxicillin June 08 June 14 (6 days)\nğ‘Ÿ2Amoxicillin June 10 June 12 (2 days)\nğ‘Ÿ3Ceftriaxone June 20 July 05 (15 days)\nğ‘Ÿ4Levofloxacin June 24 July 04 (10 days)\n(a) Sample of relation with antibiotic prescriptions\nğ‘Ÿ2ğ‘Ÿ3ğ‘Ÿ4\nğ‘Ÿ1\nJun 15 Jul 01 Jul 15\n(b) Range-duration query\nFigure 1: Running example.\neach point represents a timestamp interval of a tuple. The red poly-\ngon indicates the query of Example 3.4, i.e., the prescriptions from\nJune 15 to July 15 with a duration between 5 and 15 days. Note that\nthe points are not uniformly distributed, hence efficiently indexing\nthis dataset requires to be adaptive in both the start time and duration\ndimension.\nThe RD- INDEX we are presenting is a two-dimensional grid,\npartitioning the tuples into disjoint buckets according to the start\ntime and the duration of the intervals. The boundaries between cells\nare defined by using the empirical cumulative distribution function of\nthe tuplesâ€™ duration and the starting times, so that each cell contains\napproximately the same number of intervals, which corresponds to\nthepage sizeğ‘ of our index. This allows the index to adapt to the\ndistribution of the input and to different scenarios. In a main memory\nscenario, the parameter ğ‘ could be set such that a cell fits in a cache\nline. In an external memory setting, it might be set to the disk block\nsize.\nTo simplify the presentation, in the following we will focus on\nthe timestamp interval attribute ğ‘‡of relation r: in the discussion we\nassume that each interval being inserted in the index is associated\nwith a reference to the tuple in rit belongs to.\n4.2 Index Construction\nThe grid structure of the RD- INDEX partitions an array of tuples first\nalong either the start time or duration dimension of the intervals, and\nthen along the other. The choice of which dimension to index first\nmay impact the performance of the index, depending on the query\nworkload and the data distribution (cf. Section 6. In the following\nwe assume that the start time dimension is partitioned first, followed\nby the duration dimension. All the descriptions, considerations, and\nproofs also hold with the dimensions swapped.\nBefore describing the algorithm to build the index, we present\nthe subroutine NEXTSUBSEQ , which partitions an array of tuples\nthat is sorted according to a given key function. We will use this\nsubroutine to determine columns and cells of the grid structure, using\nfirst the start time and then duration as keys. Given an index â„and\na size parameter ğ‘,NEXTSUBSEQ returns a subsequence starting\natâ„that either contains at most ğ‘tuples, or contains tuples thatAlgorithm 1: NEXTSUBSEQ(r,â„,ğ‘,ğ‘˜)\nInput: Relation rsorted according to ğ‘˜; current index position â„;\nsubsequence size ğ‘;keyfunctionğ‘˜\nOutput: Subsequence of rstarting from position â„, either of size\nâ‰¤ğ‘or with all tuples having the same key\n1ifâ„+ğ‘â‰¥|r|then\n2 return subsequenceâŸ¨râ„,..., r|r|âˆ’1âŸ©;\n3â„â€²â†â„+ğ‘;\n4ifğ‘˜(râ„)=ğ‘˜(râ„â€²)then\n5 whileâ„â€²<|r|âˆ§ğ‘˜(râ„)=ğ‘˜(râ„â€²)do\n6â„â€²â†â„â€²+1\n7else\n8 whileğ‘˜(râ„â€²âˆ’1)=ğ‘˜(râ„â€²)do\n9â„â€²â†â„â€²âˆ’1\n10return subsequenceâŸ¨râ„,râ„+1,..., râ„â€²âˆ’1âŸ©;\nall share the same key. Additionally, all the tuples with the same\nkey are part of the same subsequence. The pseudocode is reported\nin Algorithm 1 and works as follows. Starting from index position\nâ„, if there are fewer than ğ‘elements after â„then we return all the\ntuples from â„onwards. Otherwise, we look at the tuple at position\nâ„â€²=â„+ğ‘and consider two cases1. If the tuples at position â„andâ„â€²\nhave the same key, then we scan forward until the first tuple with a\ndifferent key occurs (lines 4â€“6). Otherwise, we scan backward until\ntwo consecutive tuples have different keys (lines 7â€“9). In both cases,\nthe rationale is to avoid splitting runs of same-key tuples between\ndifferent subsequences.\nNote that Algorithm 1 might return a subsequence with more than\nğ‘elements if and only if all share the same key. In such case we\ndeem the returned subsequence heavy , otherwise we deem it light.\nExample 4.2. Figure 3 depicts three invocations of NEXTSUBSEQ\non a sequence of sorted start times, with parameter ğ‘=9. The first\njump by 9 positions would split the run of intervals with start time\n13. Therefore, the algorithm iterates back until the first start time\n<13. The second invocation would again split the same run since it\ncontains more than 9 intervals with start time 13. This time, since\nthe endpoints of the jump have the same value, the algorithm iterates\nforward until the last interval with the same start time, thus finding a\nheavy subsequence. The last jump defines the third group.\nWe are now ready to describe the index construction procedure\nBUILD INDEX , which is shown in Algorithm 2. Let ğ‘ be the page\nsizeparameter, and rbe the relation to be indexed. First, we sort r\nby increasing start time. Then, we repeatedly invoke NEXTSUBSEQ\n(line 10) to divide the relation into columns ofğ‘ 2tuples each, based\non their start times. Defining columns in this way allows, intuitively,\nto then further partition each column in ğ‘ cells ofğ‘ elements each2.\nAs a special case, if there are more than ğ‘ 2tuples with the same start\ntime, NEXTSUBSEQ will assign them to the same column, which we\nthen deem heavy . We also keep track of the minimum start time in\neach column using an auxiliary array col_minstart . Similarly,\n1Thereforeâ„â€²is the end index of the subsequence, non-inclusive .\n2We could use two separate parameters to control the number of partitions in the\ntwo dimensions, but using ğ‘ andğ‘ 2makes for a simpler exposition, analysis and\nimplementation.\n\nIndexing Temporal Relations for Range-Duration Queries\n01020304050\nJan Apr Jul Oct Jan\nstartduration\nFigure 2: Drug prescription dataset in the start time/duration plane. The gray dots are tuples. The red polygon is the range-duration\nquery of Example 3.4.\n1 2 4 4 7 8 10 13 13 13 13 13 13 13 13 13 13 13 14 15 16 17 19 21 23\nfirst group second group (heavy) third groupx\n8 4 5 10 9 9 2 3 5 6 7 9 10 11 13 14 15 17 18 4 2 4 5 12 8Start time:\nDuration:\nFigure 3: Partitioning a sequence of intervals sorted by start time using N EXTSUBSEQ with parameter ğ‘=9, with the start time being\nthekey function .\nJan, 01 Mar, 28 May, 25 Jul, 12 Oct, 27 Dec, 15\nApr, 08 Jun, 07 Aug, 08 Oct, 02 Dec, 31 Feb, 14col_minstart:\ncol_maxend:\n01020304050\nJan Apr Jul Oct Jan\nstartduration\nFigure 4: Instantiation of RD- INDEX with page size ğ‘ =70on the example dataset. Above the plot we report the col_minstart and\ncol_maxend arrays.\nthe array col_maxend stores the cumulative maximum end time in\nthe columns, i.e., the maximum end time found so far in the relation.\nBoth of these arrays will be used at query time: the first to find the\nfirst column to inspect for a given query, the second to determinewhen to stop iterating through columns. Note that col_maxend\nrecords the cumulative maximum end time of columns. This ensures\nthat no interval in columns â‰¤ğ‘–ends after col_maxend[i] , which\nwill be useful at query time.\n\nMatteo Ceccarello, Anton DignÃ¶s, Johann Gamper, and Christina Khnaisser\nAlgorithm 2: BUILD INDEX(r,ğ‘ )\nInput: Temporal relation rand page size parameter ğ‘ \nOutput: Gridğºpartitioning rby start time and duration, along with\nauxiliary arrays.\n1gridâ†[][];\n2col_minstartâ†[];\n3col_maxendâ†[];\n4cell_mindurâ†[][];\n5cell_maxdurâ†[][];\n6Sort rby interval start time;\n7â„â†0/*position in r */\n8ğ‘–â†0/*column index */\n9whileâ„<|r|do\n10 columnâ†NEXTSUBSEQ(r,â„,ğ‘ 2,ğ‘Ÿ.ğ‘‡â†’ğ‘Ÿ.ğ‘‡ğ‘ );\n11 col_minstart[i] â†min{ğ‘Ÿ.ğ‘‡ğ‘ :ğ‘Ÿâˆˆcolumn};\n12 col_maxend[i] â†\nmax{col_maxend[i-1] ,{ğ‘Ÿ.ğ‘‡ğ‘’:ğ‘Ÿâˆˆcolumn}};\n13 Sortcolumn by duration;\n14ğ‘˜â†0/*position in column */\n15ğ‘—â†0/*cell index */\n16 whileğ‘˜<|column|do\n17 cellâ†NEXTSUBSEQ(column,ğ‘˜,ğ‘ ,ğ‘Ÿ.ğ‘‡â†’|ğ‘Ÿ.ğ‘‡|);\n18 Sortcell by end time;\n19 grid[i][j]â†cell ;\n20 cell_mindur[i][j] â†\nmin{|ğ‘Ÿ.ğ‘‡|:ğ‘Ÿâˆˆcell};\n21 cell_maxdur[i][j] â†\nmax{|ğ‘Ÿ.ğ‘‡|:ğ‘Ÿâˆˆcell};\n22ğ‘—â†ğ‘—+1;\n23ğ‘˜â†ğ‘˜+|cell|;\n24ğ‘–â†ğ‘–+1;\n25â„â†â„+|column|;\n26return (grid ,col_minstart ,col_maxend ,cell_mindur ,\ncell_maxdur );\nEach column is further partitioned in cells in a similar way. First\nwe sort the tuples in the column by increasing duration. Then we\ndefine cells of size ğ‘ by repeatedly invoking NEXTSUBSEQ (line 17).\nAgain, if there are more than ğ‘ tuples with the same duration, they\nwill all be assigned to the same cell, which will then be deemed\nheavy . Similarly to columns, also cells are complemented by two\narrays of ancillary information: cell_mindur stores the minimum\nduration in each cell to be used at query time to find the first cell\nto inspect, while cell_maxdur stores the maximum duration in\neach cell, which at query time will determine when to stop iterating\nthrough cells.\nFinally, tuples in each cell are sorted by the end time. This is\nuseful at query time, since it allows to stop queries early, as we shall\ndiscuss in the proof of Theorem 5.3.\nWe now formally define light and heavy columns and cells, since\nthey play a key role in the proof of the performance of our index\nstructure.Definition 4.3. For a given page size ğ‘ , aheavy column (resp.\ncell) contains >ğ‘ 2(resp. >ğ‘ ) intervals. Conversely, a light column\n(resp. cell) contains â‰¤ğ‘ 2(resp.â‰¤ğ‘ ) intervals.\nExample 4.4. Figure 4 shows the grid constructed by Algorithm 2\non our example relation from Figure 2, with page size parameter\nğ‘ =70. Note that the columns, which contain ğ‘ 2=4 900 tuples each,\nspan different ranges of start times, adapting to the density of the\npoints. Within each column, the points are partitioned according to\nthe distribution of durations. Since many drug prescriptions have\nthe same short durations, the cells at the bottom of the columns are\nheavy (or span only a few different duration values). In this setting,\na uniform grid would suffer from a high imbalance in the number of\ntuples in each cell.\n4.3 Querying the Index\nGiven a range-duration query with time range ğ‘¡=[ğ‘¡ğ‘ ,ğ‘¡ğ‘’)and dura-\ntion interval ğ‘‘=[ğ‘‘ğ‘šğ‘–ğ‘›,ğ‘‘ğ‘šğ‘ğ‘¥], recall that a tuple ğ‘Ÿâˆˆrsatisfies the\nquery if the conditions (1),(2), and (3)specified in Section 4.1 are\nmet. We report the conditions here for convenience:\n|ğ‘Ÿ.ğ‘‡|âˆˆ[ğ‘‘ğ‘šğ‘–ğ‘›,ğ‘‘ğ‘šğ‘ğ‘¥] (1)\nğ‘Ÿ.ğ‘‡ğ‘’<ğ‘¡ğ‘  (2)\nğ‘Ÿ.ğ‘‡ğ‘ <ğ‘¡ğ‘’ (3)\nThe pseudocode for querying the index structure is reported in\nAlgorithm 3. First, we seek the index of the last column that might\ncontain matching tuples. To this end, we perform a binary search on\nthe array col_minstart to find the last column ğ‘–such that the\nminimum start time in the column (which is the column bound) is\nstrictly less than the query end time ğ‘¡ğ‘’(line 2). This ensures that the\ncolumn contains at least one tuple satisfying condition (3). Then, we\niterate backwards through columns until column ğ‘–cannot possibly\ncontain tuples satisfying the query. For this, we use the support array\ncol_maxend : ifcol_maxend[i] â‰¤ğ‘¡ğ‘ then we know that all\nthe columns at index â‰¤ğ‘–contain tuples that stop earlier than the start\nof the query range. Hence, we can avoid inspecting them because of\ncondition (2).\nFor each column that we consider, a binary search on the array\ncell_mindur[i] is performed, looking for the last cell ğ‘—such\nthat the minimum duration in the cell (which is the cell bound) is â‰¤\nto the maximum duration ğ‘‘ğ‘šğ‘ğ‘¥ specified in the query (line 4). Doing\nso ensures that at least one tuple in the cell satisfies the upper bound\nof condition (1). Then, we iterate backwards through the cells until\nwe reach a cell whose maximum duration is less than the minimum\ndurationğ‘‘ğ‘šğ‘–ğ‘›of the query. At this point we stop since condition (1)\ncan no longer be satisfied.\nFinally, we iterate through the tuples of each considered cell by\ndecreasing end time and stop as soon as condition (2)is no longer\nsatisfied (line 7). All the intervals that satisfy the query are returned\nin the result.\n4.4 Updating the Index\nOur index data structure can be extended to support both insertion\nand removal of tuples.\nInterval Insertion. To insert a tuple ğ‘Ÿ, we query the index for the\nstart timeğ‘Ÿ.ğ‘‡ğ‘ and the duration|ğ‘Ÿ.ğ‘‡|to identify the cell that should\n\nIndexing Temporal Relations for Range-Duration Queries\nAlgorithm 3: QUERY (grid ,[ğ‘¡ğ‘ ,ğ‘¡ğ‘’),[ğ‘‘ğ‘šğ‘–ğ‘›,ğ‘‘ğ‘šğ‘ğ‘¥])\nInput: A range duration query with time range [ğ‘¡ğ‘ ,ğ‘¡ğ‘’)and duration\nrange[ğ‘‘ğ‘šğ‘–ğ‘›,ğ‘‘ğ‘šğ‘ğ‘¥]; An index grid with the ancillary\narrays col_minstart ,cell_mindur ,col_maxend ,\nandcell_maxdur\n1ğ‘Ÿğ‘’ğ‘ â†âˆ…;\n2ğ‘–â†argmaxğ‘–col_minstart[i] <ğ‘¡ğ‘’;\n3whileğ‘–â‰¥0âˆ§ğ‘¡ğ‘ <col_maxend[i] do\n4ğ‘—â†argmaxğ‘—cell_mindur[i][j] â‰¤ğ‘‘ğ‘šğ‘ğ‘¥;\n5 whileğ‘—â‰¥0âˆ§cell_maxdur[i][j] â‰¥ğ‘‘ğ‘šğ‘–ğ‘› do\n6 forğ‘Ÿâˆˆgrid[i][j] do\n7 ifğ‘Ÿ.ğ‘‡ğ‘’â‰¤ğ‘¡ğ‘ then\n8 break ;\n9 if|ğ‘Ÿ.ğ‘‡|âˆˆ[ğ‘‘ğ‘šğ‘–ğ‘›,ğ‘‘ğ‘šğ‘ğ‘¥]âˆ§ğ‘Ÿ.ğ‘‡ğ‘ <ğ‘¡ğ‘’then\n10 ğ‘Ÿğ‘’ğ‘ â†ğ‘Ÿğ‘’ğ‘ âˆª{ğ‘Ÿ};\n11ğ‘—â†ğ‘—âˆ’1;\n12ğ‘–â†ğ‘–âˆ’1;\n13returnğ‘Ÿğ‘’ğ‘ \ncontainğ‘Ÿ. Inserting new intervals into cells might make them grow\ntoo large to be able to maintain the performance guarantees on the\nquery time. Luckily, as we shall see in Section 5, heavy columns and\ncells do not present issues upon insertions by virtue of containing\nintervals that all share either the same start time or the same duration.\nIf a light column exceeds size ğ‘ 2, we replace it with two new columns.\nSimilarly, if a light cell exceeds size ğ‘ , we replace it with two new\ncells.\nSplitting a column entails to consider all the intervals it contains,\nusing NEXTSUBSEQ withğ‘=ğ‘ 2/2+1to find the breakpoint at\nwhich to split (this way, we balance the size of the new columns).\nFor each of the two new columns that replace the original column,\nwe apply NEXTSUBSEQ to split them into cells, exactly as in the\ninner loop of the index construction. The array col_minstart\nandcol_maxend are updated to reflect the replacement of the old\ncolumn with the new ones.\nSimilarly, to split a cell that exceeds size ğ‘ in columnğ‘–we\nuseNEXTSUBSEQ withğ‘=ğ‘ /2+1to find a new breakpoint\nand replace the cell with two new cells. The auxiliary structures\ncell_mindur[i] andcell_maxdur[i] are updated accord-\ningly.\nBoth in the case of column and cell splitting, we sort all the\nintervals in the newly created cells by end time.\nInterval Removal. As for the removal of a tuple ğ‘Ÿfrom the index,\nwe query the index to find the cell grid[i][j] that contains ğ‘Ÿ.ğ‘‡\nand remove the interval from the cell. As a consequence, the cell\nmight contain fewer than ğ‘ /2items. As we shall see with Lemma 5.2,\nit is crucial for the performance of the index that cells contain at\nleastğ‘ /2intervals.\nTherefore, upon removal of an element from a cell, we check\nwhether the sum of elements of the cell and either of the adja-\ncent ones is less than ğ‘ . In such case, we merge the two cells,\ni.e., we replace them with a single cell where all intervals are then\nsorted by decreasing end time. After cells are merged, the arrayscell_mindur[i] andcell_maxdur[i] are updated as well\nto reflect the changes.\nSimilarly, a removal might cause a column to have fewer than ğ‘ 2/2\nelements. We then apply a similar reasoning. If the sum of the num-\nber of items in the column and either adjacent ones is smaller than\nğ‘ 2/2, we merge the two columns, i.e., the two columns are replaced\nby a single one. NEXTSUBSEQ is then called to find the breakpoints\nto divide the newly created column into cells. After the two columns\nare merged, the arrays col_minstart andcol_maxend are\nupdated to reflect the changes.\n5 ANALYSIS\nIn this section, we provide guarantees on the time required by all\nthe operations supported by our index structure. We assume that the\nindex is built by partitioning first in the time dimension, and then\nin the duration dimension. The asymptotic results presented in this\nsection hold for both dimension orderings.\n5.1 Querying the Index\nBefore stating our main result, we establish the following fundamen-\ntal facts about heavy columns and cells.\nLEMMA 5.1. A heavy cell in a heavy column contains only copies\nof the same interval.\nPROOF .By construction, a heavy column contains only intervals\nwith the same start time. Similarly, a heavy cell contains only in-\ntervals with the same duration. Therefore, a heavy cell in a heavy\ncolumn contains intervals with the same start time and duration, i.e.,\nmultiple copies of the same interval. â–¡ â–¡\nLEMMA 5.2. TheRD- INDEX with parameter ğ‘ overğ‘›intervals\nhasğ‘‚\u0010\nğ‘›\nğ‘ 2\u0011\ncolumns, each having ğ‘‚\u0000ğ‘›\nğ‘ \u0001cells.\nPROOF .To upper bound the number of columns into which a\nrelation can be partitioned, we first devise a set of intervals that will\nforce RD- INDEX to use the maximum number of columns. Consider\na relation such that exactly ğ‘ 2/2+1intervals have start time 1, ğ‘ 2/2\nintervals have start time 2, ğ‘ 2/2+1intervals have start time 3, and\nso on. RD- INDEX will have to build a separate light column for\neach distinct start time. Note that if the subsets of intervals with the\nsame start time were any smaller, RD- INDEX would create columns\ncontaining more than one start time, resulting in fewer columns\noverall. Therefore, each column has size â‰¥ğ‘ 2/2, which implies that\nthere areğ‘‚\u0000ğ‘›/ğ‘ 2\u0001columns.\nAs for cells, the worst case occurs if all intervals fall in the\nsame column. With a reasoning similar to the above argument, we\nhave that these ğ‘›intervals in one column are partitioned in ğ‘‚(ğ‘›/ğ‘ )\ncells. â–¡ â–¡\nTHEOREM 5.3. Given an index over a set of ğ‘›intervals and a\npage sizeğ‘ , the time for answering a range-duration query is\nğ‘‚\u0010ğ‘›\nğ‘ 2logğ‘›\nğ‘ +ğ‘›\nğ‘ +ğ‘ 2+ğ‘˜\u0011\nwhereğ‘˜is the number of intervals matching the query predicate.\nPROOF .Letğ‘¡=[ğ‘¡ğ‘ ,ğ‘¡ğ‘’)be the query interval and ğ‘‘=[ğ‘‘ğ‘šğ‘–ğ‘›,ğ‘‘ğ‘šğ‘ğ‘¥]\nbe the duration range of the query. Recall that the index construction\n\nMatteo Ceccarello, Anton DignÃ¶s, Johann Gamper, and Christina Khnaisser\nalgorithm may create a heavy column or cell when it cannot break\ndown a group of intervals because they all share the same start time\nor duration. Furthermore, recall that by construction light columns\n(resp. cells) are of size â‰¤ğ‘ 2(resp.â‰¤ğ‘ ).\nA range-duration query defines a query polygon in the start\ntimeÃ—duration space, as depicted in Figure 4. For a given cell\ngrid[i][j] , we denote by ğ‘˜ğ‘–ğ‘—the number of intervals in the cell\nthat match the query. The query time is comprised of two parts: (a)\nwe have to find the correct range of cells to query, and (b) we have\nto filter the intervals in each cell to retrieve the ones that are part of\nthe answer.\nAs for part (a), finding the cells to inspect, we first determine the\nlast column that can contain tuples satisfying the query constraint.\nFor this we use binary search over the ğ‘‚\u0000ğ‘›/ğ‘ 2\u0001boundaries between\ncolumns (Lemma 5.2) in ğ‘‚\u0000log(ğ‘›/ğ‘ 2)\u0001time. Iterating backwards\nthrough the columns visits at most ğ‘‚\u0000ğ‘›/ğ‘ 2\u0001columns. In each such\ncolumn, to find the last cell with intervals satisfying the duration\nconstraint, we do a binary search over the ğ‘‚(ğ‘›/ğ‘ )cells in the column\n(Lemma 5.2). Therefore, the overall time to find the correct cells is\nğ‘‚\u0010\nlogğ‘›\nğ‘ 2+ğ‘›\nğ‘ 2logğ‘›\nğ‘ \u0011\n=ğ‘‚\u0010ğ‘›\nğ‘ 2logğ‘›\nğ‘ \u0011\nAs for part (b), enumerating the results from the cells, we can\ndistinguish four possible cases for a cell grid[i][j] :\n(1)Both the cellâ€™s durations range and start times range fall within\nthe query polygon. In such cells, the query constraints on the\nduration and the start time are satisfied by construction. The\nalgorithm considers just the intervals of grid[i][j] , which\nare part of the output (since it iterates over the cellâ€™s intervals\nby decreasing end time). Therefore, the time spent enumerating\nintervals from the cell is ğ‘‚\u0000ğ‘˜ğ‘–ğ‘—\u0001. Also, note that this is the only\ncase in which a heavy cell in a heavy column is visited by the\nquery algorithm. Such cells can potentially have ğ‘‚(ğ‘›)copies of\nthe same interval. If the algorithm visits the cell, then it means\nthat such copies are all part of the output, hence we pay Î˜\u0000ğ‘˜ğ‘–ğ‘—\u0001\nin the complexity.\n(2)The cellâ€™s start times all satisfy the query constraints, but not\nall its durations do so. The cell must be light, otherwise all its\ndurations would be equal and would need to satisfy the duration\nconstraint, contradicting the assumption. Therefore, the algorithm\nhas to evaluate ğ‘‚(ğ‘ )intervals.\n(3)The cellâ€™s durations all satisfy the query constraints, but not all\nits start times do. In this case we cannot be in a heavy column\n(which contains a single start time) and thus the column contains\nat mostğ‘ 2intervals.\n(4)Only some of the cellâ€™s intervals satisfy both constraints. In this\ncase neither the column nor the cell can be heavy, therefore the\nalgorithm must only evaluate ğ‘‚(ğ‘ )intervals.\nAll the cells of type (1) account for at most ğ‘‚(ğ‘˜)in terms of running\ntime. As for cells of type (2) there are at most ğ‘‚\u0000ğ‘›/ğ‘ 2\u0001of them.\nOverall they account for ğ‘‚\u0000ğ‘›\nğ‘ \u0001interval evaluations. Cells of type\n(3) account for ğ‘‚\u0000ğ‘ 2\u0001interval evaluations overall. Finally, there is\na constant number of cells of type (4) (which are at the corners\nof the query polygon). These cells therefore account for at most\nğ‘‚(ğ‘ )interval evaluations in total. Overall, the time to evaluate the\nintervals in the cells is ğ‘‚\u0000ğ‘›\nğ‘ +ğ‘ 2+ğ‘˜\u0001.Combining this last result with the time to find the range of cells\nto query, we have that the overall query time is\nğ‘‚\u0010ğ‘›\nğ‘ 2logğ‘›\nğ‘ +ğ‘›\nğ‘ +ğ‘ 2+ğ‘˜\u0011\n.\nâ–¡ â–¡\nThe above theorem exposes a fundamental tradeoff of our data\nstructure: using a smaller page size allows to improve the precision\nof the data structure (by looking at fewer intervals that are not part\nof the query output), while at the same time increasing the number\nof columns that need to be queried. In Section 6.5 we investigate\nexperimentally the effect of ğ‘ on the performance, finding that the\nbest performance is attained for ğ‘›/ğ‘ 2âˆˆ[50,500].\nThe choice of the order of partitioning has no impact on the\ntheoretical complexity results, however it affects the practical per-\nformance as we will discuss in Section 6 (Figure 10). It turns out\nthat generally it is better to index first the duration and then the start\ntime, as summarized in the following observation.\nOBSERVATION 1.While changing the order in which dimensions\nare indexed does not change the asymptotic behavior of RD- INDEX ,\nthe choice of such order affects the practical performance. In fact\nrange and duration constraints play different roles in queries. When\nquerying for duration, the position of start times on the timeline\ndoes not affect the outcome of a query. Conversely, a range query\ncan be rephrased in terms of start times and durations. Therefore,\nrange queries can benefit from a partition of the duration dimension,\nsince it implies a partition of the end times. Furthermore, duration\nconstraints are typically much more selective than range constraints.\nTherefore, indexing first by duration might imply that a query has\nto iterate through fewer columns, compared to the case where start\ntimes are indexed first.\n5.2 Index Construction and Update\nTHEOREM 5.4. Given a set of ğ‘›intervals, building the index\nrequires time ğ‘‚(ğ‘›logğ‘›).\nPROOF .Computing column boundaries for the duration requires\ntimeğ‘‚(ğ‘›logğ‘›)for sorting the tuples, while invoking Algorithm 1\nrequires time ğ‘‚(ğ‘›)for iterating through the sorted intervals to find\nthe boundaries: in fact, each of the ğ‘›intervals is visited at most once.\nLetğ‘›ğ‘–be the number of intervals in the ğ‘–-th column. Sorting the\ncolumn requires time ğ‘‚(ğ‘›ğ‘–logğ‘›ğ‘–). Then, the invocation of Algo-\nrithm 1 to find cell boundaries requires time ğ‘‚(ğ‘›ğ‘–), following the\nsame argument as above. Similarly, let ğ‘›ğ‘–ğ‘—be the size of cell ğ‘–ğ‘—. Sort-\ning its tuples by end time requires time ğ‘‚\u0000ğ‘›ğ‘–ğ‘—logğ‘›ğ‘–ğ‘—\u0001. Therefore,\nthe time for running the inner loop is ğ‘‚(ğ‘›logğ‘›)overall, and the\ntheorem follows. â–¡ â–¡\nTHEOREM 5.5. Inserting a tuple ğ‘Ÿinto the index requires time\nğ‘‚\u0000logğ‘›/ğ‘ +ğ‘›/ğ‘ +ğ‘ 2logğ‘ \u0001.\nPROOF .Finding the cell that should contain ğ‘Ÿ.ğ‘‡requires perform-\ning first a binary search over the ğ‘‚\u0010\nğ‘›\nğ‘ 2\u0011\ncolumns and then over the\nğ‘‚\u0000ğ‘›\nğ‘ \u0001cells of the resulting column (by Lemma 5.2), for a total time\nğ‘‚(logğ‘›/ğ‘ ).\nNote that a heavy column or cell does not need to be split, since\nby definition they can contain more than ğ‘ 2(resp.ğ‘ ) intervals, as long\n\nIndexing Temporal Relations for Range-Duration Queries\nas they all have the same start time (resp. duration). Therefore we\nconsider only the case of splitting a light column or light cell. Split-\nting a column with ğ‘ 2+1intervals requires to first apply Algorithm 1\n(which takes time ğ‘‚\u0000ğ‘ 2\u0001), sort the newly created columns (requiring\ntime at most ğ‘‚\u0000ğ‘ 2logğ‘ \u0001) and then applying again Algorithm 1 on\nthe new columns to find the cells (for an overall time of ğ‘‚\u0000ğ‘ 2\u0001). Fur-\nthermore, inserting the new column boundaries in order in the sorted\narray of boundaries requires ğ‘‚\u0010\nğ‘›\nğ‘ 2\u0011\ntime. By similar reasoning, split-\nting a cell with ğ‘ +1intervals requires time ğ‘‚(ğ‘ logğ‘ ), and updating\ncell boundaries by inserting in-order requires ğ‘‚\u0000ğ‘›\nğ‘ \u0001. â–¡ â–¡\nIn a similar way we can prove the following theorem.\nTHEOREM 5.6. Removing a tuple ğ‘Ÿfrom the index requires time\nğ‘‚(logğ‘›/ğ‘ +ğ‘›/ğ‘ ).\n6 EXPERIMENTAL EV ALUATION\nIn this section, we evaluate experimentally our proposed index. To\nframe this evaluation, we consider the following data structures as\nbaselines: The implementation of B-T REEprovided by the Rust stan-\ndard library, which is optimized for CPU cache usage; intervals are\nindexed by duration in this case. The INTERVAL -TREE index [ 25],\nwhich we implemented ourselves, indexing intervals by their posi-\ntion on the timeline. The GRID-FILE[31] and PERIOD -INDEX â˜…[4],\nwhich we also implemented, and which index both start times and du-\nrations. We also consider the R-T REE as a baseline, specifically the\nR*-T REE [3]: intervals are mapped to points identified by the start\ntime and duration of the interval, and then indexed by the R*-T REE.\nOur proposed data structure will be denoted with RD- INDEX -TD\nwhen start time is indexed before duration, and with RD- INDEX -\nDTotherwise. In cases where the order of the dimensions is not\nrelevant to the discussion, we will use RD- INDEX instead. To ac-\ncount for the potential shortcomings of our implementations, we will\nalso evaluate the relative performance of the data structures with\nimplementation-independent metrics [26].\nWe aim to answer the following questions:\n(Q1) How robust are the indices over different workloads? (Â§ 6.2)\n(Q2) How do indices compare on mixed workloads? (Â§ 6.3)\n(Q3) How do query times relate with the query selectivity? (Â§ 6.4)\n(Q4) How does the page size parameter affect the performance of\nthe index? (Â§ 6.5)\n(Q5) How does the performance scale with respect to the size of the\ndataset? (Â§ 6.6)\n(Q6) What is the performance of updating the index? (Â§ 6.7)\n6.1 Setup and Datasets\nWe implemented our index and the baseline competitors in Rust\n1.44.1, using a configurable and extensible framework [ 2]. Code\nand data are available at https://github.com/Cecca/temporal-index.\nThe experiments presented in this section were run on a machine\nequipped with 94 GB of memory and a Intel Â®Xeon Â®CPU E5-2667\nv3 @ 3.20GHz processor.\nAs a benchmark we consider the following datasets and work-\nloads:\nFlight :A set of 701 353 flights, identified by their takeoff and\nlanding time at the granularity of minute, covering August 2018.Query ranges on this dataset are generated at random. Time range\ndurations are uniformly distributed between one and 31 days, and\nduration ranges are uniformly distributed between one minute and\none day.\nWebkit :1 547 419 file edits in the Webkit source code repos-\nitory. Intervals represent the timespan between successive edits to\na file. Query ranges on this dataset are generated at random. Time\nrange durations are uniformly distributed between one minute and\none year, and duration ranges are uniformly distributed between up\nto three years.\nMimicIII :.4 134 909 drug prescriptions from the open MimicIII\ndatabase [ 20]. Each prescription is characterized by its start and\nend day. Queries, generated at random, span the entire domain of\ntimes and durations: the former take values âˆˆ[1,40 251], the latter\nâˆˆ[1,200]. The large span of start times (110 years) is due to the\nanonymization procedure applied to the database.\nSynthetic :Randomly generated datasets with 10 million in-\ntervals by default. The interval start times are uniformly distributed\nin[1,ğ‘›], whereğ‘›is the size of the dataset; interval durations follow\na Zipf distribution with ğ›½=1.\nFigure 5 reports the distribution of start times and durations of the\nthree real-world datasets. Note that the start times of the Flight\ndataset are approximately uniformly distributed, with durations ge-\nometrically distributed. The MimicIII dataset has similarly dis-\ntributed start times, and duration values which are very concentrated.\nFinally, the Webkit dataset has a distribution of durations similar\ntoFlight , but the distribution of start times is skewed towards\nrecent times, meaning that more file edits have been done recently.\nIn the experiments we run a count query subject to range and\nduration constraints. Evaluating a count query rather than reporting\nthe matching tuples, allows to measure the time to retrieve the tuples,\nrather than the time to print them to screen or write them to a file.\n6.2 Robustness of Index Structures Across\nDifferent Workloads\nIn the first set of experiments, we consider both real-world and\nsynthetic datasets (with 10 million intervals). Table 1 reports, under\ndifferent combinations of dataset/query workload, an overview on\nthe performance of different index structures on three indicators: the\nqueries per second, the time to build the index, and the size of the\nindex. The latter is measured in terms of bytes per interval, i.e., the\nnumber of bytes that the index uses for each input interval. Since we\nare representing intervals as pairs of 64-bits unsigned integers, 16\nbytes per interval are required just to represent the data, and thus are\na lower bound on this performance metric. Dark blue and light blue\ncells denote, respectively, the best and second-best performing data\nstructures in terms of queries per second. For index structures that\ntake parameters, we report on the best configuration. In particular,\nwe defer the discussion of the effect of different parameterizations\nof RD- INDEX to Section 6.5.\nWe remark that the overall difference in throughput for different\nworkloads is due to the different output sizes: duration-only queries\nare in general less selective than range-duration queries, hence it\ntakes more time to iterate through the output. This explains why, in\n\nMatteo Ceccarello, Anton DignÃ¶s, Johann Gamper, and Christina Khnaisser\nFigure 5: Histograms of the start times and durations of the three real-world datasets considered in this paper.\nTable 1: Performance attained by the tested indices on different workloads. Performance is characterized in terms of three numbers:\nthe number of queries per second (larger is better), the time to build the index in milliseconds (smaller is better), and the index size\n(smaller is better) expressed as the number of bytes used for each indexed interval. Configurations with a dark blue background\nare the ones with the best throughput for a dataset/queryset combination, light blue cells denote the second-best data structure. The\nfastest index construction times are underlined, and the smallest indices are highlighted in bold.\nQueries per second |Index build time|Bytes per interval\ndataset query RD- INDEX -TD RD- INDEX -DT GRID-FILE PERIOD -INDEX â˜… R*-T REE INTERVAL -TREE B-T REE\nrange-only 415|1 024|16.1 602|889|16.1 468|445|27.7 242|2 392|57.1 12|3 358|80.0 272|3 636|50.1 8|2 505|31.4\nduration-only 842|1 030|16.1 734|785|17.1 77|983|24.1 69|6 139|178.1 106|3 398|80.0 12|3 636|50.1 43 103|2 469|31.4 Synthetic\nrange-duration 11 737|1 052|16.1 14 085|829|16.5 1 581|857|24.1 1 403|6 566|178.1 2 591|3 402|80.0 215|3 674|50.1 502|2 529|31.4\nrange-only 54 945|42|17.1 57 471|44|16.1 49 505|20|23.2 15 015|80|40.0 4 921|195|97.9 51 813|139|44.5 2 798|39|23.3\nduration-only 4 182|44|16.1 4 218|33|21.3 3 791|20|23.2 538|111|62.9 378|205|97.9 683|150|44.5 714 286|43|23.3 Flight\nrange-duration 232 558|45|16.7 208 333|39|16.6 188 679|20|23.2 29 940|95|62.9 21 786|193|97.9 43 860|139|44.5 13 514|47|23.3\nrange-only 416|116|16.1 467|115|16.1 445|56|23.0 83|540|119.0 30|468|97.7 384|274|48.3 47|252|36.4\nduration-only 2 544|112|16.1 2 520|104|16.9 1 938|52|23.0 57|559|124.4 234|469|97.7 157|274|48.3 3 393|255|36.4 Webkit\nrange-duration 3 159|112|16.1 3 133|99|16.9 2 322|51|23.0 80|737|322.6 258|468|97.7 256|274|48.3 758|252|36.4\nrange-only 372|240|16.0 391|213|16.0 391|143|23.5 381|451|24.3 38|1 112|81.2 347|717|46.6 127|138|21.2\nduration-only 3 560|275|16.0 2 876|202|17.5 2 075|184|27.7 520|718|41.3 452|1 175|81.2 76|733|46.6 2 500 000|141|21.2 MimicIII\nrange-duration 10 246|241|16.0 10 730|201|17.5 5 227|185|27.7 1 779|720|41.3 1 384|1 081|81.2 232|721|46.6 3 347|135|21.2\ngeneral, range-duration queries enjoy a higher throughput across all\nthe index structures.\nConsider first the performance in terms of throughput, i.e., the first\nmeasure. We observe that RD- INDEX always performs better than\ncompetitors on range-duration queries and on range-only queries\n(with the exception of MimicIII , where it ties with GRID-FILE).\nFor duration-only queries it is always the second best solution after\ntheB-T REE. We will, however, see in the next section how RD-\nINDEX surpasses the B-T REE as soon as a few queries constraining\nalso the range are introduced in the workload.\nWe also observe that the GRID -FILE ranks second or third in\nseveral cases. Recall that this data structure is rather similar to RD-\nINDEX , the difference being that the latter is adaptive to the input\ndistribution. This shows the performance benefits of a data structure\nthat takes into account the data distribution.\nConcerning the other performance indicators, we note that the\nindex construction time of RD- INDEX is comparable with the one\nof the GRID-FILEandB-T REE, and generally much faster than the\nother approaches. As for the size of the index, RD- INDEX always\nproduces the smallest index, across all tested configurations, usingjust slightly more than the minimum 16 bytes to represent an interval.\nThe other approaches, especially pointer-based data structures such\nasB-T REE,INTERVAL -TREE, and R*-T REE require significantly\nmore space. The PERIOD -INDEX â˜…has a much higher space require-\nment compared to the others, since each interval may be replicated\nseveral times.\nIn summary, RD- INDEX is a data structure that provides fast\nquery times, is fast to build, and has negligible space overhead.\n6.3 Mixed Query Workloads\nWe now consider mixed query workloads, consisting of a mix of\nrange-only, duration-only, and range-duration queries. Rather than\nfixing a particular combination of queries, we use the data of Ta-\nble 1 to estimate the throughput of workloads composed by any\ncombination of queries. Let ğ‘“ğ‘Ÿğ‘‘,ğ‘“ğ‘Ÿ, andğ‘“ğ‘‘be, respectively, the frac-\ntion of range-duration, range-only, and duration-only queries in the\nmixed query workload, with ğ‘“ğ‘Ÿğ‘‘+ğ‘“ğ‘Ÿ+ğ‘“ğ‘‘=1. Similarly, for a given\nalgorithm and dataset, let ğœ™ğ‘Ÿğ‘‘,ğœ™ğ‘Ÿ, andğœ™ğ‘‘be the throughputs of\nrange-duration, range-only, and duration-only queries, as reported\nin Table 1. The throughput of the combined workload will then be\n\nIndexing Temporal Relations for Range-Duration Queries\nFigure 6: Ternary plots of best performing index structure for\ndifferent mixed workloads, on the four different datasets. The\nonline supplementary material provides an interactive version\nof this plot.\nthe weighted harmonic mean of the average rates reported in Table 1\n1\nğ‘“ğ‘Ÿğ‘‘\nğœ™ğ‘Ÿğ‘‘+ğ‘“ğ‘‘\nğœ™ğ‘‘+ğ‘“ğ‘Ÿ\nğœ™ğ‘Ÿ.\nFigure 6 provides a summary of the best performing algorithm for\nany workload that can be concocted with the formula above. In each\nternary plot, each point in the triangle identifies a combination of\nrange-only, duration-only, and range-duration queries. For instance,\nthe center of each triangle corresponds to a workload composed in\nequal parts by the three types of queries. Portions of the triangles are\ncolored according to the best-performing index for the corresponding\nworkloads. We observe that RD- INDEX is the best performing index\nstructure in the vast majority of workloads. The exception is for\nworkloads where duration-only queries are the majority, where the\nB-T REEoutperforms RD- INDEX . On mixed workloads, we observe\nthat the performance of RD- INDEX is rather robust to the ordering\nof indexing dimensions. This can be verified in Figure 13 in Appen-\ndix A, which reports ternary plots of the throughput of all algorithms\non all datasets for all mixed workloads. The online supplemental\nmaterial3provides an interactive tool to explore the performance of\nall different index structures on any mixed workload.\n6.4 Distribution of Query Times Against\nSelectivity\nWe investigate the relationship between the selectivity of queries (i.e.,\nthe fraction of the input that satisfies them) and the time taken by\n3https://cecca.github.io/temporal-index/different data structures to answer them. Given that range-duration\nqueries constrain both the time and the duration ranges, for a query\nwe can define the time selectivity as the fraction of the input that\nsatisfies the time range constraint of the query, and the duration se-\nlectivity as the fraction of the input satisfying the duration constraint\nof the query.\nFor a given dataset, we build a query set such that queries are\nuniformly distributed on the timeÃ—duration selectivity plane: this\nway we have queries that are very selective in only one dimension,\nvery selective in both dimensions, or not selective at all. The goal is\nto investigate the behavior of each index structure for queries with\ndifferent characteristics. To account for the overhead of measuring\ntime and to level out the effect of the CPU cache, we run each query\n100 consecutive times and report the average. For RD- INDEX , we\nset the page size to ğ‘ =200, which is a good parameter choice of all\nthe datasets we consider.\nFigure 7 reports the results for such a setup, with 1024 queries\narranged in a 32Ã—32 grid, running on a synthetic dataset with 10\nmillion intervals, with uniformly distributed start times and Zipf\ndistributed durations. Colors encode the fraction of the dataset in-\nspected by each query. This metric allows a more implementation-\nindependent assessment of the relative performance of different data\nstructures. When reading Figure 7, remember that less selective\nqueries require more time just to iterate through the output. Interest-\ningly, different data structures exhibit different patterns in this plot,\nas a result of how they access data.\nTheINTERVAL -TREEplot exhibits vertical bands. The data struc-\nture is able to select intervals only based on their position on the\ntimeline. Therefore, for a fixed time selectivity of the query the frac-\ntion of intervals inspected (and thus the time to answer the query)\ndoes not depend on the selectivity in the duration dimension, since\nall the candidate intervals need to be examined. For similar reasons,\ntheB-T REE shows horizontal bands. Data structures that explicitly\nindex both dimensions, instead, tend to exhibit a more diagonal\npattern, in particular RD- INDEX , with a milder effect for GRID-\nFILEandR*-T REE. The pattern exhibited by PERIOD -INDEX â˜…\ntends to be more similar to the INTERVAL -TREE. This means that\nthis index is more responsive to queries that are selective in the\ntime dimension. This is to be expected since PERIOD -INDEX â˜…is\nadaptive to the distribution of start times in the dataset. Its worse\nperformance compared to RD- INDEX andGRID-FILEfor queries of\na given selectivity is explained by the fact that some intervals might\nbe represented multiple times in the index.\nFigure 8 reports the performance against the overall selectivity of\nthe same queries. The performance is assessed in terms of the frac-\ntion of the input inspected by each query, which are represented as\ndots whose position along the ğ‘¥axis encodes their overall selectivity.\nIdeally, a data structure should answer queries by inspecting just\nthe tuples which are part of the output. This behavior is represented\nby the black diagonal in Figure 8. We observe that RD- INDEX in-\ndeed shows the ideal behavior. As for the GRID-FILE, since the\nefficiency in answering a query depends on the density of the cells\nbeing considered, the performance is in many cases far from ideal.\nThis can be seen from the fact that several queries are far away from\nthe ideal diagonal. The B-T REE indexes intervals by their duration.\nAs such, duration-only queries are answered most efficiently: In\nFigure 8 such queries lie on the ideal diagonal. On the other hand,\n\nMatteo Ceccarello, Anton DignÃ¶s, Johann Gamper, and Christina Khnaisser\nFigure 7: Heatmaps of the performance of index structures against selectivity in the time and duration dimensions. The top row\nreports the time, in milliseconds, required to answer a query with a given time and duration selectivity. The plots report the fraction\nof intervals (over the total ğ‘›=107) examined by each query. A fraction larger than 1 means that a query examined the same interval\nmore than once. For readability the color scales are binned every 5 percentiles, therefore the scales are non linear. In both plots,\nlighter is better.\nFigure 8: Number of examined intervals against selectivity of the query. Each point represents a query: red dots â€¢are range-only\nqueries, blue dots â€¢are duration-only queries, black dots â€¢are range-duration queries. The black line represents the ideal behavior,\nin which only matching intervals are examined. Note that all the plots except for the one related to the P ERIOD -INDEX â˜…share theğ‘¦\naxis: in all plots the black diagonal has slope 1.\nrange-only queries are answered by simply enumerating the entire\ndataset, thus scoring 1 on Figure 8. Similar considerations hold for\ntheINTERVAL -TREE, with range-only queries performing the bestand duration-only queries performing the worst. Finally, PERIOD -\nINDEX â˜…inspects the same tuples multiple times for the majority of\nqueries, which are thus very far away from the ideal diagonal line in\nthe plot.\n\nIndexing Temporal Relations for Range-Duration Queries\nFigure 9: Performance of RD- INDEX under a non-optimal pa-\nrameter configuration.\nSo far, we have reported on the performance of a good config-\nuration (i.e. ğ‘ =200) ofRD- INDEX , which gives a behavior close\nto optimal. Figure 9 reports, in the same scenario of Figure 8, the\nperformance of RD- INDEX with a time-duration ordering and page\nsizeğ‘ =10. As we will see in the next section, this configuration is\nnot ideal (the page size is too small): indeed, for several queries we\nhave to visit more intervals than the precision of the query. This is\nespecially true for duration-only queries (blue dots). Nevertheless,\neven under this non-optimal setting, RD- INDEX still performs better\nthan the other approaches, i.e., points are more concentrated towards\nthe diagonal.\n6.5 Dependency on the Page Size and the\nIndexing Order\nThe aim of this section is to investigate the influence of the page\nsize and the order in which the two dimensions are indexed. We use\ntwo datasets with 10 million intervals each: the first has uniform\nstart times and skewed durations (Zipf distribution), the second\nhas skewed start times and uniformly distributed durations. As for\nthe query workload, batches of 10 000 range-duration, range-only,\nand duration-only queries are considered. The page size is varied\nbetween 1 and 10 000.\nDue to the size of the dataset, any page size ğ‘ aboveâˆšğ‘›â‰ˆ3 162\nresults in a degenerate configuration, where there is a single column\n(of sizeğ‘ 2=ğ‘›) that contains all the intervals. In this case the intervals\nare partitioned according to a single dimension, with the number\nof cells controlled by the page size parameter. This situation might\nalso occur at lower values of the page size parameter, depending on\nthe number of distinct values in the dimension being partitioned. On\nthe other hand, for page size 1, each cell of the grid contains only\nintervals with the same start time and duration, and it contains all of\nthem. Querying the data structure in this case amounts to perform\nbinary searches directly on the values of the domains of start times\nand durations.\nFigure 10: Dependency of the performance, in terms of queries\nper second, on the page size parameter.\nFigure 10 reports the results of this experiment in terms of queries\nper second. To ease the comparison between the plots, we rescale\nthe throughput by the highest value for each combination of dataset\nand query workload. Degenerate configurations resulting in a single\ncolumn are reported as triangles rather than dots. We observe very\ndifferent trends for different query workloads.\nConsider first the dataset with skewed durations. For range-duration\nqueries, both orderings of dimensions exhibit a similar behavior. The\npeak performance is reached by intermediate values around the page\nsize. If we consider duration-only queries the profile changes. Index-\ning first by duration (blue line) slightly favors smaller page sizes,\nwhich imply smaller columns and thus a more fine grained access\nto the data. Indexing first by time, instead, requires a duration-only\nquery to traverse all the columns. In this scenario high page sizes\nare favored, since they translate into fewer columns to be iterated\nthrough. For range-only queries we observe a symmetric pattern.\nWhen data has skew on the start times, the patterns exhibited by\nthe two indexing orders are rather different. First, we note that the\ngap between the best configurations of the two indexing orders for\nrange-duration queries is much wider than with the other dataset.\nSecond, while indexing first by duration exhibits a similar pattern\non both datasets, indexing first by start time performs best in the\ndegenerate cases of a single column, i.e., with no partitioning of\nthe start times at all. This is a consequence of Observation 1. In\nparticular, having skewed start times exacerbates the difference in\nselectivity between the range and duration constraints: when start\ntimes are very concentrated on the timeline, the range constraint of\na query is satisfied by either most of the intervals or by almost none.\nOverall, we observe that indexing first by duration has either\nbetter or comparable performance compared to indexing first by\ntime. Therefore, we recommend to choose the former ordering of\ndimensions when building an RD- INDEX .\n\nMatteo Ceccarello, Anton DignÃ¶s, Johann Gamper, and Christina Khnaisser\n6.6 Scalability with Respect to the Input Size\nTo test the scalability of the index structures, we consider range-\nduration queries and datasets of increasing size, while maintaining\nthe output size constant. This allows to assess the influence of the\ninput size on the performance without conflating the results with the\ntime required to iterate over larger outputs.\nWe consider the three real-world datasets, along with a synthetic\none with uniform start times and Zipf-distributed durations, which is\nrepresentative of the distribution of many real-world datasets. Then,\nwe artificially increase their size as follows. Given a dataset and\na scale parameter ğœ‚, let Â¯ğ‘¡be the span of time covered by all the\nintervals in the dataset. We make ğœ‚copies of each interval and shift\ncopyğ‘–in time byğ‘–Â·Â¯ğ‘¡, forğ‘–âˆˆ[0,ğœ‚). The underlying idea is to repeat\nthe temporal patterns of the dataset on a longer time scale, simulating\nthe scenario in which the relation grows over time.\nFigure 11 reports for each scale factor the performance of the\nbest configuration of each algorithm. First, we note that in general\nthe relative performance of the data structures does not change at\ndifferent dataset scales. There are some notable exceptions. The\nperformance of B-T REE degrades by a factor â‰ˆ10 from scale 1 to\nscale 10. The reason is that the B-T REE indexes the durations, and\nunder our synthetic construction the number of intervals associated\nto each duration increases by the same scale of the dataset. For\nsimilar reasons, the performance of RD- INDEX -DTdegrades, albeit\nin a much less pronounced way.\nOn Webkit, the performance of GRID-FILEandPERIOD -INDEX â˜…\nincreases with the scale as the dataset: the effect of our synthetic\nconstruction in this case is to compensate for the skew in the start\ntimes, giving to both data structures the chance of better partitioning\nthe time dimension.\n6.7 Insertion Performance\nWe now focus on the insertion operation, considering RD- INDEX ,\nB-T REE,R*-T REE, and INTERVAL -TREE. We omit from the com-\nparison PERIOD -INDEX â˜…, which does not support updates, and\nGRID-FILE, which is a static data structure that requires to know the\nrange of the data beforehand.\nFor each of the four datasets we considered in the previous sec-\ntions, we insert intervals into initially empty indices. The expectation\nis that the insertion performance degrades as the index grows larger.\nTo measure this effect, we insert the intervals in batches of 50 000,\nmeasuring the time for each batch in order to be able to estimate\nthe throughput of the insertions as the size of the index grows. We\nperform two sets of experiments. In the first set of experiments, the\nintervals are inserted in random order. In the second set of experi-\nments, intervals are inserted by increasing start time, which simulates\na natural append only scenario for time-related data.\nFigure 12 reports the results of these experiments. The x-axis re-\nports the fraction of the dataset that has been inserted into the index.\nThe y-axis reports, in logarithmic scale, the number of insertions\nper second. In most cases, the best performing data structure for the\ninsertion workload is the B-T REE, both when data is presented in\nrandom and sorted order. RD- INDEX follows on the second place for\nmost datasets, with the ordering first by time and then by duration\nusually performing better. For randomly-ordered insertions, we note\nthat the performance of RD- INDEX tends to slightly decrease as\nFigure 11: Scalability of the index structures for the increasing\ndataset sizes. Performance is measured in queries per second.\nEach point corresponds to the best configuration of the given\ndata structure for a particular dataset scale, up to 50 times the\noriginal size. The workload is of range-duration queries.\nthe index size increases. In the more realistic append only scenario,\ninstead, the insertion throughput of RD- INDEX is more stable and\ntends to remain constant over time. This is expected, since in such a\nsetting only the last column (when the start time is the first dimen-\nsion being indexed, otherwise the last cell of each column) is ever\nrestructured, requiring very little data to be moved. Furthermore,\nthe performance in this scenario improves compared to the random\norder of insertions, in particular on the MimicIII dataset, and is\non par with the B-T REE on all datasets.\n7 CONCLUSIONS\nRD- INDEX is an index data structure for temporal intervals that\nallows to answer efficiently range-duration queries. Our approach,\nwhich has provable theoretical guarantees, lends itself to a simple\nand efficient implementation. In particular, its ability to adapt to the\ndistribution of the input data makes it compare favorably with the\nstate of the art on a variety of workloads. In particular, RD- INDEX\nhas superior performance on a vast array of mixed workloads.\nA direction of future work is to extend the RD- INDEX to support\ninterval joins [ 35], thus addressing several needs with a single index.\nFurthermore, the favorable comparison with the R*-T REE suggests\nthat a promising research direction is to extend the ideas on which\nRD- INDEX is based to the case of multidimensional spatial data.\nREFERENCES\n[1]L. Arge, M. de Berg, H. J. Haverkort, and K. Yi. The priority r-tree: A practically\nefficient and worst-case optimal r-tree. ACM Trans. Algorithms , 4(1):9:1â€“9:30,\n2008.\n\nIndexing Temporal Relations for Range-Duration Queries\n(a) Intervals inserted in random order\n (b) Intervals inserted by increasing start time\nFigure 12: Performance of the insertion for different index structures. The left group of plots (a) reports the throughput of insertions\nwhen intervals are added in random order. The right group of plots (b) focuses on insertions by increasing start time, i.e. a append\nonly scenario.\n[2]M. AumÃ¼ller and M. Ceccarello. Running experiments with confidence and sanity.\nInSISAP , volume 12440 of Lecture Notes in Computer Science , pages 387â€“395.\nSpringer, 2020.\n[3]N. Beckmann, H. Kriegel, R. Schneider, and B. Seeger. The r*-tree: An efficient\nand robust access method for points and rectangles. In SIGMOD , pages 322â€“331.\nACM Press, 1990.\n[4]A. Behrend, A. DignÃ¶s, J. Gamper, P. Schmiegelt, H. V oigt, M. Rottmann, and\nK. Kahl. Period index: A learned 2d hash index for range and duration queries. In\nSSTD , pages 100â€“109. ACM, 2019.\n[5]A. Behrend, R. Manthey, G. SchÃ¼ller, and M. Wieneke. Detecting moving objects\nin noisy radar data using a relational database. In ADBIS , volume 5739 of Lecture\nNotes in Computer Science , pages 286â€“300. Springer, 2009.[6]A. Behrend, P. Schmiegelt, J. Xie, R. Fehling, A. Ghoneimy, Z. H. Liu, E. S. Chan,\nand D. Gawlick. Temporal state management for supporting the real-time analysis\nof clinical data. In ADBIS (2) , volume 312 of Advances in Intelligent Systems and\nComputing , pages 159â€“170. Springer, 2014.\n[7]M. Berg, M. Kreveld, M. Overmars, and O. Schwarzkopf. More geometric\ndata structures. In Computational Geometry , pages 211â€“233. Springer Berlin\nHeidelberg, 2000.\n[8]M. H. BÃ¶hlen, A. DignÃ¶s, J. Gamper, and C. S. Jensen. Temporal data management\n- an overview. In eBISS , volume 324 of Lecture Notes in Business Information\nProcessing , pages 51â€“83. Springer, 2017.\n[9]M. H. BÃ¶hlen, J. Gamper, and C. S. Jensen. Multi-dimensional aggregation for\ntemporal data. In EDBT , pages 257â€“275, 2006.\n\nMatteo Ceccarello, Anton DignÃ¶s, Johann Gamper, and Christina Khnaisser\n[10] P. Bouros and N. Mamoulis. A forward scan based plane sweep algorithm for\nparallel interval joins. PVLDB , 10(11):1346â€“1357, 2017.\n[11] P. Bouros, N. Mamoulis, D. Tsitsigkos, and M. Terrovitis. In-memory interval\njoins. VLDB J. , 30(4):667â€“691, 2021.\n[12] F. Cafagna and M. H. BÃ¶hlen. Disjoint interval partitioning. VLDB J. , 26(3):447â€“\n466, 2017.\n[13] A. DignÃ¶s, M. H. BÃ¶hlen, and J. Gamper. Overlap interval partition join. In\nSIGMOD , pages 1459â€“1470. ACM, 2014.\n[14] A. DignÃ¶s, M. H. BÃ¶hlen, J. Gamper, and C. S. Jensen. Extending the kernel of\na relational DBMS with comprehensive support for sequenced temporal queries.\nACM Trans. Database Syst. , 41(4):26:1â€“26:46, 2016.\n[15] A. DignÃ¶s, M. H. BÃ¶hlen, J. Gamper, C. S. Jensen, and P. Moser. Leveraging\nrange joins for the computation of overlap joins. VLDB J. , 2021.\n[16] J. Ding, V . Nathan, M. Alizadeh, and T. Kraska. Tsunami: A learned\nmulti-dimensional index for correlated data and skewed workloads. CoRR ,\nabs/2006.13282, 2020.\n[17] H. Edelsbrunner. Dynamic rectangle intersection searching. Technical Report 47,\nInstitute for Information Processing, Technical University of Graz, Austria, 1980.\n[18] R. A. Finkel and J. L. Bentley. Quad trees: A data structure for retrieval on\ncomposite keys. Acta Informatica , 4:1â€“9, 1974.\n[19] Y . Hayashi and D. L. Paterson. Strategies for reduction in duration of antibiotic\nuse in hospitalized patients. 52(10):1232â€“1240, Apr. 2011.\n[20] A. E. W. Johnson, T. J. Pollard, L. Shen, L.-W. H. Lehman, M. Feng, M. Ghassemi,\nB. Moody, P. Szolovits, L. A. Celi, and R. G. Mark. Mimic-iii, a freely accessible\ncritical care database. Scientific data , 3(1):1â€“9, 2016.\n[21] M. Kaufmann. Storing and processing temporal data in a main memory column\nstore. Proc. VLDB Endow. , 6(12):1444â€“1449, 2013.\n[22] M. Kaufmann, A. A. Manjili, P. Vagenas, P. M. Fischer, D. Kossmann, F. FÃ¤rber,\nand N. May. Timeline index: a unified data structure for processing queries on\ntemporal data in SAP HANA. In SIGMOD , pages 1173â€“1184. ACM, 2013.\n[23] N. Kline and R. T. Snodgrass. Computing temporal aggregates. In ICDE , pages\n222â€“231. IEEE Computer Society, 1995.\n[24] T. Kraska, A. Beutel, E. H. Chi, J. Dean, and N. Polyzotis. The case for learned\nindex structures. In SIGMOD , pages 489â€“504. ACM, 2018.\n[25] H. Kriegel, M. PÃ¶tke, and T. Seidl. Managing intervals efficiently in object-\nrelational databases. In PVLDB , pages 407â€“418. Morgan Kaufmann, 2000.\n[26] H. Kriegel, E. Schubert, and A. Zimek. The (black) art of runtime evaluation: Are\nwe comparing algorithms or implementations? Knowl. Inf. Syst. , 52(2):341â€“378,\n2017.\n[27] K. G. Kulkarni and J. Michels. Temporal features in SQL: 2011. SIGMOD Rec. ,\n41(3):34â€“43, 2012.\n[28] D. G. J. Larsson and C.-F. Flach. Antibiotic resistance in the environment. Nov.\n2021.\n[29] B. Moon, I. F. V . LÃ³pez, and V . Immanuel. Efficient algorithms for large-scale\ntemporal aggregation. IEEE Trans. Knowl. Data Eng. , 15(3):744â€“759, 2003.\n[30] V . Nathan, J. Ding, M. Alizadeh, and T. Kraska. Learning multi-dimensional\nindexes. In SIGMOD , pages 985â€“1000. ACM, 2020.\n[31] J. Nievergelt, H. Hinterberger, and K. C. Sevcik. The grid file: An adaptable,\nsymmetric multikey file structure. ACM Trans. Database Syst. , 9(1):38â€“71, 1984.\n[32] F. Persia, F. Bettini, and S. Helmer. An interactive framework for video surveil-\nlance event detection and modeling. In CIKM , pages 2515â€“2518. ACM, 2017.\n[33] D. Piatov and S. Helmer. Sweeping-based temporal aggregation. In SSTD , volume\n10411 of Lecture Notes in Computer Science , pages 125â€“144. Springer, 2017.\n[34] D. Piatov, S. Helmer, and A. DignÃ¶s. An interval join optimized for modern\nhardware. In ICDE , pages 1098â€“1109. IEEE Computer Society, 2016.\n[35] D. Piatov, S. Helmer, A. DignÃ¶s, and F. Persia. Cache-efficient sweeping-based\ninterval joins for extended allen relation predicates. VLDB J. , 2021.\n[36] H. Samet. Foundations of multidimensional and metric data structures . Morgan\nKaufmann, 2006.\n[37] G. SchÃ¼ller, A. Behrend, and R. Manthey. AIMS: an sql-based system for airspace\nmonitoring. In GIS-IWGS , pages 31â€“38. ACM, 2010.\n[38] G. SchÃ¼ller, P. Schmiegelt, and A. Behrend. Supporting phase management in\nstream applications. In ADBIS , volume 7503 of Lecture Notes in Computer\nScience , pages 332â€“345. Springer, 2012.\n[39] D. J. Shapiro, M. Hall, S. C. Lipsett, A. L. Hersh, L. Ambroggio, S. S. Shah, T. V .\nBrogan, J. S. Gerber, D. J. Williams, C. G. Grijalva, A. J. Blaschke, and M. I.\nNeuman. Short- versus prolonged-duration antibiotics for outpatient pneumonia\nin children. 234:205â€“211.e1, July 2021.\n[40] T. Ulrich. Loose octrees. In Game Programming Gems , pages 444â€“453. Charles\nRiver Media, 2000.\nA ADDITIONAL FIGURES\nIn this appendix we report on the complete results for mixed work-\nloads of which Figure 6 in Section 6.3 is a compact summary.Figure 13 reports a collection of ternary plots, each focusing on\na particular combination of dataset (columns) and index structure\n(rows). In order to accommodate on a readable color scale the wide\nrange of throughputs encompassed by indices, we color-code the\nthroughput divided by percentiles. Therefore, brighter colors corre-\nspond to high throughputs, dark colors correspond to low through-\nputs. Furthermore, these throughput percentiles are computed per\ndataset .\nTherefore, we can read Figure 13 as follows. For a given dataset\n(sayRandom ) we can take two different algorithms (e.g. RD- INDEX\nandB-T REE) and compare the color in any given area of the two cor-\nresponding ternary plots. For instance focusing on the bottom-right\ncorner of the ternary plots, corresponding to workloads comprised\nmostly of range-duration queries, we observe that the plot for RD-\nINDEX features a brighter color than the one for B-T REE. This\nmeans that the throughput of RD- INDEX is higher than the one of\nB-T REE for those workloads.\nFrom Figure 13 we can therefore notice that the behavior of RD-\nINDEX -DTandRD- INDEX -TDis very similar, across all datasets.\nFurthermore, we notice that with the exception of workloads where\nthe vast majority of queries are duration-only, RD- INDEX enjoys a\nhigher throughput than other indices.\n\nIndexing Temporal Relations for Range-Duration Queries\nFigure 13: Performance of all index structures on all considered datasets, for different mixed workloads.",
  "textLength": 79345
}